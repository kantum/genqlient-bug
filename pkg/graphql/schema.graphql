schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}
scalar citext
scalar date
scalar jsonb
"Hardware codec ID"
scalar smartcodec_CodecId
"The commercial name"
scalar smartcodec_CodecName
"Datarate Name"
scalar smartcodec_DatarateName
"Line ID"
scalar smartcodec_LineId
"The company that made the product"
scalar smartcodec_Manufacturer
"The product ID from the manufacturer"
scalar smartcodec_ProductId
"Frequency used to sample the sound"
scalar smartcodec_Samplingrate
"A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt."
scalar smartcodec_URL
"Represents empty values"
scalar smartcodec_Void
"this unique identifier allows management of the subscription"
scalar smartcodec_mutation_streams_subscriptionId
"The error message"
scalar smartcodec_query_lines_items_error_error_message
"phone number, sip account, ip address, ..."
scalar smartcodec_query_lines_items_setup_addresses_items_address
scalar timestamptz
scalar uuid
"Actions are commands that can be executed."
type Action {
  "An array relationship"
  buttons(
    "distinct select on columns"
    distinctOn: [ButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ButtonOrderBy!],
    "filter the rows returned"
    where: ButtonBoolExp
  ): [Button!]!
  "An aggregate relationship"
  buttonsAggregate(
    "distinct select on columns"
    distinctOn: [ButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ButtonOrderBy!],
    "filter the rows returned"
    where: ButtonBoolExp
  ): ButtonAggregate!
  "The command of the action."
  command: String!
  "The date and time when the action was created."
  createdAt: timestamptz!
  "The date and time when the action was deleted."
  deletedAt: timestamptz
  "The description of the action."
  description: String!
  "The unique identifier of the action."
  id: uuid!
  "The label of the action is used to override the name in the UI."
  label: String!
  "The name of the action."
  name: String!
  "The type of the action."
  type: String!
  "The date and time when the action was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "action"
"""
type ActionAggregate {
  aggregate: ActionAggregateFields
  nodes: [Action!]!
}
"""
aggregate fields of "action"
"""
type ActionAggregateFields {
  count(columns: [ActionSelectColumn!], distinct: Boolean): Int!
  max: ActionMaxFields
  min: ActionMinFields
}
"aggregate max on columns"
type ActionMaxFields {
  "The command of the action."
  command: String
  "The date and time when the action was created."
  createdAt: timestamptz
  "The date and time when the action was deleted."
  deletedAt: timestamptz
  "The description of the action."
  description: String
  "The unique identifier of the action."
  id: uuid
  "The label of the action is used to override the name in the UI."
  label: String
  "The name of the action."
  name: String
  "The type of the action."
  type: String
  "The date and time when the action was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type ActionMinFields {
  "The command of the action."
  command: String
  "The date and time when the action was created."
  createdAt: timestamptz
  "The date and time when the action was deleted."
  deletedAt: timestamptz
  "The description of the action."
  description: String
  "The unique identifier of the action."
  id: uuid
  "The label of the action is used to override the name in the UI."
  label: String
  "The name of the action."
  name: String
  "The type of the action."
  type: String
  "The date and time when the action was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "action"
"""
type ActionMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Action!]!
}
"Addresses are postal addresses."
type Address {
  "An object relationship"
  contact: Contact
  "The contact that the address belongs to."
  contactId: uuid
  "The date and time when the address was created."
  createdAt: timestamptz!
  "The date and time when the address was deleted."
  deletedAt: timestamptz
  "The unique identifier of the address."
  id: uuid!
  "The date and time when the address was last updated."
  updatedAt: timestamptz!
  "The date and time when the address was validated."
  validatedAt: timestamptz
  "The text value of the address."
  value: String!
}
"""
aggregated selection of "address"
"""
type AddressAggregate {
  aggregate: AddressAggregateFields
  nodes: [Address!]!
}
"""
aggregate fields of "address"
"""
type AddressAggregateFields {
  count(columns: [AddressSelectColumn!], distinct: Boolean): Int!
  max: AddressMaxFields
  min: AddressMinFields
}
"aggregate max on columns"
type AddressMaxFields {
  "The contact that the address belongs to."
  contactId: uuid
  "The date and time when the address was created."
  createdAt: timestamptz
  "The date and time when the address was deleted."
  deletedAt: timestamptz
  "The unique identifier of the address."
  id: uuid
  "The date and time when the address was last updated."
  updatedAt: timestamptz
  "The date and time when the address was validated."
  validatedAt: timestamptz
  "The text value of the address."
  value: String
}
"aggregate min on columns"
type AddressMinFields {
  "The contact that the address belongs to."
  contactId: uuid
  "The date and time when the address was created."
  createdAt: timestamptz
  "The date and time when the address was deleted."
  deletedAt: timestamptz
  "The unique identifier of the address."
  id: uuid
  "The date and time when the address was last updated."
  updatedAt: timestamptz
  "The date and time when the address was validated."
  validatedAt: timestamptz
  "The text value of the address."
  value: String
}
"""
response of any mutation on the table "address"
"""
type AddressMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Address!]!
}
"Buttons can be used to trigger actions."
type Button {
  "An object relationship"
  action: Action
  "The action that the button triggers."
  actionId: uuid
  "An aggregate relationship"
  cardButtonsAggregate(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): CardButtonAggregate!
  "An array relationship"
  card_buttons(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): [CardButton!]!
  "The color of the button when it is off."
  colorOff: citext!
  "The color of the button when it is on."
  colorOn: citext!
  "The date and time when the button was created."
  createdAt: timestamptz!
  "The date and time when the button was deleted."
  deletedAt: timestamptz
  "The description of the button."
  description: String!
  "Whether the button is global."
  global: Boolean!
  "The icon of the button."
  icon: String!
  "The unique identifier of the button."
  id: uuid!
  "The label of the button is used to override the name in the UI."
  label: String!
  "The name of the button."
  name: String!
  "The position of the button."
  position: Int!
  show: Boolean!
  "The date and time when the button was last updated."
  updatedAt: timestamptz!
  "The url of the button."
  url: String!
}
"""
aggregated selection of "button"
"""
type ButtonAggregate {
  aggregate: ButtonAggregateFields
  nodes: [Button!]!
}
"""
aggregate fields of "button"
"""
type ButtonAggregateFields {
  avg: ButtonAvgFields
  count(columns: [ButtonSelectColumn!], distinct: Boolean): Int!
  max: ButtonMaxFields
  min: ButtonMinFields
  stddev: ButtonStddevFields
  stddevPop: ButtonStddev_popFields
  stddevSamp: ButtonStddev_sampFields
  sum: ButtonSumFields
  varPop: ButtonVar_popFields
  varSamp: ButtonVar_sampFields
  variance: ButtonVarianceFields
}
"aggregate avg on columns"
type ButtonAvgFields {
  "The position of the button."
  position: Float
}
"aggregate max on columns"
type ButtonMaxFields {
  "The action that the button triggers."
  actionId: uuid
  "The color of the button when it is off."
  colorOff: citext
  "The color of the button when it is on."
  colorOn: citext
  "The date and time when the button was created."
  createdAt: timestamptz
  "The date and time when the button was deleted."
  deletedAt: timestamptz
  "The description of the button."
  description: String
  "The icon of the button."
  icon: String
  "The unique identifier of the button."
  id: uuid
  "The label of the button is used to override the name in the UI."
  label: String
  "The name of the button."
  name: String
  "The position of the button."
  position: Int
  "The date and time when the button was last updated."
  updatedAt: timestamptz
  "The url of the button."
  url: String
}
"aggregate min on columns"
type ButtonMinFields {
  "The action that the button triggers."
  actionId: uuid
  "The color of the button when it is off."
  colorOff: citext
  "The color of the button when it is on."
  colorOn: citext
  "The date and time when the button was created."
  createdAt: timestamptz
  "The date and time when the button was deleted."
  deletedAt: timestamptz
  "The description of the button."
  description: String
  "The icon of the button."
  icon: String
  "The unique identifier of the button."
  id: uuid
  "The label of the button is used to override the name in the UI."
  label: String
  "The name of the button."
  name: String
  "The position of the button."
  position: Int
  "The date and time when the button was last updated."
  updatedAt: timestamptz
  "The url of the button."
  url: String
}
"""
response of any mutation on the table "button"
"""
type ButtonMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Button!]!
}
"aggregate stddev on columns"
type ButtonStddevFields {
  "The position of the button."
  position: Float
}
"aggregate stddev_pop on columns"
type ButtonStddev_popFields {
  "The position of the button."
  position: Float
}
"aggregate stddev_samp on columns"
type ButtonStddev_sampFields {
  "The position of the button."
  position: Float
}
"aggregate sum on columns"
type ButtonSumFields {
  "The position of the button."
  position: Int
}
"aggregate var_pop on columns"
type ButtonVar_popFields {
  "The position of the button."
  position: Float
}
"aggregate var_samp on columns"
type ButtonVar_sampFields {
  "The position of the button."
  position: Float
}
"aggregate variance on columns"
type ButtonVarianceFields {
  "The position of the button."
  position: Float
}
"Calendars are UI components to display events."
type Calendar {
  "The date and time when the calendar was created."
  createdAt: timestamptz!
  "The date and time when the calendar was deleted."
  deletedAt: timestamptz
  "The description of the calendar."
  description: String!
  "An array relationship"
  events(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): [Event!]!
  "An aggregate relationship"
  eventsAggregate(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): EventAggregate!
  "The unique identifier of the calendar."
  id: uuid!
  "The label of the calendar is used to override the name in the UI."
  label: String!
  "An object relationship"
  line: Line!
  "The name of the calendar."
  name: String!
  "The date and time when the calendar was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "calendar"
"""
type CalendarAggregate {
  aggregate: CalendarAggregateFields
  nodes: [Calendar!]!
}
"""
aggregate fields of "calendar"
"""
type CalendarAggregateFields {
  count(columns: [CalendarSelectColumn!], distinct: Boolean): Int!
  max: CalendarMaxFields
  min: CalendarMinFields
}
"aggregate max on columns"
type CalendarMaxFields {
  "The date and time when the calendar was created."
  createdAt: timestamptz
  "The date and time when the calendar was deleted."
  deletedAt: timestamptz
  "The description of the calendar."
  description: String
  "The unique identifier of the calendar."
  id: uuid
  "The label of the calendar is used to override the name in the UI."
  label: String
  "The name of the calendar."
  name: String
  "The date and time when the calendar was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type CalendarMinFields {
  "The date and time when the calendar was created."
  createdAt: timestamptz
  "The date and time when the calendar was deleted."
  deletedAt: timestamptz
  "The description of the calendar."
  description: String
  "The unique identifier of the calendar."
  id: uuid
  "The label of the calendar is used to override the name in the UI."
  label: String
  "The name of the calendar."
  name: String
  "The date and time when the calendar was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "calendar"
"""
type CalendarMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Calendar!]!
}
"Cards are UI components that can be used to display different information."
type Card {
  "The background color of the card."
  backgroundColor: citext!
  "The border color of the card."
  borderColor: citext!
  "An aggregate relationship"
  cardButtonsAggregate(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): CardButtonAggregate!
  "An aggregate relationship"
  cardGridsAggregate(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): CardGridAggregate!
  "An aggregate relationship"
  cardTagsAggregate(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): CardTagAggregate!
  "An array relationship"
  card_buttons(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): [CardButton!]!
  "An array relationship"
  card_grids(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): [CardGrid!]!
  "An array relationship"
  card_tags(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): [CardTag!]!
  "An object relationship"
  card_type: CardType!
  "The date and time when the card was created."
  createdAt: timestamptz!
  "The date and time when the card was deleted."
  deletedAt: timestamptz
  "The description of the card."
  description: String!
  "The unique identifier of the card."
  id: uuid!
  "The label of the card is used to override the name in the UI."
  label: String!
  "An object relationship"
  line: Line
  "The line that the card is associated with."
  lineId: uuid
  "The name of the card."
  name: String!
  "The slot color of the card."
  slotColor: citext!
  "The text color of the card."
  textColor: citext!
  "The type of the card."
  type: CardTypeEnum!
  "The date and time when the card was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "card"
"""
type CardAggregate {
  aggregate: CardAggregateFields
  nodes: [Card!]!
}
"""
aggregate fields of "card"
"""
type CardAggregateFields {
  count(columns: [CardSelectColumn!], distinct: Boolean): Int!
  max: CardMaxFields
  min: CardMinFields
}
"Card button is a many to many relationship between cards and buttons."
type CardButton {
  "An object relationship"
  button: Button!
  buttonId: uuid!
  "An object relationship"
  card: Card!
  cardId: uuid!
  createdAt: timestamptz!
  deletedAt: timestamptz
  updatedAt: timestamptz!
}
"""
aggregated selection of "card_button"
"""
type CardButtonAggregate {
  aggregate: CardButtonAggregateFields
  nodes: [CardButton!]!
}
"""
aggregate fields of "card_button"
"""
type CardButtonAggregateFields {
  count(columns: [CardButtonSelectColumn!], distinct: Boolean): Int!
  max: CardButtonMaxFields
  min: CardButtonMinFields
}
"aggregate max on columns"
type CardButtonMaxFields {
  buttonId: uuid
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  updatedAt: timestamptz
}
"aggregate min on columns"
type CardButtonMinFields {
  buttonId: uuid
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  updatedAt: timestamptz
}
"""
response of any mutation on the table "card_button"
"""
type CardButtonMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [CardButton!]!
}
"Card Grid is a join table between cards and grids."
type CardGrid {
  "An object relationship"
  card: Card!
  "The card that is in the grid."
  cardId: uuid!
  "The date and time when the card grid was created."
  createdAt: timestamptz!
  "The date and time when the card grid was deleted."
  deletedAt: timestamptz
  "An object relationship"
  grid: Grid!
  "The grid that the card is in."
  gridId: uuid!
  "The position of the card in the grid."
  position: Int!
  "The date and time when the card grid was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "card_grid"
"""
type CardGridAggregate {
  aggregate: CardGridAggregateFields
  nodes: [CardGrid!]!
}
"""
aggregate fields of "card_grid"
"""
type CardGridAggregateFields {
  avg: CardGridAvgFields
  count(columns: [CardGridSelectColumn!], distinct: Boolean): Int!
  max: CardGridMaxFields
  min: CardGridMinFields
  stddev: CardGridStddevFields
  stddevPop: CardGridStddev_popFields
  stddevSamp: CardGridStddev_sampFields
  sum: CardGridSumFields
  varPop: CardGridVar_popFields
  varSamp: CardGridVar_sampFields
  variance: CardGridVarianceFields
}
"aggregate avg on columns"
type CardGridAvgFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate max on columns"
type CardGridMaxFields {
  "The card that is in the grid."
  cardId: uuid
  "The date and time when the card grid was created."
  createdAt: timestamptz
  "The date and time when the card grid was deleted."
  deletedAt: timestamptz
  "The grid that the card is in."
  gridId: uuid
  "The position of the card in the grid."
  position: Int
  "The date and time when the card grid was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type CardGridMinFields {
  "The card that is in the grid."
  cardId: uuid
  "The date and time when the card grid was created."
  createdAt: timestamptz
  "The date and time when the card grid was deleted."
  deletedAt: timestamptz
  "The grid that the card is in."
  gridId: uuid
  "The position of the card in the grid."
  position: Int
  "The date and time when the card grid was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "card_grid"
"""
type CardGridMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [CardGrid!]!
}
"aggregate stddev on columns"
type CardGridStddevFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate stddev_pop on columns"
type CardGridStddev_popFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate stddev_samp on columns"
type CardGridStddev_sampFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate sum on columns"
type CardGridSumFields {
  "The position of the card in the grid."
  position: Int
}
"aggregate var_pop on columns"
type CardGridVar_popFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate var_samp on columns"
type CardGridVar_sampFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate variance on columns"
type CardGridVarianceFields {
  "The position of the card in the grid."
  position: Float
}
"aggregate max on columns"
type CardMaxFields {
  "The background color of the card."
  backgroundColor: citext
  "The border color of the card."
  borderColor: citext
  "The date and time when the card was created."
  createdAt: timestamptz
  "The date and time when the card was deleted."
  deletedAt: timestamptz
  "The description of the card."
  description: String
  "The unique identifier of the card."
  id: uuid
  "The label of the card is used to override the name in the UI."
  label: String
  "The line that the card is associated with."
  lineId: uuid
  "The name of the card."
  name: String
  "The slot color of the card."
  slotColor: citext
  "The text color of the card."
  textColor: citext
  "The date and time when the card was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type CardMinFields {
  "The background color of the card."
  backgroundColor: citext
  "The border color of the card."
  borderColor: citext
  "The date and time when the card was created."
  createdAt: timestamptz
  "The date and time when the card was deleted."
  deletedAt: timestamptz
  "The description of the card."
  description: String
  "The unique identifier of the card."
  id: uuid
  "The label of the card is used to override the name in the UI."
  label: String
  "The line that the card is associated with."
  lineId: uuid
  "The name of the card."
  name: String
  "The slot color of the card."
  slotColor: citext
  "The text color of the card."
  textColor: citext
  "The date and time when the card was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "card"
"""
type CardMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Card!]!
}
"""
columns and relationships of "card_tag"
"""
type CardTag {
  "An object relationship"
  card: Card!
  cardId: uuid!
  createdAt: timestamptz!
  deletedAt: timestamptz
  "An object relationship"
  tag: Tag!
  tagId: uuid!
  updatedAt: timestamptz!
}
"""
aggregated selection of "card_tag"
"""
type CardTagAggregate {
  aggregate: CardTagAggregateFields
  nodes: [CardTag!]!
}
"""
aggregate fields of "card_tag"
"""
type CardTagAggregateFields {
  count(columns: [CardTagSelectColumn!], distinct: Boolean): Int!
  max: CardTagMaxFields
  min: CardTagMinFields
}
"aggregate max on columns"
type CardTagMaxFields {
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  tagId: uuid
  updatedAt: timestamptz
}
"aggregate min on columns"
type CardTagMinFields {
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  tagId: uuid
  updatedAt: timestamptz
}
"""
response of any mutation on the table "card_tag"
"""
type CardTagMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [CardTag!]!
}
"Card types are the different types of cards that can be used."
type CardType {
  "An array relationship"
  cards(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): [Card!]!
  "An aggregate relationship"
  cardsAggregate(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): CardAggregate!
  "The comment of the card type."
  comment: String!
  "The value of the card type."
  value: String!
}
"""
aggregated selection of "card_type"
"""
type CardTypeAggregate {
  aggregate: CardTypeAggregateFields
  nodes: [CardType!]!
}
"""
aggregate fields of "card_type"
"""
type CardTypeAggregateFields {
  count(columns: [CardTypeSelectColumn!], distinct: Boolean): Int!
  max: CardTypeMaxFields
  min: CardTypeMinFields
}
"aggregate max on columns"
type CardTypeMaxFields {
  "The comment of the card type."
  comment: String
  "The value of the card type."
  value: String
}
"aggregate min on columns"
type CardTypeMinFields {
  "The comment of the card type."
  comment: String
  "The value of the card type."
  value: String
}
"""
response of any mutation on the table "card_type"
"""
type CardTypeMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [CardType!]!
}
"Codec is a type of line that represent a hardware codec."
type Codec {
  "The capabilities of the codec."
  capabilities: String!
  "The date and time when the codec was created."
  createdAt: timestamptz!
  "The date and time when the codec was deleted."
  deletedAt: timestamptz
  "The unique identifier of the codec."
  id: uuid!
  "An object relationship"
  line: Line!
  "The smartcodec id of the codec."
  smartcodecId: Int!
  "The date and time when the codec was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "codec"
"""
type CodecAggregate {
  aggregate: CodecAggregateFields
  nodes: [Codec!]!
}
"""
aggregate fields of "codec"
"""
type CodecAggregateFields {
  avg: CodecAvgFields
  count(columns: [CodecSelectColumn!], distinct: Boolean): Int!
  max: CodecMaxFields
  min: CodecMinFields
  stddev: CodecStddevFields
  stddevPop: CodecStddev_popFields
  stddevSamp: CodecStddev_sampFields
  sum: CodecSumFields
  varPop: CodecVar_popFields
  varSamp: CodecVar_sampFields
  variance: CodecVarianceFields
}
"aggregate avg on columns"
type CodecAvgFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"aggregate max on columns"
type CodecMaxFields {
  "The capabilities of the codec."
  capabilities: String
  "The date and time when the codec was created."
  createdAt: timestamptz
  "The date and time when the codec was deleted."
  deletedAt: timestamptz
  "The unique identifier of the codec."
  id: uuid
  "The smartcodec id of the codec."
  smartcodecId: Int
  "The date and time when the codec was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type CodecMinFields {
  "The capabilities of the codec."
  capabilities: String
  "The date and time when the codec was created."
  createdAt: timestamptz
  "The date and time when the codec was deleted."
  deletedAt: timestamptz
  "The unique identifier of the codec."
  id: uuid
  "The smartcodec id of the codec."
  smartcodecId: Int
  "The date and time when the codec was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "codec"
"""
type CodecMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Codec!]!
}
"aggregate stddev on columns"
type CodecStddevFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"aggregate stddev_pop on columns"
type CodecStddev_popFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"aggregate stddev_samp on columns"
type CodecStddev_sampFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"aggregate sum on columns"
type CodecSumFields {
  "The smartcodec id of the codec."
  smartcodecId: Int
}
"aggregate var_pop on columns"
type CodecVar_popFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"aggregate var_samp on columns"
type CodecVar_sampFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"aggregate variance on columns"
type CodecVarianceFields {
  "The smartcodec id of the codec."
  smartcodecId: Float
}
"Contacts are people that can be called."
type Contact {
  "An array relationship"
  addresses(
    "distinct select on columns"
    distinctOn: [AddressSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [AddressOrderBy!],
    "filter the rows returned"
    where: AddressBoolExp
  ): [Address!]!
  "An aggregate relationship"
  addressesAggregate(
    "distinct select on columns"
    distinctOn: [AddressSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [AddressOrderBy!],
    "filter the rows returned"
    where: AddressBoolExp
  ): AddressAggregate!
  "The date and time when the contact was created."
  createdAt: timestamptz!
  "The date and time when the contact was deleted."
  deletedAt: timestamptz
  "The description of the contact."
  description: String!
  "An array relationship"
  emails(
    "distinct select on columns"
    distinctOn: [EmailSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EmailOrderBy!],
    "filter the rows returned"
    where: EmailBoolExp
  ): [Email!]!
  "An aggregate relationship"
  emailsAggregate(
    "distinct select on columns"
    distinctOn: [EmailSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EmailOrderBy!],
    "filter the rows returned"
    where: EmailBoolExp
  ): EmailAggregate!
  "The unique identifier of the contact."
  id: uuid!
  "The label of the contact is used to override the name in the UI."
  label: String!
  "The name of the contact."
  name: String!
  "An array relationship"
  phones(
    "distinct select on columns"
    distinctOn: [PhoneSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [PhoneOrderBy!],
    "filter the rows returned"
    where: PhoneBoolExp
  ): [Phone!]!
  "An aggregate relationship"
  phonesAggregate(
    "distinct select on columns"
    distinctOn: [PhoneSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [PhoneOrderBy!],
    "filter the rows returned"
    where: PhoneBoolExp
  ): PhoneAggregate!
  "The type of the contact."
  type: String!
  "The date and time when the contact was last updated."
  updatedAt: timestamptz!
  "The user that the contact belongs to."
  userId: uuid
}
"""
aggregated selection of "contact"
"""
type ContactAggregate {
  aggregate: ContactAggregateFields
  nodes: [Contact!]!
}
"""
aggregate fields of "contact"
"""
type ContactAggregateFields {
  count(columns: [ContactSelectColumn!], distinct: Boolean): Int!
  max: ContactMaxFields
  min: ContactMinFields
}
"aggregate max on columns"
type ContactMaxFields {
  "The date and time when the contact was created."
  createdAt: timestamptz
  "The date and time when the contact was deleted."
  deletedAt: timestamptz
  "The description of the contact."
  description: String
  "The unique identifier of the contact."
  id: uuid
  "The label of the contact is used to override the name in the UI."
  label: String
  "The name of the contact."
  name: String
  "The type of the contact."
  type: String
  "The date and time when the contact was last updated."
  updatedAt: timestamptz
  "The user that the contact belongs to."
  userId: uuid
}
"aggregate min on columns"
type ContactMinFields {
  "The date and time when the contact was created."
  createdAt: timestamptz
  "The date and time when the contact was deleted."
  deletedAt: timestamptz
  "The description of the contact."
  description: String
  "The unique identifier of the contact."
  id: uuid
  "The label of the contact is used to override the name in the UI."
  label: String
  "The name of the contact."
  name: String
  "The type of the contact."
  type: String
  "The date and time when the contact was last updated."
  updatedAt: timestamptz
  "The user that the contact belongs to."
  userId: uuid
}
"""
response of any mutation on the table "contact"
"""
type ContactMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Contact!]!
}
"Devices are sound cards."
type Device {
  "The date and time when the device was created."
  createdAt: timestamptz!
  "The date and time when the device was deleted."
  deletedAt: timestamptz
  "The description of the device."
  description: String!
  "The unique identifier of the device."
  id: uuid!
  "The label of the device is used to override the name in the UI."
  label: String!
  "The name of the device."
  name: String!
  "The type of the device."
  type: String!
  "The date and time when the device was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "device"
"""
type DeviceAggregate {
  aggregate: DeviceAggregateFields
  nodes: [Device!]!
}
"""
aggregate fields of "device"
"""
type DeviceAggregateFields {
  count(columns: [DeviceSelectColumn!], distinct: Boolean): Int!
  max: DeviceMaxFields
  min: DeviceMinFields
}
"aggregate max on columns"
type DeviceMaxFields {
  "The date and time when the device was created."
  createdAt: timestamptz
  "The date and time when the device was deleted."
  deletedAt: timestamptz
  "The description of the device."
  description: String
  "The unique identifier of the device."
  id: uuid
  "The label of the device is used to override the name in the UI."
  label: String
  "The name of the device."
  name: String
  "The type of the device."
  type: String
  "The date and time when the device was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type DeviceMinFields {
  "The date and time when the device was created."
  createdAt: timestamptz
  "The date and time when the device was deleted."
  deletedAt: timestamptz
  "The description of the device."
  description: String
  "The unique identifier of the device."
  id: uuid
  "The label of the device is used to override the name in the UI."
  label: String
  "The name of the device."
  name: String
  "The type of the device."
  type: String
  "The date and time when the device was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "device"
"""
type DeviceMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Device!]!
}
"Emails are valid email addresses."
type Email {
  "An object relationship"
  contact: Contact
  "The contact that the email belongs to."
  contactId: uuid
  "The date and time when the email was created."
  createdAt: timestamptz!
  "The date and time when the email was deleted."
  deletedAt: timestamptz
  "The unique identifier of the email."
  id: uuid!
  "The date and time when the email was last updated."
  updatedAt: timestamptz!
  "The date and time when the email was validated."
  validatedAt: timestamptz
  "The email address of the email."
  value: citext!
}
"""
aggregated selection of "email"
"""
type EmailAggregate {
  aggregate: EmailAggregateFields
  nodes: [Email!]!
}
"""
aggregate fields of "email"
"""
type EmailAggregateFields {
  count(columns: [EmailSelectColumn!], distinct: Boolean): Int!
  max: EmailMaxFields
  min: EmailMinFields
}
"aggregate max on columns"
type EmailMaxFields {
  "The contact that the email belongs to."
  contactId: uuid
  "The date and time when the email was created."
  createdAt: timestamptz
  "The date and time when the email was deleted."
  deletedAt: timestamptz
  "The unique identifier of the email."
  id: uuid
  "The date and time when the email was last updated."
  updatedAt: timestamptz
  "The date and time when the email was validated."
  validatedAt: timestamptz
  "The email address of the email."
  value: citext
}
"aggregate min on columns"
type EmailMinFields {
  "The contact that the email belongs to."
  contactId: uuid
  "The date and time when the email was created."
  createdAt: timestamptz
  "The date and time when the email was deleted."
  deletedAt: timestamptz
  "The unique identifier of the email."
  id: uuid
  "The date and time when the email was last updated."
  updatedAt: timestamptz
  "The date and time when the email was validated."
  validatedAt: timestamptz
  "The email address of the email."
  value: citext
}
"""
response of any mutation on the table "email"
"""
type EmailMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Email!]!
}
"Events are calendar events. This is based on fullcalendar event object: https://fullcalendar.io/docs/event-object"
type Event {
  "Determines if the event is shown in the “all-day” section of relevant views. In addition, if true the time text is not displayed with the event."
  allDay: Boolean!
  "The eventBackgroundColor override for this specific event."
  backgroundColor: citext!
  "The eventBorderColor override for this specific event."
  borderColor: citext!
  "An object relationship"
  calendar: Calendar!
  calendarId: uuid!
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: String!
  "The eventConstraint override for this specific event."
  constraint: Boolean!
  "The date and time when the event was created."
  createdAt: timestamptz!
  "The date and time when the event was deleted."
  deletedAt: timestamptz
  "The description of the event."
  description: String!
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: String!
  "The value overriding the eventDurationEditable setting for this specific event."
  durationEditable: Boolean!
  "The value overriding the editable setting for this specific event."
  editable: Boolean!
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: timestamptz!
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: String!
  "An object relationship"
  event: Event
  "An array relationship"
  events(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): [Event!]!
  "An aggregate relationship"
  eventsAggregate(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): EventAggregate!
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps(
    "JSON select path"
    path: String
  ): jsonb!
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: String!
  "The unique identifier of the event."
  id: uuid!
  "The label of the event is used to override the name in the UI."
  label: String!
  "An object relationship"
  line: Line
  "A reference to the line this calendar is linked to"
  lineId: uuid
  "The name of the event."
  name: String!
  "The value overriding the eventOverlap setting for this specific event. If false, prevents this event from being dragged/resized over other events. Also prevents other events from being dragged/resized over this event. Does not accept a function."
  overlap: Boolean!
  "The value overriding the eventResourceEditable setting for this specific event."
  resourceEditable: Boolean!
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: uuid
  "Date object that obeys the current timeZone. When an event begins."
  start: timestamptz!
  "The value overriding the eventStartEditable setting for this specific event."
  startEditable: Boolean!
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: String!
  "The eventTextColor override for this specific event."
  textColor: citext!
  "The text that will appear on an event."
  title: String!
  "The date and time when the event was last updated."
  updatedAt: timestamptz!
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: String!
}
"""
aggregated selection of "event"
"""
type EventAggregate {
  aggregate: EventAggregateFields
  nodes: [Event!]!
}
"""
aggregate fields of "event"
"""
type EventAggregateFields {
  count(columns: [EventSelectColumn!], distinct: Boolean): Int!
  max: EventMaxFields
  min: EventMinFields
}
"aggregate max on columns"
type EventMaxFields {
  "The eventBackgroundColor override for this specific event."
  backgroundColor: citext
  "The eventBorderColor override for this specific event."
  borderColor: citext
  calendarId: uuid
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: String
  "The date and time when the event was created."
  createdAt: timestamptz
  "The date and time when the event was deleted."
  deletedAt: timestamptz
  "The description of the event."
  description: String
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: String
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: timestamptz
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: String
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: String
  "The unique identifier of the event."
  id: uuid
  "The label of the event is used to override the name in the UI."
  label: String
  "A reference to the line this calendar is linked to"
  lineId: uuid
  "The name of the event."
  name: String
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: uuid
  "Date object that obeys the current timeZone. When an event begins."
  start: timestamptz
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: String
  "The eventTextColor override for this specific event."
  textColor: citext
  "The text that will appear on an event."
  title: String
  "The date and time when the event was last updated."
  updatedAt: timestamptz
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: String
}
"aggregate min on columns"
type EventMinFields {
  "The eventBackgroundColor override for this specific event."
  backgroundColor: citext
  "The eventBorderColor override for this specific event."
  borderColor: citext
  calendarId: uuid
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: String
  "The date and time when the event was created."
  createdAt: timestamptz
  "The date and time when the event was deleted."
  deletedAt: timestamptz
  "The description of the event."
  description: String
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: String
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: timestamptz
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: String
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: String
  "The unique identifier of the event."
  id: uuid
  "The label of the event is used to override the name in the UI."
  label: String
  "A reference to the line this calendar is linked to"
  lineId: uuid
  "The name of the event."
  name: String
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: uuid
  "Date object that obeys the current timeZone. When an event begins."
  start: timestamptz
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: String
  "The eventTextColor override for this specific event."
  textColor: citext
  "The text that will appear on an event."
  title: String
  "The date and time when the event was last updated."
  updatedAt: timestamptz
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: String
}
"""
response of any mutation on the table "event"
"""
type EventMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Event!]!
}
"Grids are UI components to display cards."
type Grid {
  "The border width of the cards in the grid."
  cardBorderWidth: Int!
  "An aggregate relationship"
  cardGridsAggregate(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): CardGridAggregate!
  "An array relationship"
  card_grids(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): [CardGrid!]!
  "The number of columns in the grid."
  column: Int!
  "The date and time when the grid was created."
  createdAt: timestamptz!
  "The date and time when the grid was deleted."
  deletedAt: timestamptz
  "The description of the grid."
  description: String!
  "An aggregate relationship"
  gridShowinfosAggregate(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): GridShowinfoAggregate!
  "An array relationship"
  grid_showinfos(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): [GridShowinfo!]!
  "Whether the grid has horizontal scroll."
  horizontalScroll: Boolean!
  "The unique identifier of the grid."
  id: uuid!
  "The label of the grid is used to override the name in the UI."
  label: String!
  "The name of the grid."
  name: String!
  "The position of the grid in the ui."
  position: Int!
  "The number of rows in the grid."
  row: Int!
  "An array relationship"
  showinfos(
    "distinct select on columns"
    distinctOn: [ShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ShowinfoOrderBy!],
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): [Showinfo!]!
  "An aggregate relationship"
  showinfosAggregate(
    "distinct select on columns"
    distinctOn: [ShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ShowinfoOrderBy!],
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): ShowinfoAggregate!
  "The padding of the grid slots."
  slotPadding: Int!
  "An object relationship"
  studio: Studio
  "The studio that the grid belongs to."
  studioId: uuid
  "The date and time when the grid was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "grid"
"""
type GridAggregate {
  aggregate: GridAggregateFields
  nodes: [Grid!]!
}
"""
aggregate fields of "grid"
"""
type GridAggregateFields {
  avg: GridAvgFields
  count(columns: [GridSelectColumn!], distinct: Boolean): Int!
  max: GridMaxFields
  min: GridMinFields
  stddev: GridStddevFields
  stddevPop: GridStddev_popFields
  stddevSamp: GridStddev_sampFields
  sum: GridSumFields
  varPop: GridVar_popFields
  varSamp: GridVar_sampFields
  variance: GridVarianceFields
}
"aggregate avg on columns"
type GridAvgFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"aggregate max on columns"
type GridMaxFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  "The number of columns in the grid."
  column: Int
  "The date and time when the grid was created."
  createdAt: timestamptz
  "The date and time when the grid was deleted."
  deletedAt: timestamptz
  "The description of the grid."
  description: String
  "The unique identifier of the grid."
  id: uuid
  "The label of the grid is used to override the name in the UI."
  label: String
  "The name of the grid."
  name: String
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  "The padding of the grid slots."
  slotPadding: Int
  "The studio that the grid belongs to."
  studioId: uuid
  "The date and time when the grid was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type GridMinFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  "The number of columns in the grid."
  column: Int
  "The date and time when the grid was created."
  createdAt: timestamptz
  "The date and time when the grid was deleted."
  deletedAt: timestamptz
  "The description of the grid."
  description: String
  "The unique identifier of the grid."
  id: uuid
  "The label of the grid is used to override the name in the UI."
  label: String
  "The name of the grid."
  name: String
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  "The padding of the grid slots."
  slotPadding: Int
  "The studio that the grid belongs to."
  studioId: uuid
  "The date and time when the grid was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "grid"
"""
type GridMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Grid!]!
}
"GridShowinfo is the link between grid and showinfo."
type GridShowinfo {
  "The date and time when the grid_showinfo was created."
  createdAt: timestamptz!
  "The date and time when the grid_showinfo was deleted."
  deletedAt: timestamptz
  "An object relationship"
  grid: Grid
  "The grid this grid_showinfo is linked to."
  gridId: uuid
  "The unique identifier of the grid_showinfo."
  id: uuid!
  "An object relationship"
  showinfo: Showinfo
  "The showinfo this grid_showinfo is linked to."
  showinfoId: uuid
  "The date and time when the grid_showinfo was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "grid_showinfo"
"""
type GridShowinfoAggregate {
  aggregate: GridShowinfoAggregateFields
  nodes: [GridShowinfo!]!
}
"""
aggregate fields of "grid_showinfo"
"""
type GridShowinfoAggregateFields {
  count(columns: [GridShowinfoSelectColumn!], distinct: Boolean): Int!
  max: GridShowinfoMaxFields
  min: GridShowinfoMinFields
}
"aggregate max on columns"
type GridShowinfoMaxFields {
  "The date and time when the grid_showinfo was created."
  createdAt: timestamptz
  "The date and time when the grid_showinfo was deleted."
  deletedAt: timestamptz
  "The grid this grid_showinfo is linked to."
  gridId: uuid
  "The unique identifier of the grid_showinfo."
  id: uuid
  "The showinfo this grid_showinfo is linked to."
  showinfoId: uuid
  "The date and time when the grid_showinfo was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type GridShowinfoMinFields {
  "The date and time when the grid_showinfo was created."
  createdAt: timestamptz
  "The date and time when the grid_showinfo was deleted."
  deletedAt: timestamptz
  "The grid this grid_showinfo is linked to."
  gridId: uuid
  "The unique identifier of the grid_showinfo."
  id: uuid
  "The showinfo this grid_showinfo is linked to."
  showinfoId: uuid
  "The date and time when the grid_showinfo was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "grid_showinfo"
"""
type GridShowinfoMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [GridShowinfo!]!
}
"aggregate stddev on columns"
type GridStddevFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"aggregate stddev_pop on columns"
type GridStddev_popFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"aggregate stddev_samp on columns"
type GridStddev_sampFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"aggregate sum on columns"
type GridSumFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  "The number of columns in the grid."
  column: Int
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  "The padding of the grid slots."
  slotPadding: Int
}
"aggregate var_pop on columns"
type GridVar_popFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"aggregate var_samp on columns"
type GridVar_sampFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"aggregate variance on columns"
type GridVarianceFields {
  "The border width of the cards in the grid."
  cardBorderWidth: Float
  "The number of columns in the grid."
  column: Float
  "The position of the grid in the ui."
  position: Float
  "The number of rows in the grid."
  row: Float
  "The padding of the grid slots."
  slotPadding: Float
}
"Groups are used to group users and other groups."
type Group {
  "The date and time when the group was created."
  createdAt: timestamptz!
  "The date and time when the group was deleted."
  deletedAt: timestamptz
  "The description of the group."
  description: String!
  "An object relationship"
  group: Group
  "An aggregate relationship"
  groupStudiosAggregate(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): GroupStudioAggregate!
  "An array relationship"
  group_studios(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): [GroupStudio!]!
  "An array relationship"
  groups(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): [Group!]!
  "An aggregate relationship"
  groupsAggregate(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): GroupAggregate!
  "The unique identifier of the group."
  id: uuid!
  "The label of the group is used to override the name in the UI."
  label: String!
  "The logo image path of the group."
  logo: String!
  "The name of the group."
  name: String!
  "An object relationship"
  organization: Organization!
  "The organization id of the group."
  organizationId: uuid!
  "The parent group of the group."
  parentId: uuid
  "The date and time when the group was last updated."
  updatedAt: timestamptz!
  "An aggregate relationship"
  userGroupsAggregate(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): UserGroupAggregate!
  "An array relationship"
  user_groups(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): [UserGroup!]!
}
"""
aggregated selection of "group"
"""
type GroupAggregate {
  aggregate: GroupAggregateFields
  nodes: [Group!]!
}
"""
aggregate fields of "group"
"""
type GroupAggregateFields {
  count(columns: [GroupSelectColumn!], distinct: Boolean): Int!
  max: GroupMaxFields
  min: GroupMinFields
}
"aggregate max on columns"
type GroupMaxFields {
  "The date and time when the group was created."
  createdAt: timestamptz
  "The date and time when the group was deleted."
  deletedAt: timestamptz
  "The description of the group."
  description: String
  "The unique identifier of the group."
  id: uuid
  "The label of the group is used to override the name in the UI."
  label: String
  "The logo image path of the group."
  logo: String
  "The name of the group."
  name: String
  "The organization id of the group."
  organizationId: uuid
  "The parent group of the group."
  parentId: uuid
  "The date and time when the group was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type GroupMinFields {
  "The date and time when the group was created."
  createdAt: timestamptz
  "The date and time when the group was deleted."
  deletedAt: timestamptz
  "The description of the group."
  description: String
  "The unique identifier of the group."
  id: uuid
  "The label of the group is used to override the name in the UI."
  label: String
  "The logo image path of the group."
  logo: String
  "The name of the group."
  name: String
  "The organization id of the group."
  organizationId: uuid
  "The parent group of the group."
  parentId: uuid
  "The date and time when the group was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "group"
"""
type GroupMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Group!]!
}
"Group studios are used to group studios and other groups."
type GroupStudio {
  "The date and time when the group studio was created."
  createdAt: timestamptz!
  "The date and time when the group studio was deleted."
  deletedAt: timestamptz
  "An object relationship"
  group: Group!
  "The group of the group studio."
  groupId: uuid!
  "An object relationship"
  studio: Studio!
  "The studio of the group studio."
  studioId: uuid!
  "The date and time when the group studio was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "group_studio"
"""
type GroupStudioAggregate {
  aggregate: GroupStudioAggregateFields
  nodes: [GroupStudio!]!
}
"""
aggregate fields of "group_studio"
"""
type GroupStudioAggregateFields {
  count(columns: [GroupStudioSelectColumn!], distinct: Boolean): Int!
  max: GroupStudioMaxFields
  min: GroupStudioMinFields
}
"aggregate max on columns"
type GroupStudioMaxFields {
  "The date and time when the group studio was created."
  createdAt: timestamptz
  "The date and time when the group studio was deleted."
  deletedAt: timestamptz
  "The group of the group studio."
  groupId: uuid
  "The studio of the group studio."
  studioId: uuid
  "The date and time when the group studio was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type GroupStudioMinFields {
  "The date and time when the group studio was created."
  createdAt: timestamptz
  "The date and time when the group studio was deleted."
  deletedAt: timestamptz
  "The group of the group studio."
  groupId: uuid
  "The studio of the group studio."
  studioId: uuid
  "The date and time when the group studio was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "group_studio"
"""
type GroupStudioMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [GroupStudio!]!
}
"Lines represent a way to communicate with the outside world."
type Line {
  "An object relationship"
  calendar: Calendar
  "An array relationship"
  cardsByLineId(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): [Card!]!
  "An aggregate relationship"
  cardsByLineIdAggregate(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): CardAggregate!
  "An object relationship"
  codec: Codec
  "The date and time when the line was created."
  createdAt: timestamptz!
  "The date and time when the line was deleted."
  deletedAt: timestamptz
  "The description of the line."
  description: String!
  "An array relationship"
  events(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): [Event!]!
  "An aggregate relationship"
  eventsAggregate(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): EventAggregate!
  "The unique identifier of the line."
  id: uuid!
  "The label of the line is used to override the name in the UI."
  label: String!
  "An aggregate relationship"
  lineStudiosAggregate(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): LineStudioAggregate!
  "An array relationship"
  line_studios(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): [LineStudio!]!
  "An object relationship"
  line_type: LineType!
  "The name of the line."
  name: String!
  "An object relationship"
  organization: Organization!
  organizationId: uuid!
  "An object relationship"
  sip: Sip
  smartcodec: smartcodec_Line2
  "The status of the line."
  status: String!
  "The type of the line."
  type: LineTypeEnum!
  "The date and time when the line was last updated."
  updatedAt: timestamptz!
  "An object relationship"
  webrtc: Webrtc
}
"""
aggregated selection of "line"
"""
type LineAggregate {
  aggregate: LineAggregateFields
  nodes: [Line!]!
}
"""
aggregate fields of "line"
"""
type LineAggregateFields {
  count(columns: [LineSelectColumn!], distinct: Boolean): Int!
  max: LineMaxFields
  min: LineMinFields
}
"aggregate max on columns"
type LineMaxFields {
  "The date and time when the line was created."
  createdAt: timestamptz
  "The date and time when the line was deleted."
  deletedAt: timestamptz
  "The description of the line."
  description: String
  "The unique identifier of the line."
  id: uuid
  "The label of the line is used to override the name in the UI."
  label: String
  "The name of the line."
  name: String
  organizationId: uuid
  "The status of the line."
  status: String
  "The date and time when the line was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type LineMinFields {
  "The date and time when the line was created."
  createdAt: timestamptz
  "The date and time when the line was deleted."
  deletedAt: timestamptz
  "The description of the line."
  description: String
  "The unique identifier of the line."
  id: uuid
  "The label of the line is used to override the name in the UI."
  label: String
  "The name of the line."
  name: String
  organizationId: uuid
  "The status of the line."
  status: String
  "The date and time when the line was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "line"
"""
type LineMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Line!]!
}
"LineStudio is the link between line and studio."
type LineStudio {
  "The date and time when the line_studio was created."
  createdAt: timestamptz!
  "The date and time when the line_studio was deleted."
  deletedAt: timestamptz
  "An object relationship"
  line: Line!
  "The line this line_studio is linked to."
  lineId: uuid!
  "An object relationship"
  studio: Studio!
  "The studio this line_studio is linked to."
  studioId: uuid!
  "The date and time when the line_studio was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "line_studio"
"""
type LineStudioAggregate {
  aggregate: LineStudioAggregateFields
  nodes: [LineStudio!]!
}
"""
aggregate fields of "line_studio"
"""
type LineStudioAggregateFields {
  count(columns: [LineStudioSelectColumn!], distinct: Boolean): Int!
  max: LineStudioMaxFields
  min: LineStudioMinFields
}
"aggregate max on columns"
type LineStudioMaxFields {
  "The date and time when the line_studio was created."
  createdAt: timestamptz
  "The date and time when the line_studio was deleted."
  deletedAt: timestamptz
  "The line this line_studio is linked to."
  lineId: uuid
  "The studio this line_studio is linked to."
  studioId: uuid
  "The date and time when the line_studio was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type LineStudioMinFields {
  "The date and time when the line_studio was created."
  createdAt: timestamptz
  "The date and time when the line_studio was deleted."
  deletedAt: timestamptz
  "The line this line_studio is linked to."
  lineId: uuid
  "The studio this line_studio is linked to."
  studioId: uuid
  "The date and time when the line_studio was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "line_studio"
"""
type LineStudioMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [LineStudio!]!
}
"Line types are used to classify lines."
type LineType {
  "The comment of the line type."
  comment: String!
  "An array relationship"
  lines(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): [Line!]!
  "An aggregate relationship"
  linesAggregate(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): LineAggregate!
  "The value of the line type."
  value: String!
}
"""
aggregated selection of "line_type"
"""
type LineTypeAggregate {
  aggregate: LineTypeAggregateFields
  nodes: [LineType!]!
}
"""
aggregate fields of "line_type"
"""
type LineTypeAggregateFields {
  count(columns: [LineTypeSelectColumn!], distinct: Boolean): Int!
  max: LineTypeMaxFields
  min: LineTypeMinFields
}
"aggregate max on columns"
type LineTypeMaxFields {
  "The comment of the line type."
  comment: String
  "The value of the line type."
  value: String
}
"aggregate min on columns"
type LineTypeMinFields {
  "The comment of the line type."
  comment: String
  "The value of the line type."
  value: String
}
"""
response of any mutation on the table "line_type"
"""
type LineTypeMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [LineType!]!
}
"Medias are communication channels between the outside world and the system."
type Media {
  "The date and time when the media was created."
  createdAt: timestamptz!
  "The date and time when the media was deleted."
  deletedAt: timestamptz
  "The description of the media."
  description: String!
  "The unique identifier of the media."
  id: uuid!
  "The label of the media is used to override the name in the UI."
  label: String!
  "The name of the media."
  name: String!
  "The type of the media."
  type: String!
  "The date and time when the media was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "media"
"""
type MediaAggregate {
  aggregate: MediaAggregateFields
  nodes: [Media!]!
}
"""
aggregate fields of "media"
"""
type MediaAggregateFields {
  count(columns: [MediaSelectColumn!], distinct: Boolean): Int!
  max: MediaMaxFields
  min: MediaMinFields
}
"aggregate max on columns"
type MediaMaxFields {
  "The date and time when the media was created."
  createdAt: timestamptz
  "The date and time when the media was deleted."
  deletedAt: timestamptz
  "The description of the media."
  description: String
  "The unique identifier of the media."
  id: uuid
  "The label of the media is used to override the name in the UI."
  label: String
  "The name of the media."
  name: String
  "The type of the media."
  type: String
  "The date and time when the media was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type MediaMinFields {
  "The date and time when the media was created."
  createdAt: timestamptz
  "The date and time when the media was deleted."
  deletedAt: timestamptz
  "The description of the media."
  description: String
  "The unique identifier of the media."
  id: uuid
  "The label of the media is used to override the name in the UI."
  label: String
  "The name of the media."
  name: String
  "The type of the media."
  type: String
  "The date and time when the media was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "media"
"""
type MediaMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Media!]!
}
"Organizations are used as a container for users and groups."
type Organization {
  "The date and time when the organization was created."
  createdAt: timestamptz!
  "The date and time when the organization was deleted."
  deletedAt: timestamptz
  "The description of the organization."
  description: String!
  "An array relationship"
  groups(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): [Group!]!
  "An aggregate relationship"
  groupsAggregate(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): GroupAggregate!
  "The unique identifier of the organization."
  id: uuid!
  "The label of the organization is used to override the name in the UI."
  label: String!
  "An array relationship"
  lines(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): [Line!]!
  "An aggregate relationship"
  linesAggregate(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): LineAggregate!
  "The logo image path of the organization."
  logo: String!
  "The name of the organization."
  name: String!
  "An array relationship"
  studios(
    "distinct select on columns"
    distinctOn: [StudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [StudioOrderBy!],
    "filter the rows returned"
    where: StudioBoolExp
  ): [Studio!]!
  "An aggregate relationship"
  studiosAggregate(
    "distinct select on columns"
    distinctOn: [StudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [StudioOrderBy!],
    "filter the rows returned"
    where: StudioBoolExp
  ): StudioAggregate!
  "The date and time when the organization was last updated."
  updatedAt: timestamptz!
  "An array relationship"
  users(
    "distinct select on columns"
    distinctOn: [UserSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserOrderBy!],
    "filter the rows returned"
    where: UserBoolExp
  ): [User!]!
  "An aggregate relationship"
  usersAggregate(
    "distinct select on columns"
    distinctOn: [UserSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserOrderBy!],
    "filter the rows returned"
    where: UserBoolExp
  ): UserAggregate!
}
"""
aggregated selection of "organization"
"""
type OrganizationAggregate {
  aggregate: OrganizationAggregateFields
  nodes: [Organization!]!
}
"""
aggregate fields of "organization"
"""
type OrganizationAggregateFields {
  count(columns: [OrganizationSelectColumn!], distinct: Boolean): Int!
  max: OrganizationMaxFields
  min: OrganizationMinFields
}
"aggregate max on columns"
type OrganizationMaxFields {
  "The date and time when the organization was created."
  createdAt: timestamptz
  "The date and time when the organization was deleted."
  deletedAt: timestamptz
  "The description of the organization."
  description: String
  "The unique identifier of the organization."
  id: uuid
  "The label of the organization is used to override the name in the UI."
  label: String
  "The logo image path of the organization."
  logo: String
  "The name of the organization."
  name: String
  "The date and time when the organization was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type OrganizationMinFields {
  "The date and time when the organization was created."
  createdAt: timestamptz
  "The date and time when the organization was deleted."
  deletedAt: timestamptz
  "The description of the organization."
  description: String
  "The unique identifier of the organization."
  id: uuid
  "The label of the organization is used to override the name in the UI."
  label: String
  "The logo image path of the organization."
  logo: String
  "The name of the organization."
  name: String
  "The date and time when the organization was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "organization"
"""
type OrganizationMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Organization!]!
}
"Phones are valid phone numbers."
type Phone {
  "An object relationship"
  contact: Contact
  "The contact that the phone belongs to."
  contactId: uuid
  "The date and time when the contact phone was created."
  createdAt: timestamptz!
  "The date and time when the contact phone was deleted."
  deletedAt: timestamptz
  "The unique identifier of the contact phone."
  id: uuid!
  "The phone number of the contact phone."
  number: String!
  "The date and time when the contact phone was last updated."
  updatedAt: timestamptz!
  "The date and time when the contact phone was validated."
  validatedAt: timestamptz
}
"""
aggregated selection of "phone"
"""
type PhoneAggregate {
  aggregate: PhoneAggregateFields
  nodes: [Phone!]!
}
"""
aggregate fields of "phone"
"""
type PhoneAggregateFields {
  count(columns: [PhoneSelectColumn!], distinct: Boolean): Int!
  max: PhoneMaxFields
  min: PhoneMinFields
}
"aggregate max on columns"
type PhoneMaxFields {
  "The contact that the phone belongs to."
  contactId: uuid
  "The date and time when the contact phone was created."
  createdAt: timestamptz
  "The date and time when the contact phone was deleted."
  deletedAt: timestamptz
  "The unique identifier of the contact phone."
  id: uuid
  "The phone number of the contact phone."
  number: String
  "The date and time when the contact phone was last updated."
  updatedAt: timestamptz
  "The date and time when the contact phone was validated."
  validatedAt: timestamptz
}
"aggregate min on columns"
type PhoneMinFields {
  "The contact that the phone belongs to."
  contactId: uuid
  "The date and time when the contact phone was created."
  createdAt: timestamptz
  "The date and time when the contact phone was deleted."
  deletedAt: timestamptz
  "The unique identifier of the contact phone."
  id: uuid
  "The phone number of the contact phone."
  number: String
  "The date and time when the contact phone was last updated."
  updatedAt: timestamptz
  "The date and time when the contact phone was validated."
  validatedAt: timestamptz
}
"""
response of any mutation on the table "phone"
"""
type PhoneMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Phone!]!
}
"Settings are used to store user preferences."
type Setting {
  "The date and time when the setting was created."
  createdAt: timestamptz!
  "Enable or disable dark mode."
  darkMode: Boolean!
  "The date and time when the setting was deleted."
  deletedAt: timestamptz
  "The description of the setting."
  description: String!
  "Show tabs at the bottom of the grid."
  gridTabBottom: Boolean!
  "The unique identifier of the setting."
  id: uuid!
  "Left panel size in pixel"
  leftPanelWidth: Int!
  "The name of the setting."
  name: String!
  "The padding of the grid."
  padding: Int!
  "Show tabs at the bottom of the panel."
  panelTabBottom: Boolean!
  "The date and time when the setting was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "setting"
"""
type SettingAggregate {
  aggregate: SettingAggregateFields
  nodes: [Setting!]!
}
"""
aggregate fields of "setting"
"""
type SettingAggregateFields {
  avg: SettingAvgFields
  count(columns: [SettingSelectColumn!], distinct: Boolean): Int!
  max: SettingMaxFields
  min: SettingMinFields
  stddev: SettingStddevFields
  stddevPop: SettingStddev_popFields
  stddevSamp: SettingStddev_sampFields
  sum: SettingSumFields
  varPop: SettingVar_popFields
  varSamp: SettingVar_sampFields
  variance: SettingVarianceFields
}
"aggregate avg on columns"
type SettingAvgFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"aggregate max on columns"
type SettingMaxFields {
  "The date and time when the setting was created."
  createdAt: timestamptz
  "The date and time when the setting was deleted."
  deletedAt: timestamptz
  "The description of the setting."
  description: String
  "The unique identifier of the setting."
  id: uuid
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The name of the setting."
  name: String
  "The padding of the grid."
  padding: Int
  "The date and time when the setting was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type SettingMinFields {
  "The date and time when the setting was created."
  createdAt: timestamptz
  "The date and time when the setting was deleted."
  deletedAt: timestamptz
  "The description of the setting."
  description: String
  "The unique identifier of the setting."
  id: uuid
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The name of the setting."
  name: String
  "The padding of the grid."
  padding: Int
  "The date and time when the setting was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "setting"
"""
type SettingMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Setting!]!
}
"aggregate stddev on columns"
type SettingStddevFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"aggregate stddev_pop on columns"
type SettingStddev_popFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"aggregate stddev_samp on columns"
type SettingStddev_sampFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"aggregate sum on columns"
type SettingSumFields {
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The padding of the grid."
  padding: Int
}
"aggregate var_pop on columns"
type SettingVar_popFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"aggregate var_samp on columns"
type SettingVar_sampFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"aggregate variance on columns"
type SettingVarianceFields {
  "Left panel size in pixel"
  leftPanelWidth: Float
  "The padding of the grid."
  padding: Float
}
"CardInfo is what is displayed in the card. this apply by grid."
type Showinfo {
  "The alignment of the text."
  align: String!
  "The background color of the information."
  backgroundColor: citext!
  "Make the text bold."
  bold: Boolean!
  "The color of the text."
  color: String!
  "The date and time when the showinfo was created."
  createdAt: timestamptz!
  "The date and time when the showinfo was deleted."
  deletedAt: timestamptz
  "Is it the global showinfo template."
  global: Boolean!
  "An object relationship"
  grid: Grid
  "The grid this showinfo is linked to."
  gridId: uuid
  "An aggregate relationship"
  gridShowinfosAggregate(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): GridShowinfoAggregate!
  "An array relationship"
  grid_showinfos(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): [GridShowinfo!]!
  "The unique identifier of the showinfo."
  id: uuid!
  "The name of the information."
  name: String!
  "Javascript path to the information."
  path: String!
  "The position of the information."
  position: Int!
  "Show or hide the information in the card."
  show: Boolean!
  "The size of the text."
  size: Int!
  "The date and time when the showinfo was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "showinfo"
"""
type ShowinfoAggregate {
  aggregate: ShowinfoAggregateFields
  nodes: [Showinfo!]!
}
"""
aggregate fields of "showinfo"
"""
type ShowinfoAggregateFields {
  avg: ShowinfoAvgFields
  count(columns: [ShowinfoSelectColumn!], distinct: Boolean): Int!
  max: ShowinfoMaxFields
  min: ShowinfoMinFields
  stddev: ShowinfoStddevFields
  stddevPop: ShowinfoStddev_popFields
  stddevSamp: ShowinfoStddev_sampFields
  sum: ShowinfoSumFields
  varPop: ShowinfoVar_popFields
  varSamp: ShowinfoVar_sampFields
  variance: ShowinfoVarianceFields
}
"aggregate avg on columns"
type ShowinfoAvgFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
"aggregate max on columns"
type ShowinfoMaxFields {
  "The alignment of the text."
  align: String
  "The background color of the information."
  backgroundColor: citext
  "The color of the text."
  color: String
  "The date and time when the showinfo was created."
  createdAt: timestamptz
  "The date and time when the showinfo was deleted."
  deletedAt: timestamptz
  "The grid this showinfo is linked to."
  gridId: uuid
  "The unique identifier of the showinfo."
  id: uuid
  "The name of the information."
  name: String
  "Javascript path to the information."
  path: String
  "The position of the information."
  position: Int
  "The size of the text."
  size: Int
  "The date and time when the showinfo was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type ShowinfoMinFields {
  "The alignment of the text."
  align: String
  "The background color of the information."
  backgroundColor: citext
  "The color of the text."
  color: String
  "The date and time when the showinfo was created."
  createdAt: timestamptz
  "The date and time when the showinfo was deleted."
  deletedAt: timestamptz
  "The grid this showinfo is linked to."
  gridId: uuid
  "The unique identifier of the showinfo."
  id: uuid
  "The name of the information."
  name: String
  "Javascript path to the information."
  path: String
  "The position of the information."
  position: Int
  "The size of the text."
  size: Int
  "The date and time when the showinfo was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "showinfo"
"""
type ShowinfoMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Showinfo!]!
}
"aggregate stddev on columns"
type ShowinfoStddevFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
"aggregate stddev_pop on columns"
type ShowinfoStddev_popFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
"aggregate stddev_samp on columns"
type ShowinfoStddev_sampFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
"aggregate sum on columns"
type ShowinfoSumFields {
  "The position of the information."
  position: Int
  "The size of the text."
  size: Int
}
"aggregate var_pop on columns"
type ShowinfoVar_popFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
"aggregate var_samp on columns"
type ShowinfoVar_sampFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
"aggregate variance on columns"
type ShowinfoVarianceFields {
  "The position of the information."
  position: Float
  "The size of the text."
  size: Float
}
type SignupOutput {
  id: uuid!
  user: User
}
"SIP is a type of line that represent a SIP line."
type Sip {
  "The address of the trunk."
  address: String!
  "The date and time when the SIP line was created."
  createdAt: timestamptz!
  "The date and time when the SIP line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the SIP line."
  id: uuid!
  "An object relationship"
  line: Line!
  "The password of the SIP line."
  password: String!
  "The date and time when the SIP line was last updated."
  updatedAt: timestamptz!
  "The username of the SIP line."
  username: String!
}
"""
aggregated selection of "sip"
"""
type SipAggregate {
  aggregate: SipAggregateFields
  nodes: [Sip!]!
}
"""
aggregate fields of "sip"
"""
type SipAggregateFields {
  count(columns: [SipSelectColumn!], distinct: Boolean): Int!
  max: SipMaxFields
  min: SipMinFields
}
"aggregate max on columns"
type SipMaxFields {
  "The address of the trunk."
  address: String
  "The date and time when the SIP line was created."
  createdAt: timestamptz
  "The date and time when the SIP line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the SIP line."
  id: uuid
  "The password of the SIP line."
  password: String
  "The date and time when the SIP line was last updated."
  updatedAt: timestamptz
  "The username of the SIP line."
  username: String
}
"aggregate min on columns"
type SipMinFields {
  "The address of the trunk."
  address: String
  "The date and time when the SIP line was created."
  createdAt: timestamptz
  "The date and time when the SIP line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the SIP line."
  id: uuid
  "The password of the SIP line."
  password: String
  "The date and time when the SIP line was last updated."
  updatedAt: timestamptz
  "The username of the SIP line."
  username: String
}
"""
response of any mutation on the table "sip"
"""
type SipMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Sip!]!
}
"Studios are entities that represent a physical location."
type Studio {
  "The date and time when the studio was created."
  createdAt: timestamptz!
  "The date and time when the studio was deleted."
  deletedAt: timestamptz
  "The description of the studio."
  description: String!
  "An array relationship"
  grids(
    "distinct select on columns"
    distinctOn: [GridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridOrderBy!],
    "filter the rows returned"
    where: GridBoolExp
  ): [Grid!]!
  "An aggregate relationship"
  gridsAggregate(
    "distinct select on columns"
    distinctOn: [GridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridOrderBy!],
    "filter the rows returned"
    where: GridBoolExp
  ): GridAggregate!
  "An aggregate relationship"
  groupStudiosAggregate(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): GroupStudioAggregate!
  "An array relationship"
  group_studios(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): [GroupStudio!]!
  "The unique identifier of the studio."
  id: uuid!
  "The label of the studio is used to override the name in the UI."
  label: String!
  "An aggregate relationship"
  lineStudiosAggregate(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): LineStudioAggregate!
  "An array relationship"
  line_studios(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): [LineStudio!]!
  "The logo image path of the studio."
  logo: String!
  "The name of the studio."
  name: String!
  "An object relationship"
  organization: Organization!
  "The organization id of the studio."
  organizationId: uuid!
  "The date and time when the studio was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "studio"
"""
type StudioAggregate {
  aggregate: StudioAggregateFields
  nodes: [Studio!]!
}
"""
aggregate fields of "studio"
"""
type StudioAggregateFields {
  count(columns: [StudioSelectColumn!], distinct: Boolean): Int!
  max: StudioMaxFields
  min: StudioMinFields
}
"aggregate max on columns"
type StudioMaxFields {
  "The date and time when the studio was created."
  createdAt: timestamptz
  "The date and time when the studio was deleted."
  deletedAt: timestamptz
  "The description of the studio."
  description: String
  "The unique identifier of the studio."
  id: uuid
  "The label of the studio is used to override the name in the UI."
  label: String
  "The logo image path of the studio."
  logo: String
  "The name of the studio."
  name: String
  "The organization id of the studio."
  organizationId: uuid
  "The date and time when the studio was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type StudioMinFields {
  "The date and time when the studio was created."
  createdAt: timestamptz
  "The date and time when the studio was deleted."
  deletedAt: timestamptz
  "The description of the studio."
  description: String
  "The unique identifier of the studio."
  id: uuid
  "The label of the studio is used to override the name in the UI."
  label: String
  "The logo image path of the studio."
  logo: String
  "The name of the studio."
  name: String
  "The organization id of the studio."
  organizationId: uuid
  "The date and time when the studio was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "studio"
"""
type StudioMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Studio!]!
}
"Tags are used to group cards."
type Tag {
  "An aggregate relationship"
  cardTagsAggregate(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): CardTagAggregate!
  "An array relationship"
  card_tags(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): [CardTag!]!
  "The color of the tag."
  color: citext!
  "The date and time when the tag was created."
  createdAt: timestamptz!
  "The date and time when the tag was deleted."
  deletedAt: timestamptz
  "The description of the tag."
  description: String!
  "The unique identifier of the tag."
  id: uuid!
  "The label of the tag is used to override the name in the UI."
  label: String!
  "The name of the tag."
  name: String!
  "The date and time when the tag was last updated."
  updatedAt: timestamptz!
}
"""
aggregated selection of "tag"
"""
type TagAggregate {
  aggregate: TagAggregateFields
  nodes: [Tag!]!
}
"""
aggregate fields of "tag"
"""
type TagAggregateFields {
  count(columns: [TagSelectColumn!], distinct: Boolean): Int!
  max: TagMaxFields
  min: TagMinFields
}
"aggregate max on columns"
type TagMaxFields {
  "The color of the tag."
  color: citext
  "The date and time when the tag was created."
  createdAt: timestamptz
  "The date and time when the tag was deleted."
  deletedAt: timestamptz
  "The description of the tag."
  description: String
  "The unique identifier of the tag."
  id: uuid
  "The label of the tag is used to override the name in the UI."
  label: String
  "The name of the tag."
  name: String
  "The date and time when the tag was last updated."
  updatedAt: timestamptz
}
"aggregate min on columns"
type TagMinFields {
  "The color of the tag."
  color: citext
  "The date and time when the tag was created."
  createdAt: timestamptz
  "The date and time when the tag was deleted."
  deletedAt: timestamptz
  "The description of the tag."
  description: String
  "The unique identifier of the tag."
  id: uuid
  "The label of the tag is used to override the name in the UI."
  label: String
  "The name of the tag."
  name: String
  "The date and time when the tag was last updated."
  updatedAt: timestamptz
}
"""
response of any mutation on the table "tag"
"""
type TagMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Tag!]!
}
"Users are the main entity of the application."
type User {
  "The date when the user started working."
  beginDate: date
  "The date and time when the user was created."
  createdAt: timestamptz!
  "The date and time when the user was deleted."
  deletedAt: timestamptz
  "The email of the user."
  email: citext!
  "The date when the user stopped working."
  endDate: date
  "Whether the user has accepted the eula."
  eulaAccepted: Boolean!
  "The first name of the user."
  firstName: String!
  "The unique identifier of the user."
  id: uuid!
  "The last name of the user."
  lastName: String!
  "The date and time when the user was last seen."
  lastSeen: timestamptz
  "An object relationship"
  organization: Organization!
  "The organization of the user."
  organizationId: uuid!
  "The password of the user."
  password: String!
  "Whether the user should be asked to reset their password on next login."
  resetPassword: Boolean!
  "The date and time when the user was last updated."
  updatedAt: timestamptz!
  "An aggregate relationship"
  userGroupsAggregate(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): UserGroupAggregate!
  "An array relationship"
  user_groups(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): [UserGroup!]!
  "The username of the user."
  username: String!
}
"""
aggregated selection of "user"
"""
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}
"""
aggregate fields of "user"
"""
type UserAggregateFields {
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
}
"User groups are used to group users and other groups."
type UserGroup {
  "The date and time when the user group was created."
  createdAt: timestamptz!
  "The date and time when the user group was deleted."
  deletedAt: timestamptz
  "An object relationship"
  group: Group!
  "The group of the user group."
  groupId: uuid!
  "The date and time when the user group was last updated."
  updatedAt: timestamptz!
  "An object relationship"
  user: User!
  "The user of the user group."
  userId: uuid!
}
"""
aggregated selection of "user_group"
"""
type UserGroupAggregate {
  aggregate: UserGroupAggregateFields
  nodes: [UserGroup!]!
}
"""
aggregate fields of "user_group"
"""
type UserGroupAggregateFields {
  count(columns: [UserGroupSelectColumn!], distinct: Boolean): Int!
  max: UserGroupMaxFields
  min: UserGroupMinFields
}
"aggregate max on columns"
type UserGroupMaxFields {
  "The date and time when the user group was created."
  createdAt: timestamptz
  "The date and time when the user group was deleted."
  deletedAt: timestamptz
  "The group of the user group."
  groupId: uuid
  "The date and time when the user group was last updated."
  updatedAt: timestamptz
  "The user of the user group."
  userId: uuid
}
"aggregate min on columns"
type UserGroupMinFields {
  "The date and time when the user group was created."
  createdAt: timestamptz
  "The date and time when the user group was deleted."
  deletedAt: timestamptz
  "The group of the user group."
  groupId: uuid
  "The date and time when the user group was last updated."
  updatedAt: timestamptz
  "The user of the user group."
  userId: uuid
}
"""
response of any mutation on the table "user_group"
"""
type UserGroupMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [UserGroup!]!
}
"aggregate max on columns"
type UserMaxFields {
  "The date when the user started working."
  beginDate: date
  "The date and time when the user was created."
  createdAt: timestamptz
  "The date and time when the user was deleted."
  deletedAt: timestamptz
  "The email of the user."
  email: citext
  "The date when the user stopped working."
  endDate: date
  "The first name of the user."
  firstName: String
  "The unique identifier of the user."
  id: uuid
  "The last name of the user."
  lastName: String
  "The date and time when the user was last seen."
  lastSeen: timestamptz
  "The organization of the user."
  organizationId: uuid
  "The password of the user."
  password: String
  "The date and time when the user was last updated."
  updatedAt: timestamptz
  "The username of the user."
  username: String
}
"aggregate min on columns"
type UserMinFields {
  "The date when the user started working."
  beginDate: date
  "The date and time when the user was created."
  createdAt: timestamptz
  "The date and time when the user was deleted."
  deletedAt: timestamptz
  "The email of the user."
  email: citext
  "The date when the user stopped working."
  endDate: date
  "The first name of the user."
  firstName: String
  "The unique identifier of the user."
  id: uuid
  "The last name of the user."
  lastName: String
  "The date and time when the user was last seen."
  lastSeen: timestamptz
  "The organization of the user."
  organizationId: uuid
  "The password of the user."
  password: String
  "The date and time when the user was last updated."
  updatedAt: timestamptz
  "The username of the user."
  username: String
}
"""
response of any mutation on the table "user"
"""
type UserMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [User!]!
}
"WebRTC is a type of line that represent a WebRTC line."
type Webrtc {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The date and time when the WebRTC line was created."
  createdAt: timestamptz!
  "The date and time when the WebRTC line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the WebRTC line."
  id: uuid!
  "An object relationship"
  line: Line!
  "The date and time when the WebRTC line was last updated."
  updatedAt: timestamptz!
  "Whether the WebRTC line has video."
  video: Boolean!
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"""
aggregated selection of "webrtc"
"""
type WebrtcAggregate {
  aggregate: WebrtcAggregateFields
  nodes: [Webrtc!]!
}
"""
aggregate fields of "webrtc"
"""
type WebrtcAggregateFields {
  avg: WebrtcAvgFields
  count(columns: [WebrtcSelectColumn!], distinct: Boolean): Int!
  max: WebrtcMaxFields
  min: WebrtcMinFields
  stddev: WebrtcStddevFields
  stddevPop: WebrtcStddev_popFields
  stddevSamp: WebrtcStddev_sampFields
  sum: WebrtcSumFields
  varPop: WebrtcVar_popFields
  varSamp: WebrtcVar_sampFields
  variance: WebrtcVarianceFields
}
"aggregate avg on columns"
type WebrtcAvgFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"aggregate max on columns"
type WebrtcMaxFields {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The date and time when the WebRTC line was created."
  createdAt: timestamptz
  "The date and time when the WebRTC line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the WebRTC line."
  id: uuid
  "The date and time when the WebRTC line was last updated."
  updatedAt: timestamptz
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"aggregate min on columns"
type WebrtcMinFields {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The date and time when the WebRTC line was created."
  createdAt: timestamptz
  "The date and time when the WebRTC line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the WebRTC line."
  id: uuid
  "The date and time when the WebRTC line was last updated."
  updatedAt: timestamptz
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"""
response of any mutation on the table "webrtc"
"""
type WebrtcMutationResponse {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Webrtc!]!
}
"aggregate stddev on columns"
type WebrtcStddevFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"aggregate stddev_pop on columns"
type WebrtcStddev_popFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"aggregate stddev_samp on columns"
type WebrtcStddev_sampFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"aggregate sum on columns"
type WebrtcSumFields {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"aggregate var_pop on columns"
type WebrtcVar_popFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"aggregate var_samp on columns"
type WebrtcVar_sampFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"aggregate variance on columns"
type WebrtcVarianceFields {
  "The port used to read audio."
  audioPortRead: Float
  "The port used to write audio."
  audioPortWrite: Float
  "The port used to read video."
  videoPortRead: Float
  "The port used to write video."
  videoPortWrite: Float
}
"mutation root"
type mutation_root {
  """
  delete data from the table: "action"
  """
  deleteAction(
    "filter the rows which have to be deleted"
    where: ActionBoolExp!
  ): ActionMutationResponse
  """
  delete single row from the table: "action"
  """
  deleteActionByPk(
    "The unique identifier of the action."
    id: uuid!
  ): Action
  """
  delete data from the table: "address"
  """
  deleteAddress(
    "filter the rows which have to be deleted"
    where: AddressBoolExp!
  ): AddressMutationResponse
  """
  delete single row from the table: "address"
  """
  deleteAddressByPk(
    "The unique identifier of the address."
    id: uuid!
  ): Address
  """
  delete data from the table: "button"
  """
  deleteButton(
    "filter the rows which have to be deleted"
    where: ButtonBoolExp!
  ): ButtonMutationResponse
  """
  delete single row from the table: "button"
  """
  deleteButtonByPk(
    "The unique identifier of the button."
    id: uuid!
  ): Button
  """
  delete data from the table: "calendar"
  """
  deleteCalendar(
    "filter the rows which have to be deleted"
    where: CalendarBoolExp!
  ): CalendarMutationResponse
  """
  delete single row from the table: "calendar"
  """
  deleteCalendarByPk(
    "The unique identifier of the calendar."
    id: uuid!
  ): Calendar
  """
  delete data from the table: "card"
  """
  deleteCard(
    "filter the rows which have to be deleted"
    where: CardBoolExp!
  ): CardMutationResponse
  """
  delete data from the table: "card_button"
  """
  deleteCardButton(
    "filter the rows which have to be deleted"
    where: CardButtonBoolExp!
  ): CardButtonMutationResponse
  """
  delete single row from the table: "card_button"
  """
  deleteCardButtonByPk(buttonId: uuid!, cardId: uuid!): CardButton
  """
  delete single row from the table: "card"
  """
  deleteCardByPk(
    "The unique identifier of the card."
    id: uuid!
  ): Card
  """
  delete data from the table: "card_grid"
  """
  deleteCardGrid(
    "filter the rows which have to be deleted"
    where: CardGridBoolExp!
  ): CardGridMutationResponse
  """
  delete single row from the table: "card_grid"
  """
  deleteCardGridByPk(
    "The card that is in the grid."
    cardId: uuid!,
    "The grid that the card is in."
    gridId: uuid!
  ): CardGrid
  """
  delete data from the table: "card_tag"
  """
  deleteCardTag(
    "filter the rows which have to be deleted"
    where: CardTagBoolExp!
  ): CardTagMutationResponse
  """
  delete single row from the table: "card_tag"
  """
  deleteCardTagByPk(cardId: uuid!, tagId: uuid!): CardTag
  """
  delete data from the table: "card_type"
  """
  deleteCardType(
    "filter the rows which have to be deleted"
    where: CardTypeBoolExp!
  ): CardTypeMutationResponse
  """
  delete single row from the table: "card_type"
  """
  deleteCardTypeByPk(
    "The value of the card type."
    value: String!
  ): CardType
  """
  delete data from the table: "codec"
  """
  deleteCodec(
    "filter the rows which have to be deleted"
    where: CodecBoolExp!
  ): CodecMutationResponse
  """
  delete single row from the table: "codec"
  """
  deleteCodecByPk(
    "The unique identifier of the codec."
    id: uuid!
  ): Codec
  """
  delete data from the table: "contact"
  """
  deleteContact(
    "filter the rows which have to be deleted"
    where: ContactBoolExp!
  ): ContactMutationResponse
  """
  delete single row from the table: "contact"
  """
  deleteContactByPk(
    "The unique identifier of the contact."
    id: uuid!
  ): Contact
  """
  delete data from the table: "device"
  """
  deleteDevice(
    "filter the rows which have to be deleted"
    where: DeviceBoolExp!
  ): DeviceMutationResponse
  """
  delete single row from the table: "device"
  """
  deleteDeviceByPk(
    "The unique identifier of the device."
    id: uuid!
  ): Device
  """
  delete data from the table: "email"
  """
  deleteEmail(
    "filter the rows which have to be deleted"
    where: EmailBoolExp!
  ): EmailMutationResponse
  """
  delete single row from the table: "email"
  """
  deleteEmailByPk(
    "The unique identifier of the email."
    id: uuid!
  ): Email
  """
  delete data from the table: "event"
  """
  deleteEvent(
    "filter the rows which have to be deleted"
    where: EventBoolExp!
  ): EventMutationResponse
  """
  delete single row from the table: "event"
  """
  deleteEventByPk(
    "The unique identifier of the event."
    id: uuid!
  ): Event
  """
  delete data from the table: "grid"
  """
  deleteGrid(
    "filter the rows which have to be deleted"
    where: GridBoolExp!
  ): GridMutationResponse
  """
  delete single row from the table: "grid"
  """
  deleteGridByPk(
    "The unique identifier of the grid."
    id: uuid!
  ): Grid
  """
  delete data from the table: "grid_showinfo"
  """
  deleteGridShowinfo(
    "filter the rows which have to be deleted"
    where: GridShowinfoBoolExp!
  ): GridShowinfoMutationResponse
  """
  delete single row from the table: "grid_showinfo"
  """
  deleteGridShowinfoByPk(
    "The unique identifier of the grid_showinfo."
    id: uuid!
  ): GridShowinfo
  """
  delete data from the table: "group"
  """
  deleteGroup(
    "filter the rows which have to be deleted"
    where: GroupBoolExp!
  ): GroupMutationResponse
  """
  delete single row from the table: "group"
  """
  deleteGroupByPk(
    "The unique identifier of the group."
    id: uuid!
  ): Group
  """
  delete data from the table: "group_studio"
  """
  deleteGroupStudio(
    "filter the rows which have to be deleted"
    where: GroupStudioBoolExp!
  ): GroupStudioMutationResponse
  """
  delete single row from the table: "group_studio"
  """
  deleteGroupStudioByPk(
    "The group of the group studio."
    groupId: uuid!,
    "The studio of the group studio."
    studioId: uuid!
  ): GroupStudio
  """
  delete data from the table: "line"
  """
  deleteLine(
    "filter the rows which have to be deleted"
    where: LineBoolExp!
  ): LineMutationResponse
  """
  delete single row from the table: "line"
  """
  deleteLineByPk(
    "The unique identifier of the line."
    id: uuid!
  ): Line
  """
  delete data from the table: "line_studio"
  """
  deleteLineStudio(
    "filter the rows which have to be deleted"
    where: LineStudioBoolExp!
  ): LineStudioMutationResponse
  """
  delete single row from the table: "line_studio"
  """
  deleteLineStudioByPk(
    "The line this line_studio is linked to."
    lineId: uuid!,
    "The studio this line_studio is linked to."
    studioId: uuid!
  ): LineStudio
  """
  delete data from the table: "line_type"
  """
  deleteLineType(
    "filter the rows which have to be deleted"
    where: LineTypeBoolExp!
  ): LineTypeMutationResponse
  """
  delete single row from the table: "line_type"
  """
  deleteLineTypeByPk(
    "The value of the line type."
    value: String!
  ): LineType
  """
  delete data from the table: "media"
  """
  deleteMedia(
    "filter the rows which have to be deleted"
    where: MediaBoolExp!
  ): MediaMutationResponse
  """
  delete single row from the table: "media"
  """
  deleteMediaByPk(
    "The unique identifier of the media."
    id: uuid!
  ): Media
  """
  delete data from the table: "organization"
  """
  deleteOrganization(
    "filter the rows which have to be deleted"
    where: OrganizationBoolExp!
  ): OrganizationMutationResponse
  """
  delete single row from the table: "organization"
  """
  deleteOrganizationByPk(
    "The unique identifier of the organization."
    id: uuid!
  ): Organization
  """
  delete data from the table: "phone"
  """
  deletePhone(
    "filter the rows which have to be deleted"
    where: PhoneBoolExp!
  ): PhoneMutationResponse
  """
  delete single row from the table: "phone"
  """
  deletePhoneByPk(
    "The unique identifier of the contact phone."
    id: uuid!
  ): Phone
  """
  delete data from the table: "setting"
  """
  deleteSetting(
    "filter the rows which have to be deleted"
    where: SettingBoolExp!
  ): SettingMutationResponse
  """
  delete single row from the table: "setting"
  """
  deleteSettingByPk(
    "The unique identifier of the setting."
    id: uuid!
  ): Setting
  """
  delete data from the table: "showinfo"
  """
  deleteShowinfo(
    "filter the rows which have to be deleted"
    where: ShowinfoBoolExp!
  ): ShowinfoMutationResponse
  """
  delete single row from the table: "showinfo"
  """
  deleteShowinfoByPk(
    "The unique identifier of the showinfo."
    id: uuid!
  ): Showinfo
  """
  delete data from the table: "sip"
  """
  deleteSip(
    "filter the rows which have to be deleted"
    where: SipBoolExp!
  ): SipMutationResponse
  """
  delete single row from the table: "sip"
  """
  deleteSipByPk(
    "The unique identifier of the SIP line."
    id: uuid!
  ): Sip
  """
  delete data from the table: "studio"
  """
  deleteStudio(
    "filter the rows which have to be deleted"
    where: StudioBoolExp!
  ): StudioMutationResponse
  """
  delete single row from the table: "studio"
  """
  deleteStudioByPk(
    "The unique identifier of the studio."
    id: uuid!
  ): Studio
  """
  delete data from the table: "tag"
  """
  deleteTag(
    "filter the rows which have to be deleted"
    where: TagBoolExp!
  ): TagMutationResponse
  """
  delete single row from the table: "tag"
  """
  deleteTagByPk(
    "The unique identifier of the tag."
    id: uuid!
  ): Tag
  """
  delete data from the table: "user"
  """
  deleteUser(
    "filter the rows which have to be deleted"
    where: UserBoolExp!
  ): UserMutationResponse
  """
  delete single row from the table: "user"
  """
  deleteUserByPk(
    "The unique identifier of the user."
    id: uuid!
  ): User
  """
  delete data from the table: "user_group"
  """
  deleteUserGroup(
    "filter the rows which have to be deleted"
    where: UserGroupBoolExp!
  ): UserGroupMutationResponse
  """
  delete single row from the table: "user_group"
  """
  deleteUserGroupByPk(
    "The group of the user group."
    groupId: uuid!,
    "The user of the user group."
    userId: uuid!
  ): UserGroup
  """
  delete data from the table: "webrtc"
  """
  deleteWebrtc(
    "filter the rows which have to be deleted"
    where: WebrtcBoolExp!
  ): WebrtcMutationResponse
  """
  delete single row from the table: "webrtc"
  """
  deleteWebrtcByPk(
    "The unique identifier of the WebRTC line."
    id: uuid!
  ): Webrtc
  """
  insert data into the table: "action"
  """
  insertAction(
    "the rows to be inserted"
    objects: [ActionInsertInput!]!,
    "upsert condition"
    onConflict: ActionOnConflict
  ): ActionMutationResponse
  """
  insert a single row into the table: "action"
  """
  insertActionOne(
    "the row to be inserted"
    object: ActionInsertInput!,
    "upsert condition"
    onConflict: ActionOnConflict
  ): Action
  """
  insert data into the table: "address"
  """
  insertAddress(
    "the rows to be inserted"
    objects: [AddressInsertInput!]!,
    "upsert condition"
    onConflict: AddressOnConflict
  ): AddressMutationResponse
  """
  insert a single row into the table: "address"
  """
  insertAddressOne(
    "the row to be inserted"
    object: AddressInsertInput!,
    "upsert condition"
    onConflict: AddressOnConflict
  ): Address
  """
  insert data into the table: "button"
  """
  insertButton(
    "the rows to be inserted"
    objects: [ButtonInsertInput!]!,
    "upsert condition"
    onConflict: ButtonOnConflict
  ): ButtonMutationResponse
  """
  insert a single row into the table: "button"
  """
  insertButtonOne(
    "the row to be inserted"
    object: ButtonInsertInput!,
    "upsert condition"
    onConflict: ButtonOnConflict
  ): Button
  """
  insert data into the table: "calendar"
  """
  insertCalendar(
    "the rows to be inserted"
    objects: [CalendarInsertInput!]!,
    "upsert condition"
    onConflict: CalendarOnConflict
  ): CalendarMutationResponse
  """
  insert a single row into the table: "calendar"
  """
  insertCalendarOne(
    "the row to be inserted"
    object: CalendarInsertInput!,
    "upsert condition"
    onConflict: CalendarOnConflict
  ): Calendar
  """
  insert data into the table: "card"
  """
  insertCard(
    "the rows to be inserted"
    objects: [CardInsertInput!]!,
    "upsert condition"
    onConflict: CardOnConflict
  ): CardMutationResponse
  """
  insert data into the table: "card_button"
  """
  insertCardButton(
    "the rows to be inserted"
    objects: [CardButtonInsertInput!]!,
    "upsert condition"
    onConflict: CardButtonOnConflict
  ): CardButtonMutationResponse
  """
  insert a single row into the table: "card_button"
  """
  insertCardButtonOne(
    "the row to be inserted"
    object: CardButtonInsertInput!,
    "upsert condition"
    onConflict: CardButtonOnConflict
  ): CardButton
  """
  insert data into the table: "card_grid"
  """
  insertCardGrid(
    "the rows to be inserted"
    objects: [CardGridInsertInput!]!,
    "upsert condition"
    onConflict: CardGridOnConflict
  ): CardGridMutationResponse
  """
  insert a single row into the table: "card_grid"
  """
  insertCardGridOne(
    "the row to be inserted"
    object: CardGridInsertInput!,
    "upsert condition"
    onConflict: CardGridOnConflict
  ): CardGrid
  """
  insert a single row into the table: "card"
  """
  insertCardOne(
    "the row to be inserted"
    object: CardInsertInput!,
    "upsert condition"
    onConflict: CardOnConflict
  ): Card
  """
  insert data into the table: "card_tag"
  """
  insertCardTag(
    "the rows to be inserted"
    objects: [CardTagInsertInput!]!,
    "upsert condition"
    onConflict: CardTagOnConflict
  ): CardTagMutationResponse
  """
  insert a single row into the table: "card_tag"
  """
  insertCardTagOne(
    "the row to be inserted"
    object: CardTagInsertInput!,
    "upsert condition"
    onConflict: CardTagOnConflict
  ): CardTag
  """
  insert data into the table: "card_type"
  """
  insertCardType(
    "the rows to be inserted"
    objects: [CardTypeInsertInput!]!,
    "upsert condition"
    onConflict: CardTypeOnConflict
  ): CardTypeMutationResponse
  """
  insert a single row into the table: "card_type"
  """
  insertCardTypeOne(
    "the row to be inserted"
    object: CardTypeInsertInput!,
    "upsert condition"
    onConflict: CardTypeOnConflict
  ): CardType
  """
  insert data into the table: "codec"
  """
  insertCodec(
    "the rows to be inserted"
    objects: [CodecInsertInput!]!,
    "upsert condition"
    onConflict: CodecOnConflict
  ): CodecMutationResponse
  """
  insert a single row into the table: "codec"
  """
  insertCodecOne(
    "the row to be inserted"
    object: CodecInsertInput!,
    "upsert condition"
    onConflict: CodecOnConflict
  ): Codec
  """
  insert data into the table: "contact"
  """
  insertContact(
    "the rows to be inserted"
    objects: [ContactInsertInput!]!,
    "upsert condition"
    onConflict: ContactOnConflict
  ): ContactMutationResponse
  """
  insert a single row into the table: "contact"
  """
  insertContactOne(
    "the row to be inserted"
    object: ContactInsertInput!,
    "upsert condition"
    onConflict: ContactOnConflict
  ): Contact
  """
  insert data into the table: "device"
  """
  insertDevice(
    "the rows to be inserted"
    objects: [DeviceInsertInput!]!,
    "upsert condition"
    onConflict: DeviceOnConflict
  ): DeviceMutationResponse
  """
  insert a single row into the table: "device"
  """
  insertDeviceOne(
    "the row to be inserted"
    object: DeviceInsertInput!,
    "upsert condition"
    onConflict: DeviceOnConflict
  ): Device
  """
  insert data into the table: "email"
  """
  insertEmail(
    "the rows to be inserted"
    objects: [EmailInsertInput!]!,
    "upsert condition"
    onConflict: EmailOnConflict
  ): EmailMutationResponse
  """
  insert a single row into the table: "email"
  """
  insertEmailOne(
    "the row to be inserted"
    object: EmailInsertInput!,
    "upsert condition"
    onConflict: EmailOnConflict
  ): Email
  """
  insert data into the table: "event"
  """
  insertEvent(
    "the rows to be inserted"
    objects: [EventInsertInput!]!,
    "upsert condition"
    onConflict: EventOnConflict
  ): EventMutationResponse
  """
  insert a single row into the table: "event"
  """
  insertEventOne(
    "the row to be inserted"
    object: EventInsertInput!,
    "upsert condition"
    onConflict: EventOnConflict
  ): Event
  """
  insert data into the table: "grid"
  """
  insertGrid(
    "the rows to be inserted"
    objects: [GridInsertInput!]!,
    "upsert condition"
    onConflict: GridOnConflict
  ): GridMutationResponse
  """
  insert a single row into the table: "grid"
  """
  insertGridOne(
    "the row to be inserted"
    object: GridInsertInput!,
    "upsert condition"
    onConflict: GridOnConflict
  ): Grid
  """
  insert data into the table: "grid_showinfo"
  """
  insertGridShowinfo(
    "the rows to be inserted"
    objects: [GridShowinfoInsertInput!]!,
    "upsert condition"
    onConflict: GridShowinfoOnConflict
  ): GridShowinfoMutationResponse
  """
  insert a single row into the table: "grid_showinfo"
  """
  insertGridShowinfoOne(
    "the row to be inserted"
    object: GridShowinfoInsertInput!,
    "upsert condition"
    onConflict: GridShowinfoOnConflict
  ): GridShowinfo
  """
  insert data into the table: "group"
  """
  insertGroup(
    "the rows to be inserted"
    objects: [GroupInsertInput!]!,
    "upsert condition"
    onConflict: GroupOnConflict
  ): GroupMutationResponse
  """
  insert a single row into the table: "group"
  """
  insertGroupOne(
    "the row to be inserted"
    object: GroupInsertInput!,
    "upsert condition"
    onConflict: GroupOnConflict
  ): Group
  """
  insert data into the table: "group_studio"
  """
  insertGroupStudio(
    "the rows to be inserted"
    objects: [GroupStudioInsertInput!]!,
    "upsert condition"
    onConflict: GroupStudioOnConflict
  ): GroupStudioMutationResponse
  """
  insert a single row into the table: "group_studio"
  """
  insertGroupStudioOne(
    "the row to be inserted"
    object: GroupStudioInsertInput!,
    "upsert condition"
    onConflict: GroupStudioOnConflict
  ): GroupStudio
  """
  insert data into the table: "line"
  """
  insertLine(
    "the rows to be inserted"
    objects: [LineInsertInput!]!,
    "upsert condition"
    onConflict: LineOnConflict
  ): LineMutationResponse
  """
  insert a single row into the table: "line"
  """
  insertLineOne(
    "the row to be inserted"
    object: LineInsertInput!,
    "upsert condition"
    onConflict: LineOnConflict
  ): Line
  """
  insert data into the table: "line_studio"
  """
  insertLineStudio(
    "the rows to be inserted"
    objects: [LineStudioInsertInput!]!,
    "upsert condition"
    onConflict: LineStudioOnConflict
  ): LineStudioMutationResponse
  """
  insert a single row into the table: "line_studio"
  """
  insertLineStudioOne(
    "the row to be inserted"
    object: LineStudioInsertInput!,
    "upsert condition"
    onConflict: LineStudioOnConflict
  ): LineStudio
  """
  insert data into the table: "line_type"
  """
  insertLineType(
    "the rows to be inserted"
    objects: [LineTypeInsertInput!]!,
    "upsert condition"
    onConflict: LineTypeOnConflict
  ): LineTypeMutationResponse
  """
  insert a single row into the table: "line_type"
  """
  insertLineTypeOne(
    "the row to be inserted"
    object: LineTypeInsertInput!,
    "upsert condition"
    onConflict: LineTypeOnConflict
  ): LineType
  """
  insert data into the table: "media"
  """
  insertMedia(
    "the rows to be inserted"
    objects: [MediaInsertInput!]!,
    "upsert condition"
    onConflict: MediaOnConflict
  ): MediaMutationResponse
  """
  insert a single row into the table: "media"
  """
  insertMediaOne(
    "the row to be inserted"
    object: MediaInsertInput!,
    "upsert condition"
    onConflict: MediaOnConflict
  ): Media
  """
  insert data into the table: "organization"
  """
  insertOrganization(
    "the rows to be inserted"
    objects: [OrganizationInsertInput!]!,
    "upsert condition"
    onConflict: OrganizationOnConflict
  ): OrganizationMutationResponse
  """
  insert a single row into the table: "organization"
  """
  insertOrganizationOne(
    "the row to be inserted"
    object: OrganizationInsertInput!,
    "upsert condition"
    onConflict: OrganizationOnConflict
  ): Organization
  """
  insert data into the table: "phone"
  """
  insertPhone(
    "the rows to be inserted"
    objects: [PhoneInsertInput!]!,
    "upsert condition"
    onConflict: PhoneOnConflict
  ): PhoneMutationResponse
  """
  insert a single row into the table: "phone"
  """
  insertPhoneOne(
    "the row to be inserted"
    object: PhoneInsertInput!,
    "upsert condition"
    onConflict: PhoneOnConflict
  ): Phone
  """
  insert data into the table: "setting"
  """
  insertSetting(
    "the rows to be inserted"
    objects: [SettingInsertInput!]!,
    "upsert condition"
    onConflict: SettingOnConflict
  ): SettingMutationResponse
  """
  insert a single row into the table: "setting"
  """
  insertSettingOne(
    "the row to be inserted"
    object: SettingInsertInput!,
    "upsert condition"
    onConflict: SettingOnConflict
  ): Setting
  """
  insert data into the table: "showinfo"
  """
  insertShowinfo(
    "the rows to be inserted"
    objects: [ShowinfoInsertInput!]!,
    "upsert condition"
    onConflict: ShowinfoOnConflict
  ): ShowinfoMutationResponse
  """
  insert a single row into the table: "showinfo"
  """
  insertShowinfoOne(
    "the row to be inserted"
    object: ShowinfoInsertInput!,
    "upsert condition"
    onConflict: ShowinfoOnConflict
  ): Showinfo
  """
  insert data into the table: "sip"
  """
  insertSip(
    "the rows to be inserted"
    objects: [SipInsertInput!]!,
    "upsert condition"
    onConflict: SipOnConflict
  ): SipMutationResponse
  """
  insert a single row into the table: "sip"
  """
  insertSipOne(
    "the row to be inserted"
    object: SipInsertInput!,
    "upsert condition"
    onConflict: SipOnConflict
  ): Sip
  """
  insert data into the table: "studio"
  """
  insertStudio(
    "the rows to be inserted"
    objects: [StudioInsertInput!]!,
    "upsert condition"
    onConflict: StudioOnConflict
  ): StudioMutationResponse
  """
  insert a single row into the table: "studio"
  """
  insertStudioOne(
    "the row to be inserted"
    object: StudioInsertInput!,
    "upsert condition"
    onConflict: StudioOnConflict
  ): Studio
  """
  insert data into the table: "tag"
  """
  insertTag(
    "the rows to be inserted"
    objects: [TagInsertInput!]!,
    "upsert condition"
    onConflict: TagOnConflict
  ): TagMutationResponse
  """
  insert a single row into the table: "tag"
  """
  insertTagOne(
    "the row to be inserted"
    object: TagInsertInput!,
    "upsert condition"
    onConflict: TagOnConflict
  ): Tag
  """
  insert data into the table: "user"
  """
  insertUser(
    "the rows to be inserted"
    objects: [UserInsertInput!]!,
    "upsert condition"
    onConflict: UserOnConflict
  ): UserMutationResponse
  """
  insert data into the table: "user_group"
  """
  insertUserGroup(
    "the rows to be inserted"
    objects: [UserGroupInsertInput!]!,
    "upsert condition"
    onConflict: UserGroupOnConflict
  ): UserGroupMutationResponse
  """
  insert a single row into the table: "user_group"
  """
  insertUserGroupOne(
    "the row to be inserted"
    object: UserGroupInsertInput!,
    "upsert condition"
    onConflict: UserGroupOnConflict
  ): UserGroup
  """
  insert a single row into the table: "user"
  """
  insertUserOne(
    "the row to be inserted"
    object: UserInsertInput!,
    "upsert condition"
    onConflict: UserOnConflict
  ): User
  """
  insert data into the table: "webrtc"
  """
  insertWebrtc(
    "the rows to be inserted"
    objects: [WebrtcInsertInput!]!,
    "upsert condition"
    onConflict: WebrtcOnConflict
  ): WebrtcMutationResponse
  """
  insert a single row into the table: "webrtc"
  """
  insertWebrtcOne(
    "the row to be inserted"
    object: WebrtcInsertInput!,
    "upsert condition"
    onConflict: WebrtcOnConflict
  ): Webrtc
  signup(SignupInput: SignupInput): SignupOutput
  smartcodec: smartcodecMutation
  """
  update data of the table: "action"
  """
  updateAction(
    "sets the columns of the filtered rows to the given values"
    _set: ActionSetInput,
    "filter the rows which have to be updated"
    where: ActionBoolExp!
  ): ActionMutationResponse
  """
  update single row of the table: "action"
  """
  updateActionByPk(
    "sets the columns of the filtered rows to the given values"
    _set: ActionSetInput,pk_columns: ActionPkColumnsInput!  ): Action
  """
  update multiples rows of table: "action"
  """
  updateActionMany(
    "updates to execute, in order"
    updates: [ActionUpdates!]!
  ): [ActionMutationResponse]
  """
  update data of the table: "address"
  """
  updateAddress(
    "sets the columns of the filtered rows to the given values"
    _set: AddressSetInput,
    "filter the rows which have to be updated"
    where: AddressBoolExp!
  ): AddressMutationResponse
  """
  update single row of the table: "address"
  """
  updateAddressByPk(
    "sets the columns of the filtered rows to the given values"
    _set: AddressSetInput,pk_columns: AddressPkColumnsInput!  ): Address
  """
  update multiples rows of table: "address"
  """
  updateAddressMany(
    "updates to execute, in order"
    updates: [AddressUpdates!]!
  ): [AddressMutationResponse]
  """
  update data of the table: "button"
  """
  updateButton(
    "increments the numeric columns with given value of the filtered values"
    _inc: ButtonIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: ButtonSetInput,
    "filter the rows which have to be updated"
    where: ButtonBoolExp!
  ): ButtonMutationResponse
  """
  update single row of the table: "button"
  """
  updateButtonByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: ButtonIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: ButtonSetInput,pk_columns: ButtonPkColumnsInput!  ): Button
  """
  update multiples rows of table: "button"
  """
  updateButtonMany(
    "updates to execute, in order"
    updates: [ButtonUpdates!]!
  ): [ButtonMutationResponse]
  """
  update data of the table: "calendar"
  """
  updateCalendar(
    "sets the columns of the filtered rows to the given values"
    _set: CalendarSetInput,
    "filter the rows which have to be updated"
    where: CalendarBoolExp!
  ): CalendarMutationResponse
  """
  update single row of the table: "calendar"
  """
  updateCalendarByPk(
    "sets the columns of the filtered rows to the given values"
    _set: CalendarSetInput,pk_columns: CalendarPkColumnsInput!  ): Calendar
  """
  update multiples rows of table: "calendar"
  """
  updateCalendarMany(
    "updates to execute, in order"
    updates: [CalendarUpdates!]!
  ): [CalendarMutationResponse]
  """
  update data of the table: "card"
  """
  updateCard(
    "sets the columns of the filtered rows to the given values"
    _set: CardSetInput,
    "filter the rows which have to be updated"
    where: CardBoolExp!
  ): CardMutationResponse
  """
  update data of the table: "card_button"
  """
  updateCardButton(
    "sets the columns of the filtered rows to the given values"
    _set: CardButtonSetInput,
    "filter the rows which have to be updated"
    where: CardButtonBoolExp!
  ): CardButtonMutationResponse
  """
  update single row of the table: "card_button"
  """
  updateCardButtonByPk(
    "sets the columns of the filtered rows to the given values"
    _set: CardButtonSetInput,pk_columns: CardButtonPkColumnsInput!  ): CardButton
  """
  update multiples rows of table: "card_button"
  """
  updateCardButtonMany(
    "updates to execute, in order"
    updates: [CardButtonUpdates!]!
  ): [CardButtonMutationResponse]
  """
  update single row of the table: "card"
  """
  updateCardByPk(
    "sets the columns of the filtered rows to the given values"
    _set: CardSetInput,pk_columns: CardPkColumnsInput!  ): Card
  """
  update data of the table: "card_grid"
  """
  updateCardGrid(
    "increments the numeric columns with given value of the filtered values"
    _inc: CardGridIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: CardGridSetInput,
    "filter the rows which have to be updated"
    where: CardGridBoolExp!
  ): CardGridMutationResponse
  """
  update single row of the table: "card_grid"
  """
  updateCardGridByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: CardGridIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: CardGridSetInput,pk_columns: CardGridPkColumnsInput!  ): CardGrid
  """
  update multiples rows of table: "card_grid"
  """
  updateCardGridMany(
    "updates to execute, in order"
    updates: [CardGridUpdates!]!
  ): [CardGridMutationResponse]
  """
  update multiples rows of table: "card"
  """
  updateCardMany(
    "updates to execute, in order"
    updates: [CardUpdates!]!
  ): [CardMutationResponse]
  """
  update data of the table: "card_tag"
  """
  updateCardTag(
    "sets the columns of the filtered rows to the given values"
    _set: CardTagSetInput,
    "filter the rows which have to be updated"
    where: CardTagBoolExp!
  ): CardTagMutationResponse
  """
  update single row of the table: "card_tag"
  """
  updateCardTagByPk(
    "sets the columns of the filtered rows to the given values"
    _set: CardTagSetInput,pk_columns: CardTagPkColumnsInput!  ): CardTag
  """
  update multiples rows of table: "card_tag"
  """
  updateCardTagMany(
    "updates to execute, in order"
    updates: [CardTagUpdates!]!
  ): [CardTagMutationResponse]
  """
  update data of the table: "card_type"
  """
  updateCardType(
    "sets the columns of the filtered rows to the given values"
    _set: CardTypeSetInput,
    "filter the rows which have to be updated"
    where: CardTypeBoolExp!
  ): CardTypeMutationResponse
  """
  update single row of the table: "card_type"
  """
  updateCardTypeByPk(
    "sets the columns of the filtered rows to the given values"
    _set: CardTypeSetInput,pk_columns: CardTypePkColumnsInput!  ): CardType
  """
  update multiples rows of table: "card_type"
  """
  updateCardTypeMany(
    "updates to execute, in order"
    updates: [CardTypeUpdates!]!
  ): [CardTypeMutationResponse]
  """
  update data of the table: "codec"
  """
  updateCodec(
    "increments the numeric columns with given value of the filtered values"
    _inc: CodecIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: CodecSetInput,
    "filter the rows which have to be updated"
    where: CodecBoolExp!
  ): CodecMutationResponse
  """
  update single row of the table: "codec"
  """
  updateCodecByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: CodecIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: CodecSetInput,pk_columns: CodecPkColumnsInput!  ): Codec
  """
  update multiples rows of table: "codec"
  """
  updateCodecMany(
    "updates to execute, in order"
    updates: [CodecUpdates!]!
  ): [CodecMutationResponse]
  """
  update data of the table: "contact"
  """
  updateContact(
    "sets the columns of the filtered rows to the given values"
    _set: ContactSetInput,
    "filter the rows which have to be updated"
    where: ContactBoolExp!
  ): ContactMutationResponse
  """
  update single row of the table: "contact"
  """
  updateContactByPk(
    "sets the columns of the filtered rows to the given values"
    _set: ContactSetInput,pk_columns: ContactPkColumnsInput!  ): Contact
  """
  update multiples rows of table: "contact"
  """
  updateContactMany(
    "updates to execute, in order"
    updates: [ContactUpdates!]!
  ): [ContactMutationResponse]
  """
  update data of the table: "device"
  """
  updateDevice(
    "sets the columns of the filtered rows to the given values"
    _set: DeviceSetInput,
    "filter the rows which have to be updated"
    where: DeviceBoolExp!
  ): DeviceMutationResponse
  """
  update single row of the table: "device"
  """
  updateDeviceByPk(
    "sets the columns of the filtered rows to the given values"
    _set: DeviceSetInput,pk_columns: DevicePkColumnsInput!  ): Device
  """
  update multiples rows of table: "device"
  """
  updateDeviceMany(
    "updates to execute, in order"
    updates: [DeviceUpdates!]!
  ): [DeviceMutationResponse]
  """
  update data of the table: "email"
  """
  updateEmail(
    "sets the columns of the filtered rows to the given values"
    _set: EmailSetInput,
    "filter the rows which have to be updated"
    where: EmailBoolExp!
  ): EmailMutationResponse
  """
  update single row of the table: "email"
  """
  updateEmailByPk(
    "sets the columns of the filtered rows to the given values"
    _set: EmailSetInput,pk_columns: EmailPkColumnsInput!  ): Email
  """
  update multiples rows of table: "email"
  """
  updateEmailMany(
    "updates to execute, in order"
    updates: [EmailUpdates!]!
  ): [EmailMutationResponse]
  """
  update data of the table: "event"
  """
  updateEvent(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: EventAppendInput,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _deleteAtPath: EventDeleteAtPathInput,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _deleteElem: EventDeleteElemInput,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _deleteKey: EventDeleteKeyInput,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: EventPrependInput,
    "sets the columns of the filtered rows to the given values"
    _set: EventSetInput,
    "filter the rows which have to be updated"
    where: EventBoolExp!
  ): EventMutationResponse
  """
  update single row of the table: "event"
  """
  updateEventByPk(
    "append existing jsonb value of filtered columns with new jsonb value"
    _append: EventAppendInput,
    "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
    _deleteAtPath: EventDeleteAtPathInput,
    "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
    _deleteElem: EventDeleteElemInput,
    "delete key/value pair or string element. key/value pairs are matched based on their key value"
    _deleteKey: EventDeleteKeyInput,
    "prepend existing jsonb value of filtered columns with new jsonb value"
    _prepend: EventPrependInput,
    "sets the columns of the filtered rows to the given values"
    _set: EventSetInput,pk_columns: EventPkColumnsInput!  ): Event
  """
  update multiples rows of table: "event"
  """
  updateEventMany(
    "updates to execute, in order"
    updates: [EventUpdates!]!
  ): [EventMutationResponse]
  """
  update data of the table: "grid"
  """
  updateGrid(
    "increments the numeric columns with given value of the filtered values"
    _inc: GridIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: GridSetInput,
    "filter the rows which have to be updated"
    where: GridBoolExp!
  ): GridMutationResponse
  """
  update single row of the table: "grid"
  """
  updateGridByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: GridIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: GridSetInput,pk_columns: GridPkColumnsInput!  ): Grid
  """
  update multiples rows of table: "grid"
  """
  updateGridMany(
    "updates to execute, in order"
    updates: [GridUpdates!]!
  ): [GridMutationResponse]
  """
  update data of the table: "grid_showinfo"
  """
  updateGridShowinfo(
    "sets the columns of the filtered rows to the given values"
    _set: GridShowinfoSetInput,
    "filter the rows which have to be updated"
    where: GridShowinfoBoolExp!
  ): GridShowinfoMutationResponse
  """
  update single row of the table: "grid_showinfo"
  """
  updateGridShowinfoByPk(
    "sets the columns of the filtered rows to the given values"
    _set: GridShowinfoSetInput,pk_columns: GridShowinfoPkColumnsInput!  ): GridShowinfo
  """
  update multiples rows of table: "grid_showinfo"
  """
  updateGridShowinfoMany(
    "updates to execute, in order"
    updates: [GridShowinfoUpdates!]!
  ): [GridShowinfoMutationResponse]
  """
  update data of the table: "group"
  """
  updateGroup(
    "sets the columns of the filtered rows to the given values"
    _set: GroupSetInput,
    "filter the rows which have to be updated"
    where: GroupBoolExp!
  ): GroupMutationResponse
  """
  update single row of the table: "group"
  """
  updateGroupByPk(
    "sets the columns of the filtered rows to the given values"
    _set: GroupSetInput,pk_columns: GroupPkColumnsInput!  ): Group
  """
  update multiples rows of table: "group"
  """
  updateGroupMany(
    "updates to execute, in order"
    updates: [GroupUpdates!]!
  ): [GroupMutationResponse]
  """
  update data of the table: "group_studio"
  """
  updateGroupStudio(
    "sets the columns of the filtered rows to the given values"
    _set: GroupStudioSetInput,
    "filter the rows which have to be updated"
    where: GroupStudioBoolExp!
  ): GroupStudioMutationResponse
  """
  update single row of the table: "group_studio"
  """
  updateGroupStudioByPk(
    "sets the columns of the filtered rows to the given values"
    _set: GroupStudioSetInput,pk_columns: GroupStudioPkColumnsInput!  ): GroupStudio
  """
  update multiples rows of table: "group_studio"
  """
  updateGroupStudioMany(
    "updates to execute, in order"
    updates: [GroupStudioUpdates!]!
  ): [GroupStudioMutationResponse]
  """
  update data of the table: "line"
  """
  updateLine(
    "sets the columns of the filtered rows to the given values"
    _set: LineSetInput,
    "filter the rows which have to be updated"
    where: LineBoolExp!
  ): LineMutationResponse
  """
  update single row of the table: "line"
  """
  updateLineByPk(
    "sets the columns of the filtered rows to the given values"
    _set: LineSetInput,pk_columns: LinePkColumnsInput!  ): Line
  """
  update multiples rows of table: "line"
  """
  updateLineMany(
    "updates to execute, in order"
    updates: [LineUpdates!]!
  ): [LineMutationResponse]
  """
  update data of the table: "line_studio"
  """
  updateLineStudio(
    "sets the columns of the filtered rows to the given values"
    _set: LineStudioSetInput,
    "filter the rows which have to be updated"
    where: LineStudioBoolExp!
  ): LineStudioMutationResponse
  """
  update single row of the table: "line_studio"
  """
  updateLineStudioByPk(
    "sets the columns of the filtered rows to the given values"
    _set: LineStudioSetInput,pk_columns: LineStudioPkColumnsInput!  ): LineStudio
  """
  update multiples rows of table: "line_studio"
  """
  updateLineStudioMany(
    "updates to execute, in order"
    updates: [LineStudioUpdates!]!
  ): [LineStudioMutationResponse]
  """
  update data of the table: "line_type"
  """
  updateLineType(
    "sets the columns of the filtered rows to the given values"
    _set: LineTypeSetInput,
    "filter the rows which have to be updated"
    where: LineTypeBoolExp!
  ): LineTypeMutationResponse
  """
  update single row of the table: "line_type"
  """
  updateLineTypeByPk(
    "sets the columns of the filtered rows to the given values"
    _set: LineTypeSetInput,pk_columns: LineTypePkColumnsInput!  ): LineType
  """
  update multiples rows of table: "line_type"
  """
  updateLineTypeMany(
    "updates to execute, in order"
    updates: [LineTypeUpdates!]!
  ): [LineTypeMutationResponse]
  """
  update data of the table: "media"
  """
  updateMedia(
    "sets the columns of the filtered rows to the given values"
    _set: MediaSetInput,
    "filter the rows which have to be updated"
    where: MediaBoolExp!
  ): MediaMutationResponse
  """
  update single row of the table: "media"
  """
  updateMediaByPk(
    "sets the columns of the filtered rows to the given values"
    _set: MediaSetInput,pk_columns: MediaPkColumnsInput!  ): Media
  """
  update multiples rows of table: "media"
  """
  updateMediaMany(
    "updates to execute, in order"
    updates: [MediaUpdates!]!
  ): [MediaMutationResponse]
  """
  update data of the table: "organization"
  """
  updateOrganization(
    "sets the columns of the filtered rows to the given values"
    _set: OrganizationSetInput,
    "filter the rows which have to be updated"
    where: OrganizationBoolExp!
  ): OrganizationMutationResponse
  """
  update single row of the table: "organization"
  """
  updateOrganizationByPk(
    "sets the columns of the filtered rows to the given values"
    _set: OrganizationSetInput,pk_columns: OrganizationPkColumnsInput!  ): Organization
  """
  update multiples rows of table: "organization"
  """
  updateOrganizationMany(
    "updates to execute, in order"
    updates: [OrganizationUpdates!]!
  ): [OrganizationMutationResponse]
  """
  update data of the table: "phone"
  """
  updatePhone(
    "sets the columns of the filtered rows to the given values"
    _set: PhoneSetInput,
    "filter the rows which have to be updated"
    where: PhoneBoolExp!
  ): PhoneMutationResponse
  """
  update single row of the table: "phone"
  """
  updatePhoneByPk(
    "sets the columns of the filtered rows to the given values"
    _set: PhoneSetInput,pk_columns: PhonePkColumnsInput!  ): Phone
  """
  update multiples rows of table: "phone"
  """
  updatePhoneMany(
    "updates to execute, in order"
    updates: [PhoneUpdates!]!
  ): [PhoneMutationResponse]
  """
  update data of the table: "setting"
  """
  updateSetting(
    "increments the numeric columns with given value of the filtered values"
    _inc: SettingIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: SettingSetInput,
    "filter the rows which have to be updated"
    where: SettingBoolExp!
  ): SettingMutationResponse
  """
  update single row of the table: "setting"
  """
  updateSettingByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: SettingIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: SettingSetInput,pk_columns: SettingPkColumnsInput!  ): Setting
  """
  update multiples rows of table: "setting"
  """
  updateSettingMany(
    "updates to execute, in order"
    updates: [SettingUpdates!]!
  ): [SettingMutationResponse]
  """
  update data of the table: "showinfo"
  """
  updateShowinfo(
    "increments the numeric columns with given value of the filtered values"
    _inc: ShowinfoIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: ShowinfoSetInput,
    "filter the rows which have to be updated"
    where: ShowinfoBoolExp!
  ): ShowinfoMutationResponse
  """
  update single row of the table: "showinfo"
  """
  updateShowinfoByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: ShowinfoIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: ShowinfoSetInput,pk_columns: ShowinfoPkColumnsInput!  ): Showinfo
  """
  update multiples rows of table: "showinfo"
  """
  updateShowinfoMany(
    "updates to execute, in order"
    updates: [ShowinfoUpdates!]!
  ): [ShowinfoMutationResponse]
  """
  update data of the table: "sip"
  """
  updateSip(
    "sets the columns of the filtered rows to the given values"
    _set: SipSetInput,
    "filter the rows which have to be updated"
    where: SipBoolExp!
  ): SipMutationResponse
  """
  update single row of the table: "sip"
  """
  updateSipByPk(
    "sets the columns of the filtered rows to the given values"
    _set: SipSetInput,pk_columns: SipPkColumnsInput!  ): Sip
  """
  update multiples rows of table: "sip"
  """
  updateSipMany(
    "updates to execute, in order"
    updates: [SipUpdates!]!
  ): [SipMutationResponse]
  """
  update data of the table: "studio"
  """
  updateStudio(
    "sets the columns of the filtered rows to the given values"
    _set: StudioSetInput,
    "filter the rows which have to be updated"
    where: StudioBoolExp!
  ): StudioMutationResponse
  """
  update single row of the table: "studio"
  """
  updateStudioByPk(
    "sets the columns of the filtered rows to the given values"
    _set: StudioSetInput,pk_columns: StudioPkColumnsInput!  ): Studio
  """
  update multiples rows of table: "studio"
  """
  updateStudioMany(
    "updates to execute, in order"
    updates: [StudioUpdates!]!
  ): [StudioMutationResponse]
  """
  update data of the table: "tag"
  """
  updateTag(
    "sets the columns of the filtered rows to the given values"
    _set: TagSetInput,
    "filter the rows which have to be updated"
    where: TagBoolExp!
  ): TagMutationResponse
  """
  update single row of the table: "tag"
  """
  updateTagByPk(
    "sets the columns of the filtered rows to the given values"
    _set: TagSetInput,pk_columns: TagPkColumnsInput!  ): Tag
  """
  update multiples rows of table: "tag"
  """
  updateTagMany(
    "updates to execute, in order"
    updates: [TagUpdates!]!
  ): [TagMutationResponse]
  """
  update data of the table: "user"
  """
  updateUser(
    "sets the columns of the filtered rows to the given values"
    _set: UserSetInput,
    "filter the rows which have to be updated"
    where: UserBoolExp!
  ): UserMutationResponse
  """
  update single row of the table: "user"
  """
  updateUserByPk(
    "sets the columns of the filtered rows to the given values"
    _set: UserSetInput,pk_columns: UserPkColumnsInput!  ): User
  """
  update data of the table: "user_group"
  """
  updateUserGroup(
    "sets the columns of the filtered rows to the given values"
    _set: UserGroupSetInput,
    "filter the rows which have to be updated"
    where: UserGroupBoolExp!
  ): UserGroupMutationResponse
  """
  update single row of the table: "user_group"
  """
  updateUserGroupByPk(
    "sets the columns of the filtered rows to the given values"
    _set: UserGroupSetInput,pk_columns: UserGroupPkColumnsInput!  ): UserGroup
  """
  update multiples rows of table: "user_group"
  """
  updateUserGroupMany(
    "updates to execute, in order"
    updates: [UserGroupUpdates!]!
  ): [UserGroupMutationResponse]
  """
  update multiples rows of table: "user"
  """
  updateUserMany(
    "updates to execute, in order"
    updates: [UserUpdates!]!
  ): [UserMutationResponse]
  """
  update data of the table: "webrtc"
  """
  updateWebrtc(
    "increments the numeric columns with given value of the filtered values"
    _inc: WebrtcIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: WebrtcSetInput,
    "filter the rows which have to be updated"
    where: WebrtcBoolExp!
  ): WebrtcMutationResponse
  """
  update single row of the table: "webrtc"
  """
  updateWebrtcByPk(
    "increments the numeric columns with given value of the filtered values"
    _inc: WebrtcIncInput,
    "sets the columns of the filtered rows to the given values"
    _set: WebrtcSetInput,pk_columns: WebrtcPkColumnsInput!  ): Webrtc
  """
  update multiples rows of table: "webrtc"
  """
  updateWebrtcMany(
    "updates to execute, in order"
    updates: [WebrtcUpdates!]!
  ): [WebrtcMutationResponse]
}
type query_root {
  """
  fetch data from the table: "action"
  """
  action(
    "distinct select on columns"
    distinctOn: [ActionSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ActionOrderBy!],
    "filter the rows returned"
    where: ActionBoolExp
  ): [Action!]!
  """
  fetch aggregated fields from the table: "action"
  """
  actionAggregate(
    "distinct select on columns"
    distinctOn: [ActionSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ActionOrderBy!],
    "filter the rows returned"
    where: ActionBoolExp
  ): ActionAggregate!
  """
  fetch data from the table: "action" using primary key columns
  """
  actionByPk(
    "The unique identifier of the action."
    id: uuid!
  ): Action
  """
  fetch data from the table: "address"
  """
  address(
    "distinct select on columns"
    distinctOn: [AddressSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [AddressOrderBy!],
    "filter the rows returned"
    where: AddressBoolExp
  ): [Address!]!
  """
  fetch aggregated fields from the table: "address"
  """
  addressAggregate(
    "distinct select on columns"
    distinctOn: [AddressSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [AddressOrderBy!],
    "filter the rows returned"
    where: AddressBoolExp
  ): AddressAggregate!
  """
  fetch data from the table: "address" using primary key columns
  """
  addressByPk(
    "The unique identifier of the address."
    id: uuid!
  ): Address
  """
  fetch data from the table: "button"
  """
  button(
    "distinct select on columns"
    distinctOn: [ButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ButtonOrderBy!],
    "filter the rows returned"
    where: ButtonBoolExp
  ): [Button!]!
  """
  fetch aggregated fields from the table: "button"
  """
  buttonAggregate(
    "distinct select on columns"
    distinctOn: [ButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ButtonOrderBy!],
    "filter the rows returned"
    where: ButtonBoolExp
  ): ButtonAggregate!
  """
  fetch data from the table: "button" using primary key columns
  """
  buttonByPk(
    "The unique identifier of the button."
    id: uuid!
  ): Button
  """
  fetch data from the table: "calendar"
  """
  calendar(
    "distinct select on columns"
    distinctOn: [CalendarSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CalendarOrderBy!],
    "filter the rows returned"
    where: CalendarBoolExp
  ): [Calendar!]!
  """
  fetch aggregated fields from the table: "calendar"
  """
  calendarAggregate(
    "distinct select on columns"
    distinctOn: [CalendarSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CalendarOrderBy!],
    "filter the rows returned"
    where: CalendarBoolExp
  ): CalendarAggregate!
  """
  fetch data from the table: "calendar" using primary key columns
  """
  calendarByPk(
    "The unique identifier of the calendar."
    id: uuid!
  ): Calendar
  """
  fetch data from the table: "card"
  """
  card(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): [Card!]!
  """
  fetch aggregated fields from the table: "card"
  """
  cardAggregate(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): CardAggregate!
  """
  fetch data from the table: "card_button"
  """
  cardButton(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): [CardButton!]!
  """
  fetch aggregated fields from the table: "card_button"
  """
  cardButtonAggregate(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): CardButtonAggregate!
  """
  fetch data from the table: "card_button" using primary key columns
  """
  cardButtonByPk(buttonId: uuid!, cardId: uuid!): CardButton
  """
  fetch data from the table: "card" using primary key columns
  """
  cardByPk(
    "The unique identifier of the card."
    id: uuid!
  ): Card
  """
  fetch data from the table: "card_grid"
  """
  cardGrid(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): [CardGrid!]!
  """
  fetch aggregated fields from the table: "card_grid"
  """
  cardGridAggregate(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): CardGridAggregate!
  """
  fetch data from the table: "card_grid" using primary key columns
  """
  cardGridByPk(
    "The card that is in the grid."
    cardId: uuid!,
    "The grid that the card is in."
    gridId: uuid!
  ): CardGrid
  """
  fetch data from the table: "card_tag"
  """
  cardTag(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): [CardTag!]!
  """
  fetch aggregated fields from the table: "card_tag"
  """
  cardTagAggregate(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): CardTagAggregate!
  """
  fetch data from the table: "card_tag" using primary key columns
  """
  cardTagByPk(cardId: uuid!, tagId: uuid!): CardTag
  """
  fetch data from the table: "card_type"
  """
  cardType(
    "distinct select on columns"
    distinctOn: [CardTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTypeOrderBy!],
    "filter the rows returned"
    where: CardTypeBoolExp
  ): [CardType!]!
  """
  fetch aggregated fields from the table: "card_type"
  """
  cardTypeAggregate(
    "distinct select on columns"
    distinctOn: [CardTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTypeOrderBy!],
    "filter the rows returned"
    where: CardTypeBoolExp
  ): CardTypeAggregate!
  """
  fetch data from the table: "card_type" using primary key columns
  """
  cardTypeByPk(
    "The value of the card type."
    value: String!
  ): CardType
  """
  fetch data from the table: "codec"
  """
  codec(
    "distinct select on columns"
    distinctOn: [CodecSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CodecOrderBy!],
    "filter the rows returned"
    where: CodecBoolExp
  ): [Codec!]!
  """
  fetch aggregated fields from the table: "codec"
  """
  codecAggregate(
    "distinct select on columns"
    distinctOn: [CodecSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CodecOrderBy!],
    "filter the rows returned"
    where: CodecBoolExp
  ): CodecAggregate!
  """
  fetch data from the table: "codec" using primary key columns
  """
  codecByPk(
    "The unique identifier of the codec."
    id: uuid!
  ): Codec
  """
  fetch data from the table: "contact"
  """
  contact(
    "distinct select on columns"
    distinctOn: [ContactSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ContactOrderBy!],
    "filter the rows returned"
    where: ContactBoolExp
  ): [Contact!]!
  """
  fetch aggregated fields from the table: "contact"
  """
  contactAggregate(
    "distinct select on columns"
    distinctOn: [ContactSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ContactOrderBy!],
    "filter the rows returned"
    where: ContactBoolExp
  ): ContactAggregate!
  """
  fetch data from the table: "contact" using primary key columns
  """
  contactByPk(
    "The unique identifier of the contact."
    id: uuid!
  ): Contact
  """
  fetch data from the table: "device"
  """
  device(
    "distinct select on columns"
    distinctOn: [DeviceSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [DeviceOrderBy!],
    "filter the rows returned"
    where: DeviceBoolExp
  ): [Device!]!
  """
  fetch aggregated fields from the table: "device"
  """
  deviceAggregate(
    "distinct select on columns"
    distinctOn: [DeviceSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [DeviceOrderBy!],
    "filter the rows returned"
    where: DeviceBoolExp
  ): DeviceAggregate!
  """
  fetch data from the table: "device" using primary key columns
  """
  deviceByPk(
    "The unique identifier of the device."
    id: uuid!
  ): Device
  """
  fetch data from the table: "email"
  """
  email(
    "distinct select on columns"
    distinctOn: [EmailSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EmailOrderBy!],
    "filter the rows returned"
    where: EmailBoolExp
  ): [Email!]!
  """
  fetch aggregated fields from the table: "email"
  """
  emailAggregate(
    "distinct select on columns"
    distinctOn: [EmailSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EmailOrderBy!],
    "filter the rows returned"
    where: EmailBoolExp
  ): EmailAggregate!
  """
  fetch data from the table: "email" using primary key columns
  """
  emailByPk(
    "The unique identifier of the email."
    id: uuid!
  ): Email
  """
  fetch data from the table: "event"
  """
  event(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): [Event!]!
  """
  fetch aggregated fields from the table: "event"
  """
  eventAggregate(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): EventAggregate!
  """
  fetch data from the table: "event" using primary key columns
  """
  eventByPk(
    "The unique identifier of the event."
    id: uuid!
  ): Event
  """
  fetch data from the table: "grid"
  """
  grid(
    "distinct select on columns"
    distinctOn: [GridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridOrderBy!],
    "filter the rows returned"
    where: GridBoolExp
  ): [Grid!]!
  """
  fetch aggregated fields from the table: "grid"
  """
  gridAggregate(
    "distinct select on columns"
    distinctOn: [GridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridOrderBy!],
    "filter the rows returned"
    where: GridBoolExp
  ): GridAggregate!
  """
  fetch data from the table: "grid" using primary key columns
  """
  gridByPk(
    "The unique identifier of the grid."
    id: uuid!
  ): Grid
  """
  fetch data from the table: "grid_showinfo"
  """
  gridShowinfo(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): [GridShowinfo!]!
  """
  fetch aggregated fields from the table: "grid_showinfo"
  """
  gridShowinfoAggregate(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): GridShowinfoAggregate!
  """
  fetch data from the table: "grid_showinfo" using primary key columns
  """
  gridShowinfoByPk(
    "The unique identifier of the grid_showinfo."
    id: uuid!
  ): GridShowinfo
  """
  fetch data from the table: "group"
  """
  group(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): [Group!]!
  """
  fetch aggregated fields from the table: "group"
  """
  groupAggregate(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): GroupAggregate!
  """
  fetch data from the table: "group" using primary key columns
  """
  groupByPk(
    "The unique identifier of the group."
    id: uuid!
  ): Group
  """
  fetch data from the table: "group_studio"
  """
  groupStudio(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): [GroupStudio!]!
  """
  fetch aggregated fields from the table: "group_studio"
  """
  groupStudioAggregate(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): GroupStudioAggregate!
  """
  fetch data from the table: "group_studio" using primary key columns
  """
  groupStudioByPk(
    "The group of the group studio."
    groupId: uuid!,
    "The studio of the group studio."
    studioId: uuid!
  ): GroupStudio
  """
  fetch data from the table: "line"
  """
  line(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): [Line!]!
  """
  fetch aggregated fields from the table: "line"
  """
  lineAggregate(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): LineAggregate!
  """
  fetch data from the table: "line" using primary key columns
  """
  lineByPk(
    "The unique identifier of the line."
    id: uuid!
  ): Line
  """
  fetch data from the table: "line_studio"
  """
  lineStudio(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): [LineStudio!]!
  """
  fetch aggregated fields from the table: "line_studio"
  """
  lineStudioAggregate(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): LineStudioAggregate!
  """
  fetch data from the table: "line_studio" using primary key columns
  """
  lineStudioByPk(
    "The line this line_studio is linked to."
    lineId: uuid!,
    "The studio this line_studio is linked to."
    studioId: uuid!
  ): LineStudio
  """
  fetch data from the table: "line_type"
  """
  lineType(
    "distinct select on columns"
    distinctOn: [LineTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineTypeOrderBy!],
    "filter the rows returned"
    where: LineTypeBoolExp
  ): [LineType!]!
  """
  fetch aggregated fields from the table: "line_type"
  """
  lineTypeAggregate(
    "distinct select on columns"
    distinctOn: [LineTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineTypeOrderBy!],
    "filter the rows returned"
    where: LineTypeBoolExp
  ): LineTypeAggregate!
  """
  fetch data from the table: "line_type" using primary key columns
  """
  lineTypeByPk(
    "The value of the line type."
    value: String!
  ): LineType
  """
  fetch data from the table: "media"
  """
  media(
    "distinct select on columns"
    distinctOn: [MediaSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [MediaOrderBy!],
    "filter the rows returned"
    where: MediaBoolExp
  ): [Media!]!
  """
  fetch aggregated fields from the table: "media"
  """
  mediaAggregate(
    "distinct select on columns"
    distinctOn: [MediaSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [MediaOrderBy!],
    "filter the rows returned"
    where: MediaBoolExp
  ): MediaAggregate!
  """
  fetch data from the table: "media" using primary key columns
  """
  mediaByPk(
    "The unique identifier of the media."
    id: uuid!
  ): Media
  """
  fetch data from the table: "organization"
  """
  organization(
    "distinct select on columns"
    distinctOn: [OrganizationSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [OrganizationOrderBy!],
    "filter the rows returned"
    where: OrganizationBoolExp
  ): [Organization!]!
  """
  fetch aggregated fields from the table: "organization"
  """
  organizationAggregate(
    "distinct select on columns"
    distinctOn: [OrganizationSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [OrganizationOrderBy!],
    "filter the rows returned"
    where: OrganizationBoolExp
  ): OrganizationAggregate!
  """
  fetch data from the table: "organization" using primary key columns
  """
  organizationByPk(
    "The unique identifier of the organization."
    id: uuid!
  ): Organization
  """
  fetch data from the table: "phone"
  """
  phone(
    "distinct select on columns"
    distinctOn: [PhoneSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [PhoneOrderBy!],
    "filter the rows returned"
    where: PhoneBoolExp
  ): [Phone!]!
  """
  fetch aggregated fields from the table: "phone"
  """
  phoneAggregate(
    "distinct select on columns"
    distinctOn: [PhoneSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [PhoneOrderBy!],
    "filter the rows returned"
    where: PhoneBoolExp
  ): PhoneAggregate!
  """
  fetch data from the table: "phone" using primary key columns
  """
  phoneByPk(
    "The unique identifier of the contact phone."
    id: uuid!
  ): Phone
  """
  fetch data from the table: "setting"
  """
  setting(
    "distinct select on columns"
    distinctOn: [SettingSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SettingOrderBy!],
    "filter the rows returned"
    where: SettingBoolExp
  ): [Setting!]!
  """
  fetch aggregated fields from the table: "setting"
  """
  settingAggregate(
    "distinct select on columns"
    distinctOn: [SettingSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SettingOrderBy!],
    "filter the rows returned"
    where: SettingBoolExp
  ): SettingAggregate!
  """
  fetch data from the table: "setting" using primary key columns
  """
  settingByPk(
    "The unique identifier of the setting."
    id: uuid!
  ): Setting
  """
  fetch data from the table: "showinfo"
  """
  showinfo(
    "distinct select on columns"
    distinctOn: [ShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ShowinfoOrderBy!],
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): [Showinfo!]!
  """
  fetch aggregated fields from the table: "showinfo"
  """
  showinfoAggregate(
    "distinct select on columns"
    distinctOn: [ShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ShowinfoOrderBy!],
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): ShowinfoAggregate!
  """
  fetch data from the table: "showinfo" using primary key columns
  """
  showinfoByPk(
    "The unique identifier of the showinfo."
    id: uuid!
  ): Showinfo
  """
  fetch data from the table: "sip"
  """
  sip(
    "distinct select on columns"
    distinctOn: [SipSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SipOrderBy!],
    "filter the rows returned"
    where: SipBoolExp
  ): [Sip!]!
  """
  fetch aggregated fields from the table: "sip"
  """
  sipAggregate(
    "distinct select on columns"
    distinctOn: [SipSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SipOrderBy!],
    "filter the rows returned"
    where: SipBoolExp
  ): SipAggregate!
  """
  fetch data from the table: "sip" using primary key columns
  """
  sipByPk(
    "The unique identifier of the SIP line."
    id: uuid!
  ): Sip
  smartcodec: smartcodecQuery
  """
  fetch data from the table: "studio"
  """
  studio(
    "distinct select on columns"
    distinctOn: [StudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [StudioOrderBy!],
    "filter the rows returned"
    where: StudioBoolExp
  ): [Studio!]!
  """
  fetch aggregated fields from the table: "studio"
  """
  studioAggregate(
    "distinct select on columns"
    distinctOn: [StudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [StudioOrderBy!],
    "filter the rows returned"
    where: StudioBoolExp
  ): StudioAggregate!
  """
  fetch data from the table: "studio" using primary key columns
  """
  studioByPk(
    "The unique identifier of the studio."
    id: uuid!
  ): Studio
  """
  fetch data from the table: "tag"
  """
  tag(
    "distinct select on columns"
    distinctOn: [TagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [TagOrderBy!],
    "filter the rows returned"
    where: TagBoolExp
  ): [Tag!]!
  """
  fetch aggregated fields from the table: "tag"
  """
  tagAggregate(
    "distinct select on columns"
    distinctOn: [TagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [TagOrderBy!],
    "filter the rows returned"
    where: TagBoolExp
  ): TagAggregate!
  """
  fetch data from the table: "tag" using primary key columns
  """
  tagByPk(
    "The unique identifier of the tag."
    id: uuid!
  ): Tag
  """
  fetch data from the table: "user"
  """
  user(
    "distinct select on columns"
    distinctOn: [UserSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserOrderBy!],
    "filter the rows returned"
    where: UserBoolExp
  ): [User!]!
  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    "distinct select on columns"
    distinctOn: [UserSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserOrderBy!],
    "filter the rows returned"
    where: UserBoolExp
  ): UserAggregate!
  """
  fetch data from the table: "user" using primary key columns
  """
  userByPk(
    "The unique identifier of the user."
    id: uuid!
  ): User
  """
  fetch data from the table: "user_group"
  """
  userGroup(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): [UserGroup!]!
  """
  fetch aggregated fields from the table: "user_group"
  """
  userGroupAggregate(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): UserGroupAggregate!
  """
  fetch data from the table: "user_group" using primary key columns
  """
  userGroupByPk(
    "The group of the user group."
    groupId: uuid!,
    "The user of the user group."
    userId: uuid!
  ): UserGroup
  """
  fetch data from the table: "webrtc"
  """
  webrtc(
    "distinct select on columns"
    distinctOn: [WebrtcSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [WebrtcOrderBy!],
    "filter the rows returned"
    where: WebrtcBoolExp
  ): [Webrtc!]!
  """
  fetch aggregated fields from the table: "webrtc"
  """
  webrtcAggregate(
    "distinct select on columns"
    distinctOn: [WebrtcSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [WebrtcOrderBy!],
    "filter the rows returned"
    where: WebrtcBoolExp
  ): WebrtcAggregate!
  """
  fetch data from the table: "webrtc" using primary key columns
  """
  webrtcByPk(
    "The unique identifier of the WebRTC line."
    id: uuid!
  ): Webrtc
}
type smartcodecMutation {
  "End a call on a line"
  deleteCall(lineId: smartcodec_LineId!): smartcodec_Void
  "Setup an ongoing call"
  patchCall(input: smartcodec_CallSetup_Input, lineId: smartcodec_LineId!): smartcodec_Void
  "Update line properties that can be changed"
  patchLine(input: smartcodec_LineSetup_Input, lineId: smartcodec_LineId!): smartcodec_Void
  "Start a call on a line, the call has to be setup before it can be used"
  postCall(lineId: smartcodec_LineId!): smartcodec_Void
  "Initiate stream subscriptions, and receive stream updates at the specified URL"
  streams(input: smartcodec_Streams_request_Input): smartcodec_SubscriptionInfo
}
type smartcodecQuery {
  "Get a call information from a line"
  call(lineId: smartcodec_LineId!): smartcodec_Call2
  "Get all calls currently in progress"
  calls: [smartcodec_Call]
  "Get a codec information from the smart codec server"
  codec(codecId: smartcodec_CodecId!): smartcodec_Codec2
  "Get all hardware codecs information from the smart codec server"
  codecs: [smartcodec_Codec]
  "Get all events currently in progress"
  events: [smartcodec_query_events_items]
  "Get a line"
  line(lineId: smartcodec_LineId!): smartcodec_Line2
  "Get all lines"
  lines: [smartcodec_Line]
}
type smartcodecSubscription {
  "Receive a call data from the smart codec server"
  callStream: smartcodec_Call2
  "Receive a line data from the smart codec server"
  linesStream: smartcodec_Line2
}
"Call informations"
type smartcodec_Call {
  decode: smartcodec_query_calls_items_decode
  encode: smartcodec_query_calls_items_encode
  lineId: smartcodec_LineId!
}
"Call informations"
type smartcodec_Call2 {
  decode: smartcodec_query_calls_items_decode
  encode: smartcodec_query_calls_items_encode
  lineId: smartcodec_LineId!
}
"Call configuration that can be set by the client"
type smartcodec_CallSetup {
  "Array of addresses"
  addresses: [smartcodec_query_lines_items_setup_addresses_items]
  protocol: smartcodec_Protocol
}
"All informations about the hardware codec"
type smartcodec_Codec {
  id: smartcodec_CodecId!
  name: smartcodec_CodecName
  "Interface url to configure the codec"
  url: String
}
"All informations about the hardware codec"
type smartcodec_Codec2 {
  id: smartcodec_CodecId!
  name: smartcodec_CodecName
  "Interface url to configure the codec"
  url: String
}
"At which speed data flows"
type smartcodec_Datarate {
  name: smartcodec_DatarateName
  "Value from 1 to 1000000000"
  nbOfChannels: Int
}
"All informations about the line"
type smartcodec_Line {
  codecId: smartcodec_CodecId!
  error: smartcodec_LineError
  id: smartcodec_LineId!
  lineName: smartcodec_CodecName
  manufacturer: smartcodec_Manufacturer
  productId: smartcodec_ProductId
  "Line Capabilities"
  protocols: [smartcodec_query_lines_items_protocols_items]
  setup: smartcodec_LineSetup
  status: smartcodec_LineStatus
}
"All informations about the line"
type smartcodec_Line2 {
  codecId: smartcodec_CodecId!
  error: smartcodec_LineError
  id: smartcodec_LineId!
  lineName: smartcodec_CodecName
  manufacturer: smartcodec_Manufacturer
  productId: smartcodec_ProductId
  "Line Capabilities"
  protocols: [smartcodec_query_lines_items_protocols_items]
  setup: smartcodec_LineSetup
  status: smartcodec_LineStatus
}
"Error message from line"
type smartcodec_LineError {
  error: smartcodec_query_lines_items_error_error
}
"The level of the line"
type smartcodec_LineLevel {
  level: smartcodec_query_events_items_oneOf_1_level
}
"Line configuration that can be set by the client"
type smartcodec_LineSetup {
  "Array of addresses"
  addresses: [smartcodec_query_lines_items_setup_addresses_items]
  call: smartcodec_CallSetup
  protocol: smartcodec_Protocol
}
"The realtime status of the line"
type smartcodec_LineStatus {
  status: smartcodec_query_lines_items_status_status
}
type smartcodec_Protocol {
  datarate: smartcodec_Datarate
  "Protocol name"
  name: String
  samplingrate: smartcodec_Samplingrate
  "How the sound is splited"
  separation: String
  "The service used to cary the data"
  transport: String
}
"subscription information"
type smartcodec_SubscriptionInfo {
  subscriptionId: smartcodec_mutation_streams_subscriptionId!
}
"Distant protocol and datarate setup"
type smartcodec_query_calls_items_decode {
  "Array of addresses"
  addresses: [smartcodec_query_lines_items_setup_addresses_items]
  protocol: smartcodec_Protocol
}
"Local protocol and datarate setup"
type smartcodec_query_calls_items_encode {
  "Array of addresses"
  addresses: [smartcodec_query_lines_items_setup_addresses_items]
  protocol: smartcodec_Protocol
}
type smartcodec_query_events_items_oneOf_1_level {
  input: Float
  lineId: smartcodec_LineId!
  output: Float
}
type smartcodec_query_lines_items_error_error {
  message: smartcodec_query_lines_items_error_error_message
}
type smartcodec_query_lines_items_protocols_items {
  datarates: [smartcodec_Datarate]
  "Protocol name"
  name: String
  samplingrates: [smartcodec_Samplingrate]
  separations: [String]
  transports: [String]
}
type smartcodec_query_lines_items_setup_addresses_items {
  address: smartcodec_query_lines_items_setup_addresses_items_address
  "Value from 1 to 1000"
  addressIdx: Int
}
type smartcodec_query_lines_items_status_status {
  "The audio status of the line"
  audio_ok: Boolean
  direction: smartcodec_query_lines_items_status_status_direction
  state: smartcodec_query_lines_items_status_status_state
}
type subscription_root {
  """
  fetch data from the table: "action"
  """
  action(
    "distinct select on columns"
    distinctOn: [ActionSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ActionOrderBy!],
    "filter the rows returned"
    where: ActionBoolExp
  ): [Action!]!
  """
  fetch aggregated fields from the table: "action"
  """
  actionAggregate(
    "distinct select on columns"
    distinctOn: [ActionSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ActionOrderBy!],
    "filter the rows returned"
    where: ActionBoolExp
  ): ActionAggregate!
  """
  fetch data from the table: "action" using primary key columns
  """
  actionByPk(
    "The unique identifier of the action."
    id: uuid!
  ): Action
  """
  fetch data from the table in a streaming manner: "action"
  """
  actionStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [ActionStreamCursorInput]!,
    "filter the rows returned"
    where: ActionBoolExp
  ): [Action!]!
  """
  fetch data from the table: "address"
  """
  address(
    "distinct select on columns"
    distinctOn: [AddressSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [AddressOrderBy!],
    "filter the rows returned"
    where: AddressBoolExp
  ): [Address!]!
  """
  fetch aggregated fields from the table: "address"
  """
  addressAggregate(
    "distinct select on columns"
    distinctOn: [AddressSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [AddressOrderBy!],
    "filter the rows returned"
    where: AddressBoolExp
  ): AddressAggregate!
  """
  fetch data from the table: "address" using primary key columns
  """
  addressByPk(
    "The unique identifier of the address."
    id: uuid!
  ): Address
  """
  fetch data from the table in a streaming manner: "address"
  """
  addressStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [AddressStreamCursorInput]!,
    "filter the rows returned"
    where: AddressBoolExp
  ): [Address!]!
  """
  fetch data from the table: "button"
  """
  button(
    "distinct select on columns"
    distinctOn: [ButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ButtonOrderBy!],
    "filter the rows returned"
    where: ButtonBoolExp
  ): [Button!]!
  """
  fetch aggregated fields from the table: "button"
  """
  buttonAggregate(
    "distinct select on columns"
    distinctOn: [ButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ButtonOrderBy!],
    "filter the rows returned"
    where: ButtonBoolExp
  ): ButtonAggregate!
  """
  fetch data from the table: "button" using primary key columns
  """
  buttonByPk(
    "The unique identifier of the button."
    id: uuid!
  ): Button
  """
  fetch data from the table in a streaming manner: "button"
  """
  buttonStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [ButtonStreamCursorInput]!,
    "filter the rows returned"
    where: ButtonBoolExp
  ): [Button!]!
  """
  fetch data from the table: "calendar"
  """
  calendar(
    "distinct select on columns"
    distinctOn: [CalendarSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CalendarOrderBy!],
    "filter the rows returned"
    where: CalendarBoolExp
  ): [Calendar!]!
  """
  fetch aggregated fields from the table: "calendar"
  """
  calendarAggregate(
    "distinct select on columns"
    distinctOn: [CalendarSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CalendarOrderBy!],
    "filter the rows returned"
    where: CalendarBoolExp
  ): CalendarAggregate!
  """
  fetch data from the table: "calendar" using primary key columns
  """
  calendarByPk(
    "The unique identifier of the calendar."
    id: uuid!
  ): Calendar
  """
  fetch data from the table in a streaming manner: "calendar"
  """
  calendarStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CalendarStreamCursorInput]!,
    "filter the rows returned"
    where: CalendarBoolExp
  ): [Calendar!]!
  """
  fetch data from the table: "card"
  """
  card(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): [Card!]!
  """
  fetch aggregated fields from the table: "card"
  """
  cardAggregate(
    "distinct select on columns"
    distinctOn: [CardSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardOrderBy!],
    "filter the rows returned"
    where: CardBoolExp
  ): CardAggregate!
  """
  fetch data from the table: "card_button"
  """
  cardButton(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): [CardButton!]!
  """
  fetch aggregated fields from the table: "card_button"
  """
  cardButtonAggregate(
    "distinct select on columns"
    distinctOn: [CardButtonSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardButtonOrderBy!],
    "filter the rows returned"
    where: CardButtonBoolExp
  ): CardButtonAggregate!
  """
  fetch data from the table: "card_button" using primary key columns
  """
  cardButtonByPk(buttonId: uuid!, cardId: uuid!): CardButton
  """
  fetch data from the table in a streaming manner: "card_button"
  """
  cardButtonStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CardButtonStreamCursorInput]!,
    "filter the rows returned"
    where: CardButtonBoolExp
  ): [CardButton!]!
  """
  fetch data from the table: "card" using primary key columns
  """
  cardByPk(
    "The unique identifier of the card."
    id: uuid!
  ): Card
  """
  fetch data from the table: "card_grid"
  """
  cardGrid(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): [CardGrid!]!
  """
  fetch aggregated fields from the table: "card_grid"
  """
  cardGridAggregate(
    "distinct select on columns"
    distinctOn: [CardGridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardGridOrderBy!],
    "filter the rows returned"
    where: CardGridBoolExp
  ): CardGridAggregate!
  """
  fetch data from the table: "card_grid" using primary key columns
  """
  cardGridByPk(
    "The card that is in the grid."
    cardId: uuid!,
    "The grid that the card is in."
    gridId: uuid!
  ): CardGrid
  """
  fetch data from the table in a streaming manner: "card_grid"
  """
  cardGridStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CardGridStreamCursorInput]!,
    "filter the rows returned"
    where: CardGridBoolExp
  ): [CardGrid!]!
  """
  fetch data from the table in a streaming manner: "card"
  """
  cardStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CardStreamCursorInput]!,
    "filter the rows returned"
    where: CardBoolExp
  ): [Card!]!
  """
  fetch data from the table: "card_tag"
  """
  cardTag(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): [CardTag!]!
  """
  fetch aggregated fields from the table: "card_tag"
  """
  cardTagAggregate(
    "distinct select on columns"
    distinctOn: [CardTagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTagOrderBy!],
    "filter the rows returned"
    where: CardTagBoolExp
  ): CardTagAggregate!
  """
  fetch data from the table: "card_tag" using primary key columns
  """
  cardTagByPk(cardId: uuid!, tagId: uuid!): CardTag
  """
  fetch data from the table in a streaming manner: "card_tag"
  """
  cardTagStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CardTagStreamCursorInput]!,
    "filter the rows returned"
    where: CardTagBoolExp
  ): [CardTag!]!
  """
  fetch data from the table: "card_type"
  """
  cardType(
    "distinct select on columns"
    distinctOn: [CardTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTypeOrderBy!],
    "filter the rows returned"
    where: CardTypeBoolExp
  ): [CardType!]!
  """
  fetch aggregated fields from the table: "card_type"
  """
  cardTypeAggregate(
    "distinct select on columns"
    distinctOn: [CardTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CardTypeOrderBy!],
    "filter the rows returned"
    where: CardTypeBoolExp
  ): CardTypeAggregate!
  """
  fetch data from the table: "card_type" using primary key columns
  """
  cardTypeByPk(
    "The value of the card type."
    value: String!
  ): CardType
  """
  fetch data from the table in a streaming manner: "card_type"
  """
  cardTypeStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CardTypeStreamCursorInput]!,
    "filter the rows returned"
    where: CardTypeBoolExp
  ): [CardType!]!
  """
  fetch data from the table: "codec"
  """
  codec(
    "distinct select on columns"
    distinctOn: [CodecSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CodecOrderBy!],
    "filter the rows returned"
    where: CodecBoolExp
  ): [Codec!]!
  """
  fetch aggregated fields from the table: "codec"
  """
  codecAggregate(
    "distinct select on columns"
    distinctOn: [CodecSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [CodecOrderBy!],
    "filter the rows returned"
    where: CodecBoolExp
  ): CodecAggregate!
  """
  fetch data from the table: "codec" using primary key columns
  """
  codecByPk(
    "The unique identifier of the codec."
    id: uuid!
  ): Codec
  """
  fetch data from the table in a streaming manner: "codec"
  """
  codecStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [CodecStreamCursorInput]!,
    "filter the rows returned"
    where: CodecBoolExp
  ): [Codec!]!
  """
  fetch data from the table: "contact"
  """
  contact(
    "distinct select on columns"
    distinctOn: [ContactSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ContactOrderBy!],
    "filter the rows returned"
    where: ContactBoolExp
  ): [Contact!]!
  """
  fetch aggregated fields from the table: "contact"
  """
  contactAggregate(
    "distinct select on columns"
    distinctOn: [ContactSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ContactOrderBy!],
    "filter the rows returned"
    where: ContactBoolExp
  ): ContactAggregate!
  """
  fetch data from the table: "contact" using primary key columns
  """
  contactByPk(
    "The unique identifier of the contact."
    id: uuid!
  ): Contact
  """
  fetch data from the table in a streaming manner: "contact"
  """
  contactStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [ContactStreamCursorInput]!,
    "filter the rows returned"
    where: ContactBoolExp
  ): [Contact!]!
  """
  fetch data from the table: "device"
  """
  device(
    "distinct select on columns"
    distinctOn: [DeviceSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [DeviceOrderBy!],
    "filter the rows returned"
    where: DeviceBoolExp
  ): [Device!]!
  """
  fetch aggregated fields from the table: "device"
  """
  deviceAggregate(
    "distinct select on columns"
    distinctOn: [DeviceSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [DeviceOrderBy!],
    "filter the rows returned"
    where: DeviceBoolExp
  ): DeviceAggregate!
  """
  fetch data from the table: "device" using primary key columns
  """
  deviceByPk(
    "The unique identifier of the device."
    id: uuid!
  ): Device
  """
  fetch data from the table in a streaming manner: "device"
  """
  deviceStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [DeviceStreamCursorInput]!,
    "filter the rows returned"
    where: DeviceBoolExp
  ): [Device!]!
  """
  fetch data from the table: "email"
  """
  email(
    "distinct select on columns"
    distinctOn: [EmailSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EmailOrderBy!],
    "filter the rows returned"
    where: EmailBoolExp
  ): [Email!]!
  """
  fetch aggregated fields from the table: "email"
  """
  emailAggregate(
    "distinct select on columns"
    distinctOn: [EmailSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EmailOrderBy!],
    "filter the rows returned"
    where: EmailBoolExp
  ): EmailAggregate!
  """
  fetch data from the table: "email" using primary key columns
  """
  emailByPk(
    "The unique identifier of the email."
    id: uuid!
  ): Email
  """
  fetch data from the table in a streaming manner: "email"
  """
  emailStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [EmailStreamCursorInput]!,
    "filter the rows returned"
    where: EmailBoolExp
  ): [Email!]!
  """
  fetch data from the table: "event"
  """
  event(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): [Event!]!
  """
  fetch aggregated fields from the table: "event"
  """
  eventAggregate(
    "distinct select on columns"
    distinctOn: [EventSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [EventOrderBy!],
    "filter the rows returned"
    where: EventBoolExp
  ): EventAggregate!
  """
  fetch data from the table: "event" using primary key columns
  """
  eventByPk(
    "The unique identifier of the event."
    id: uuid!
  ): Event
  """
  fetch data from the table in a streaming manner: "event"
  """
  eventStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [EventStreamCursorInput]!,
    "filter the rows returned"
    where: EventBoolExp
  ): [Event!]!
  """
  fetch data from the table: "grid"
  """
  grid(
    "distinct select on columns"
    distinctOn: [GridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridOrderBy!],
    "filter the rows returned"
    where: GridBoolExp
  ): [Grid!]!
  """
  fetch aggregated fields from the table: "grid"
  """
  gridAggregate(
    "distinct select on columns"
    distinctOn: [GridSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridOrderBy!],
    "filter the rows returned"
    where: GridBoolExp
  ): GridAggregate!
  """
  fetch data from the table: "grid" using primary key columns
  """
  gridByPk(
    "The unique identifier of the grid."
    id: uuid!
  ): Grid
  """
  fetch data from the table: "grid_showinfo"
  """
  gridShowinfo(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): [GridShowinfo!]!
  """
  fetch aggregated fields from the table: "grid_showinfo"
  """
  gridShowinfoAggregate(
    "distinct select on columns"
    distinctOn: [GridShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GridShowinfoOrderBy!],
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): GridShowinfoAggregate!
  """
  fetch data from the table: "grid_showinfo" using primary key columns
  """
  gridShowinfoByPk(
    "The unique identifier of the grid_showinfo."
    id: uuid!
  ): GridShowinfo
  """
  fetch data from the table in a streaming manner: "grid_showinfo"
  """
  gridShowinfoStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [GridShowinfoStreamCursorInput]!,
    "filter the rows returned"
    where: GridShowinfoBoolExp
  ): [GridShowinfo!]!
  """
  fetch data from the table in a streaming manner: "grid"
  """
  gridStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [GridStreamCursorInput]!,
    "filter the rows returned"
    where: GridBoolExp
  ): [Grid!]!
  """
  fetch data from the table: "group"
  """
  group(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): [Group!]!
  """
  fetch aggregated fields from the table: "group"
  """
  groupAggregate(
    "distinct select on columns"
    distinctOn: [GroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupOrderBy!],
    "filter the rows returned"
    where: GroupBoolExp
  ): GroupAggregate!
  """
  fetch data from the table: "group" using primary key columns
  """
  groupByPk(
    "The unique identifier of the group."
    id: uuid!
  ): Group
  """
  fetch data from the table in a streaming manner: "group"
  """
  groupStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [GroupStreamCursorInput]!,
    "filter the rows returned"
    where: GroupBoolExp
  ): [Group!]!
  """
  fetch data from the table: "group_studio"
  """
  groupStudio(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): [GroupStudio!]!
  """
  fetch aggregated fields from the table: "group_studio"
  """
  groupStudioAggregate(
    "distinct select on columns"
    distinctOn: [GroupStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [GroupStudioOrderBy!],
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): GroupStudioAggregate!
  """
  fetch data from the table: "group_studio" using primary key columns
  """
  groupStudioByPk(
    "The group of the group studio."
    groupId: uuid!,
    "The studio of the group studio."
    studioId: uuid!
  ): GroupStudio
  """
  fetch data from the table in a streaming manner: "group_studio"
  """
  groupStudioStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [GroupStudioStreamCursorInput]!,
    "filter the rows returned"
    where: GroupStudioBoolExp
  ): [GroupStudio!]!
  """
  fetch data from the table: "line"
  """
  line(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): [Line!]!
  """
  fetch aggregated fields from the table: "line"
  """
  lineAggregate(
    "distinct select on columns"
    distinctOn: [LineSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineOrderBy!],
    "filter the rows returned"
    where: LineBoolExp
  ): LineAggregate!
  """
  fetch data from the table: "line" using primary key columns
  """
  lineByPk(
    "The unique identifier of the line."
    id: uuid!
  ): Line
  """
  fetch data from the table in a streaming manner: "line"
  """
  lineStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [LineStreamCursorInput]!,
    "filter the rows returned"
    where: LineBoolExp
  ): [Line!]!
  """
  fetch data from the table: "line_studio"
  """
  lineStudio(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): [LineStudio!]!
  """
  fetch aggregated fields from the table: "line_studio"
  """
  lineStudioAggregate(
    "distinct select on columns"
    distinctOn: [LineStudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineStudioOrderBy!],
    "filter the rows returned"
    where: LineStudioBoolExp
  ): LineStudioAggregate!
  """
  fetch data from the table: "line_studio" using primary key columns
  """
  lineStudioByPk(
    "The line this line_studio is linked to."
    lineId: uuid!,
    "The studio this line_studio is linked to."
    studioId: uuid!
  ): LineStudio
  """
  fetch data from the table in a streaming manner: "line_studio"
  """
  lineStudioStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [LineStudioStreamCursorInput]!,
    "filter the rows returned"
    where: LineStudioBoolExp
  ): [LineStudio!]!
  """
  fetch data from the table: "line_type"
  """
  lineType(
    "distinct select on columns"
    distinctOn: [LineTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineTypeOrderBy!],
    "filter the rows returned"
    where: LineTypeBoolExp
  ): [LineType!]!
  """
  fetch aggregated fields from the table: "line_type"
  """
  lineTypeAggregate(
    "distinct select on columns"
    distinctOn: [LineTypeSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [LineTypeOrderBy!],
    "filter the rows returned"
    where: LineTypeBoolExp
  ): LineTypeAggregate!
  """
  fetch data from the table: "line_type" using primary key columns
  """
  lineTypeByPk(
    "The value of the line type."
    value: String!
  ): LineType
  """
  fetch data from the table in a streaming manner: "line_type"
  """
  lineTypeStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [LineTypeStreamCursorInput]!,
    "filter the rows returned"
    where: LineTypeBoolExp
  ): [LineType!]!
  """
  fetch data from the table: "media"
  """
  media(
    "distinct select on columns"
    distinctOn: [MediaSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [MediaOrderBy!],
    "filter the rows returned"
    where: MediaBoolExp
  ): [Media!]!
  """
  fetch aggregated fields from the table: "media"
  """
  mediaAggregate(
    "distinct select on columns"
    distinctOn: [MediaSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [MediaOrderBy!],
    "filter the rows returned"
    where: MediaBoolExp
  ): MediaAggregate!
  """
  fetch data from the table: "media" using primary key columns
  """
  mediaByPk(
    "The unique identifier of the media."
    id: uuid!
  ): Media
  """
  fetch data from the table in a streaming manner: "media"
  """
  mediaStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [MediaStreamCursorInput]!,
    "filter the rows returned"
    where: MediaBoolExp
  ): [Media!]!
  """
  fetch data from the table: "organization"
  """
  organization(
    "distinct select on columns"
    distinctOn: [OrganizationSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [OrganizationOrderBy!],
    "filter the rows returned"
    where: OrganizationBoolExp
  ): [Organization!]!
  """
  fetch aggregated fields from the table: "organization"
  """
  organizationAggregate(
    "distinct select on columns"
    distinctOn: [OrganizationSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [OrganizationOrderBy!],
    "filter the rows returned"
    where: OrganizationBoolExp
  ): OrganizationAggregate!
  """
  fetch data from the table: "organization" using primary key columns
  """
  organizationByPk(
    "The unique identifier of the organization."
    id: uuid!
  ): Organization
  """
  fetch data from the table in a streaming manner: "organization"
  """
  organizationStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [OrganizationStreamCursorInput]!,
    "filter the rows returned"
    where: OrganizationBoolExp
  ): [Organization!]!
  """
  fetch data from the table: "phone"
  """
  phone(
    "distinct select on columns"
    distinctOn: [PhoneSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [PhoneOrderBy!],
    "filter the rows returned"
    where: PhoneBoolExp
  ): [Phone!]!
  """
  fetch aggregated fields from the table: "phone"
  """
  phoneAggregate(
    "distinct select on columns"
    distinctOn: [PhoneSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [PhoneOrderBy!],
    "filter the rows returned"
    where: PhoneBoolExp
  ): PhoneAggregate!
  """
  fetch data from the table: "phone" using primary key columns
  """
  phoneByPk(
    "The unique identifier of the contact phone."
    id: uuid!
  ): Phone
  """
  fetch data from the table in a streaming manner: "phone"
  """
  phoneStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [PhoneStreamCursorInput]!,
    "filter the rows returned"
    where: PhoneBoolExp
  ): [Phone!]!
  """
  fetch data from the table: "setting"
  """
  setting(
    "distinct select on columns"
    distinctOn: [SettingSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SettingOrderBy!],
    "filter the rows returned"
    where: SettingBoolExp
  ): [Setting!]!
  """
  fetch aggregated fields from the table: "setting"
  """
  settingAggregate(
    "distinct select on columns"
    distinctOn: [SettingSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SettingOrderBy!],
    "filter the rows returned"
    where: SettingBoolExp
  ): SettingAggregate!
  """
  fetch data from the table: "setting" using primary key columns
  """
  settingByPk(
    "The unique identifier of the setting."
    id: uuid!
  ): Setting
  """
  fetch data from the table in a streaming manner: "setting"
  """
  settingStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [SettingStreamCursorInput]!,
    "filter the rows returned"
    where: SettingBoolExp
  ): [Setting!]!
  """
  fetch data from the table: "showinfo"
  """
  showinfo(
    "distinct select on columns"
    distinctOn: [ShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ShowinfoOrderBy!],
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): [Showinfo!]!
  """
  fetch aggregated fields from the table: "showinfo"
  """
  showinfoAggregate(
    "distinct select on columns"
    distinctOn: [ShowinfoSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [ShowinfoOrderBy!],
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): ShowinfoAggregate!
  """
  fetch data from the table: "showinfo" using primary key columns
  """
  showinfoByPk(
    "The unique identifier of the showinfo."
    id: uuid!
  ): Showinfo
  """
  fetch data from the table in a streaming manner: "showinfo"
  """
  showinfoStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [ShowinfoStreamCursorInput]!,
    "filter the rows returned"
    where: ShowinfoBoolExp
  ): [Showinfo!]!
  """
  fetch data from the table: "sip"
  """
  sip(
    "distinct select on columns"
    distinctOn: [SipSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SipOrderBy!],
    "filter the rows returned"
    where: SipBoolExp
  ): [Sip!]!
  """
  fetch aggregated fields from the table: "sip"
  """
  sipAggregate(
    "distinct select on columns"
    distinctOn: [SipSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [SipOrderBy!],
    "filter the rows returned"
    where: SipBoolExp
  ): SipAggregate!
  """
  fetch data from the table: "sip" using primary key columns
  """
  sipByPk(
    "The unique identifier of the SIP line."
    id: uuid!
  ): Sip
  """
  fetch data from the table in a streaming manner: "sip"
  """
  sipStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [SipStreamCursorInput]!,
    "filter the rows returned"
    where: SipBoolExp
  ): [Sip!]!
  smartcodec: smartcodecSubscription
  """
  fetch data from the table: "studio"
  """
  studio(
    "distinct select on columns"
    distinctOn: [StudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [StudioOrderBy!],
    "filter the rows returned"
    where: StudioBoolExp
  ): [Studio!]!
  """
  fetch aggregated fields from the table: "studio"
  """
  studioAggregate(
    "distinct select on columns"
    distinctOn: [StudioSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [StudioOrderBy!],
    "filter the rows returned"
    where: StudioBoolExp
  ): StudioAggregate!
  """
  fetch data from the table: "studio" using primary key columns
  """
  studioByPk(
    "The unique identifier of the studio."
    id: uuid!
  ): Studio
  """
  fetch data from the table in a streaming manner: "studio"
  """
  studioStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [StudioStreamCursorInput]!,
    "filter the rows returned"
    where: StudioBoolExp
  ): [Studio!]!
  """
  fetch data from the table: "tag"
  """
  tag(
    "distinct select on columns"
    distinctOn: [TagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [TagOrderBy!],
    "filter the rows returned"
    where: TagBoolExp
  ): [Tag!]!
  """
  fetch aggregated fields from the table: "tag"
  """
  tagAggregate(
    "distinct select on columns"
    distinctOn: [TagSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [TagOrderBy!],
    "filter the rows returned"
    where: TagBoolExp
  ): TagAggregate!
  """
  fetch data from the table: "tag" using primary key columns
  """
  tagByPk(
    "The unique identifier of the tag."
    id: uuid!
  ): Tag
  """
  fetch data from the table in a streaming manner: "tag"
  """
  tagStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [TagStreamCursorInput]!,
    "filter the rows returned"
    where: TagBoolExp
  ): [Tag!]!
  """
  fetch data from the table: "user"
  """
  user(
    "distinct select on columns"
    distinctOn: [UserSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserOrderBy!],
    "filter the rows returned"
    where: UserBoolExp
  ): [User!]!
  """
  fetch aggregated fields from the table: "user"
  """
  userAggregate(
    "distinct select on columns"
    distinctOn: [UserSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserOrderBy!],
    "filter the rows returned"
    where: UserBoolExp
  ): UserAggregate!
  """
  fetch data from the table: "user" using primary key columns
  """
  userByPk(
    "The unique identifier of the user."
    id: uuid!
  ): User
  """
  fetch data from the table: "user_group"
  """
  userGroup(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): [UserGroup!]!
  """
  fetch aggregated fields from the table: "user_group"
  """
  userGroupAggregate(
    "distinct select on columns"
    distinctOn: [UserGroupSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [UserGroupOrderBy!],
    "filter the rows returned"
    where: UserGroupBoolExp
  ): UserGroupAggregate!
  """
  fetch data from the table: "user_group" using primary key columns
  """
  userGroupByPk(
    "The group of the user group."
    groupId: uuid!,
    "The user of the user group."
    userId: uuid!
  ): UserGroup
  """
  fetch data from the table in a streaming manner: "user_group"
  """
  userGroupStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [UserGroupStreamCursorInput]!,
    "filter the rows returned"
    where: UserGroupBoolExp
  ): [UserGroup!]!
  """
  fetch data from the table in a streaming manner: "user"
  """
  userStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [UserStreamCursorInput]!,
    "filter the rows returned"
    where: UserBoolExp
  ): [User!]!
  """
  fetch data from the table: "webrtc"
  """
  webrtc(
    "distinct select on columns"
    distinctOn: [WebrtcSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [WebrtcOrderBy!],
    "filter the rows returned"
    where: WebrtcBoolExp
  ): [Webrtc!]!
  """
  fetch aggregated fields from the table: "webrtc"
  """
  webrtcAggregate(
    "distinct select on columns"
    distinctOn: [WebrtcSelectColumn!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    orderBy: [WebrtcOrderBy!],
    "filter the rows returned"
    where: WebrtcBoolExp
  ): WebrtcAggregate!
  """
  fetch data from the table: "webrtc" using primary key columns
  """
  webrtcByPk(
    "The unique identifier of the WebRTC line."
    id: uuid!
  ): Webrtc
  """
  fetch data from the table in a streaming manner: "webrtc"
  """
  webrtcStream(
    "maximum number of rows returned in a single batch"
    batchSize: Int!,
    "cursor to stream the results returned by the query"
    cursor: [WebrtcStreamCursorInput]!,
    "filter the rows returned"
    where: WebrtcBoolExp
  ): [Webrtc!]!
}
union smartcodec_query_events_items = smartcodec_LineError | smartcodec_LineLevel | smartcodec_LineStatus
"""
unique or primary key constraints on table "action"
"""
enum ActionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  action_pkey
}
"""
select columns of table "action"
"""
enum ActionSelectColumn {
  "column name"
  command
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
}
"""
update columns of table "action"
"""
enum ActionUpdateColumn {
  "column name"
  command
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "address"
"""
enum AddressConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  address_pkey
}
"""
select columns of table "address"
"""
enum AddressSelectColumn {
  "column name"
  contactId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  validatedAt
  "column name"
  value
}
"""
update columns of table "address"
"""
enum AddressUpdateColumn {
  "column name"
  contactId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  validatedAt
  "column name"
  value
}
"""
unique or primary key constraints on table "button"
"""
enum ButtonConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  button_pkey
}
"""
select columns of table "button"
"""
enum ButtonSelectColumn {
  "column name"
  actionId
  "column name"
  colorOff
  "column name"
  colorOn
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  global
  "column name"
  icon
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  position
  "column name"
  show
  "column name"
  updatedAt
  "column name"
  url
}
"""
update columns of table "button"
"""
enum ButtonUpdateColumn {
  "column name"
  actionId
  "column name"
  colorOff
  "column name"
  colorOn
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  global
  "column name"
  icon
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  position
  "column name"
  show
  "column name"
  updatedAt
  "column name"
  url
}
"""
unique or primary key constraints on table "calendar"
"""
enum CalendarConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  calendar_pkey
}
"""
select columns of table "calendar"
"""
enum CalendarSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  updatedAt
}
"""
update columns of table "calendar"
"""
enum CalendarUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "card_button"
"""
enum CardButtonConstraint {
  """
  unique or primary key constraint on columns "card_id", "button_id"
  """
  card_button_pkey
}
"""
select columns of table "card_button"
"""
enum CardButtonSelectColumn {
  "column name"
  buttonId
  "column name"
  cardId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  updatedAt
}
"""
update columns of table "card_button"
"""
enum CardButtonUpdateColumn {
  "column name"
  buttonId
  "column name"
  cardId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "card"
"""
enum CardConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  card_pkey
}
"""
unique or primary key constraints on table "card_grid"
"""
enum CardGridConstraint {
  """
  unique or primary key constraint on columns "card_id", "grid_id"
  """
  card_grid_pkey
}
"""
select columns of table "card_grid"
"""
enum CardGridSelectColumn {
  "column name"
  cardId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  gridId
  "column name"
  position
  "column name"
  updatedAt
}
"""
update columns of table "card_grid"
"""
enum CardGridUpdateColumn {
  "column name"
  cardId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  gridId
  "column name"
  position
  "column name"
  updatedAt
}
"""
select columns of table "card"
"""
enum CardSelectColumn {
  "column name"
  backgroundColor
  "column name"
  borderColor
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  lineId
  "column name"
  name
  "column name"
  slotColor
  "column name"
  textColor
  "column name"
  type
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "card_tag"
"""
enum CardTagConstraint {
  """
  unique or primary key constraint on columns "tag_id", "card_id"
  """
  card_tag_pkey
}
"""
select columns of table "card_tag"
"""
enum CardTagSelectColumn {
  "column name"
  cardId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  tagId
  "column name"
  updatedAt
}
"""
update columns of table "card_tag"
"""
enum CardTagUpdateColumn {
  "column name"
  cardId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  tagId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "card_type"
"""
enum CardTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  card_type_pkey
  """
  unique or primary key constraint on columns "value"
  """
  card_type_unique
}
enum CardTypeEnum {
  "A line card"
  LINE
  "A void card"
  VOID
}
"""
select columns of table "card_type"
"""
enum CardTypeSelectColumn {
  "column name"
  comment
  "column name"
  value
}
"""
update columns of table "card_type"
"""
enum CardTypeUpdateColumn {
  "column name"
  comment
  "column name"
  value
}
"""
update columns of table "card"
"""
enum CardUpdateColumn {
  "column name"
  backgroundColor
  "column name"
  borderColor
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  lineId
  "column name"
  name
  "column name"
  slotColor
  "column name"
  textColor
  "column name"
  type
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "codec"
"""
enum CodecConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  codec_pkey
}
"""
select columns of table "codec"
"""
enum CodecSelectColumn {
  "column name"
  capabilities
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  smartcodecId
  "column name"
  updatedAt
}
"""
update columns of table "codec"
"""
enum CodecUpdateColumn {
  "column name"
  capabilities
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  smartcodecId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "contact"
"""
enum ContactConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  contact_pkey
}
"""
select columns of table "contact"
"""
enum ContactSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
  "column name"
  userId
}
"""
update columns of table "contact"
"""
enum ContactUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
  "column name"
  userId
}
"ordering argument of a cursor"
enum CursorOrdering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}
"""
unique or primary key constraints on table "device"
"""
enum DeviceConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  device_pkey
}
"""
select columns of table "device"
"""
enum DeviceSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
}
"""
update columns of table "device"
"""
enum DeviceUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "email"
"""
enum EmailConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  email_pkey
}
"""
select columns of table "email"
"""
enum EmailSelectColumn {
  "column name"
  contactId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  validatedAt
  "column name"
  value
}
"""
update columns of table "email"
"""
enum EmailUpdateColumn {
  "column name"
  contactId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  validatedAt
  "column name"
  value
}
"""
unique or primary key constraints on table "event"
"""
enum EventConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_pkey
}
"""
select columns of table "event"
"""
enum EventSelectColumn {
  "column name"
  allDay
  "column name"
  backgroundColor
  "column name"
  borderColor
  "column name"
  calendarId
  "column name"
  classNames
  "column name"
  constraint
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  display
  "column name"
  durationEditable
  "column name"
  editable
  "column name"
  end
  "column name"
  endStr
  "column name"
  extendedProps
  "column name"
  groupId
  "column name"
  id
  "column name"
  label
  "column name"
  lineId
  "column name"
  name
  "column name"
  overlap
  "column name"
  resourceEditable
  "column name"
  sourceId
  "column name"
  start
  "column name"
  startEditable
  "column name"
  startStr
  "column name"
  textColor
  "column name"
  title
  "column name"
  updatedAt
  "column name"
  url
}
"""
update columns of table "event"
"""
enum EventUpdateColumn {
  "column name"
  allDay
  "column name"
  backgroundColor
  "column name"
  borderColor
  "column name"
  calendarId
  "column name"
  classNames
  "column name"
  constraint
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  display
  "column name"
  durationEditable
  "column name"
  editable
  "column name"
  end
  "column name"
  endStr
  "column name"
  extendedProps
  "column name"
  groupId
  "column name"
  id
  "column name"
  label
  "column name"
  lineId
  "column name"
  name
  "column name"
  overlap
  "column name"
  resourceEditable
  "column name"
  sourceId
  "column name"
  start
  "column name"
  startEditable
  "column name"
  startStr
  "column name"
  textColor
  "column name"
  title
  "column name"
  updatedAt
  "column name"
  url
}
"""
unique or primary key constraints on table "grid"
"""
enum GridConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  grid_pkey
}
"""
select columns of table "grid"
"""
enum GridSelectColumn {
  "column name"
  cardBorderWidth
  "column name"
  column
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  horizontalScroll
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  position
  "column name"
  row
  "column name"
  slotPadding
  "column name"
  studioId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "grid_showinfo"
"""
enum GridShowinfoConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  grid_showinfo_pkey
}
"""
select columns of table "grid_showinfo"
"""
enum GridShowinfoSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  gridId
  "column name"
  id
  "column name"
  showinfoId
  "column name"
  updatedAt
}
"""
update columns of table "grid_showinfo"
"""
enum GridShowinfoUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  gridId
  "column name"
  id
  "column name"
  showinfoId
  "column name"
  updatedAt
}
"""
update columns of table "grid"
"""
enum GridUpdateColumn {
  "column name"
  cardBorderWidth
  "column name"
  column
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  horizontalScroll
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  position
  "column name"
  row
  "column name"
  slotPadding
  "column name"
  studioId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "group"
"""
enum GroupConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  group_pkey
}
"""
select columns of table "group"
"""
enum GroupSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  logo
  "column name"
  name
  "column name"
  organizationId
  "column name"
  parentId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "group_studio"
"""
enum GroupStudioConstraint {
  """
  unique or primary key constraint on columns "group_id", "studio_id"
  """
  group_studio_pkey
}
"""
select columns of table "group_studio"
"""
enum GroupStudioSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  groupId
  "column name"
  studioId
  "column name"
  updatedAt
}
"""
update columns of table "group_studio"
"""
enum GroupStudioUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  groupId
  "column name"
  studioId
  "column name"
  updatedAt
}
"""
update columns of table "group"
"""
enum GroupUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  logo
  "column name"
  name
  "column name"
  organizationId
  "column name"
  parentId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "line"
"""
enum LineConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  line_pkey
}
"""
select columns of table "line"
"""
enum LineSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  organizationId
  "column name"
  status
  "column name"
  type
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "line_studio"
"""
enum LineStudioConstraint {
  """
  unique or primary key constraint on columns "line_id", "studio_id"
  """
  line_studio_pkey
}
"""
select columns of table "line_studio"
"""
enum LineStudioSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  lineId
  "column name"
  studioId
  "column name"
  updatedAt
}
"""
update columns of table "line_studio"
"""
enum LineStudioUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  lineId
  "column name"
  studioId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "line_type"
"""
enum LineTypeConstraint {
  """
  unique or primary key constraint on columns "value"
  """
  line_type_pkey
}
enum LineTypeEnum {
  "Hardware codec line"
  CODEC
  "SIP line"
  SIP
  "WebRTC line"
  WEBRTC
}
"""
select columns of table "line_type"
"""
enum LineTypeSelectColumn {
  "column name"
  comment
  "column name"
  value
}
"""
update columns of table "line_type"
"""
enum LineTypeUpdateColumn {
  "column name"
  comment
  "column name"
  value
}
"""
update columns of table "line"
"""
enum LineUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  organizationId
  "column name"
  status
  "column name"
  type
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "media"
"""
enum MediaConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_pkey
}
"""
select columns of table "media"
"""
enum MediaSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
}
"""
update columns of table "media"
"""
enum MediaUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  type
  "column name"
  updatedAt
}
"column ordering options"
enum OrderBy {
  "in ascending order, nulls last"
  ASC
  "in ascending order, nulls first"
  ASC_NULLS_FIRST
  "in ascending order, nulls last"
  ASC_NULLS_LAST
  "in descending order, nulls first"
  DESC
  "in descending order, nulls first"
  DESC_NULLS_FIRST
  "in descending order, nulls last"
  DESC_NULLS_LAST
}
"""
unique or primary key constraints on table "organization"
"""
enum OrganizationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  organization_pkey
}
"""
select columns of table "organization"
"""
enum OrganizationSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  logo
  "column name"
  name
  "column name"
  updatedAt
}
"""
update columns of table "organization"
"""
enum OrganizationUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  logo
  "column name"
  name
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "phone"
"""
enum PhoneConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  phone_pkey
}
"""
select columns of table "phone"
"""
enum PhoneSelectColumn {
  "column name"
  contactId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  number
  "column name"
  updatedAt
  "column name"
  validatedAt
}
"""
update columns of table "phone"
"""
enum PhoneUpdateColumn {
  "column name"
  contactId
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  number
  "column name"
  updatedAt
  "column name"
  validatedAt
}
"""
unique or primary key constraints on table "setting"
"""
enum SettingConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  setting_pkey
}
"""
select columns of table "setting"
"""
enum SettingSelectColumn {
  "column name"
  createdAt
  "column name"
  darkMode
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  gridTabBottom
  "column name"
  id
  "column name"
  leftPanelWidth
  "column name"
  name
  "column name"
  padding
  "column name"
  panelTabBottom
  "column name"
  updatedAt
}
"""
update columns of table "setting"
"""
enum SettingUpdateColumn {
  "column name"
  createdAt
  "column name"
  darkMode
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  gridTabBottom
  "column name"
  id
  "column name"
  leftPanelWidth
  "column name"
  name
  "column name"
  padding
  "column name"
  panelTabBottom
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "showinfo"
"""
enum ShowinfoConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  showinfo_pkey
}
"""
select columns of table "showinfo"
"""
enum ShowinfoSelectColumn {
  "column name"
  align
  "column name"
  backgroundColor
  "column name"
  bold
  "column name"
  color
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  global
  "column name"
  gridId
  "column name"
  id
  "column name"
  name
  "column name"
  path
  "column name"
  position
  "column name"
  show
  "column name"
  size
  "column name"
  updatedAt
}
"""
update columns of table "showinfo"
"""
enum ShowinfoUpdateColumn {
  "column name"
  align
  "column name"
  backgroundColor
  "column name"
  bold
  "column name"
  color
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  global
  "column name"
  gridId
  "column name"
  id
  "column name"
  name
  "column name"
  path
  "column name"
  position
  "column name"
  show
  "column name"
  size
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "sip"
"""
enum SipConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  sip_pkey
}
"""
select columns of table "sip"
"""
enum SipSelectColumn {
  "column name"
  address
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  password
  "column name"
  updatedAt
  "column name"
  username
}
"""
update columns of table "sip"
"""
enum SipUpdateColumn {
  "column name"
  address
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  password
  "column name"
  updatedAt
  "column name"
  username
}
"""
unique or primary key constraints on table "studio"
"""
enum StudioConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  studio_pkey
}
"""
select columns of table "studio"
"""
enum StudioSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  logo
  "column name"
  name
  "column name"
  organizationId
  "column name"
  updatedAt
}
"""
update columns of table "studio"
"""
enum StudioUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  logo
  "column name"
  name
  "column name"
  organizationId
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "tag"
"""
enum TagConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  tag_pkey
}
"""
select columns of table "tag"
"""
enum TagSelectColumn {
  "column name"
  color
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  updatedAt
}
"""
update columns of table "tag"
"""
enum TagUpdateColumn {
  "column name"
  color
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  description
  "column name"
  id
  "column name"
  label
  "column name"
  name
  "column name"
  updatedAt
}
"""
unique or primary key constraints on table "user"
"""
enum UserConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}
"""
unique or primary key constraints on table "user_group"
"""
enum UserGroupConstraint {
  """
  unique or primary key constraint on columns "group_id", "user_id"
  """
  user_group_pkey
}
"""
select columns of table "user_group"
"""
enum UserGroupSelectColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  groupId
  "column name"
  updatedAt
  "column name"
  userId
}
"""
update columns of table "user_group"
"""
enum UserGroupUpdateColumn {
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  groupId
  "column name"
  updatedAt
  "column name"
  userId
}
"""
select columns of table "user"
"""
enum UserSelectColumn {
  "column name"
  beginDate
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  email
  "column name"
  endDate
  "column name"
  eulaAccepted
  "column name"
  firstName
  "column name"
  id
  "column name"
  lastName
  "column name"
  lastSeen
  "column name"
  organizationId
  "column name"
  password
  "column name"
  resetPassword
  "column name"
  updatedAt
  "column name"
  username
}
"""
update columns of table "user"
"""
enum UserUpdateColumn {
  "column name"
  beginDate
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  email
  "column name"
  endDate
  "column name"
  eulaAccepted
  "column name"
  firstName
  "column name"
  id
  "column name"
  lastName
  "column name"
  lastSeen
  "column name"
  organizationId
  "column name"
  password
  "column name"
  resetPassword
  "column name"
  updatedAt
  "column name"
  username
}
"""
unique or primary key constraints on table "webrtc"
"""
enum WebrtcConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  webrtc_pkey
}
"""
select columns of table "webrtc"
"""
enum WebrtcSelectColumn {
  "column name"
  audioPortRead
  "column name"
  audioPortWrite
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  video
  "column name"
  videoPortRead
  "column name"
  videoPortWrite
}
"""
update columns of table "webrtc"
"""
enum WebrtcUpdateColumn {
  "column name"
  audioPortRead
  "column name"
  audioPortWrite
  "column name"
  createdAt
  "column name"
  deletedAt
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  video
  "column name"
  videoPortRead
  "column name"
  videoPortWrite
}
"""
select "button_aggregate_bool_exp_bool_and_arguments_columns" columns of table "button"
"""
enum button_select_column_button_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  global
  "column name"
  show
}
"""
select "button_aggregate_bool_exp_bool_or_arguments_columns" columns of table "button"
"""
enum button_select_column_button_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  global
  "column name"
  show
}
"""
select "event_aggregate_bool_exp_bool_and_arguments_columns" columns of table "event"
"""
enum event_select_column_event_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  allDay
  "column name"
  constraint
  "column name"
  durationEditable
  "column name"
  editable
  "column name"
  overlap
  "column name"
  resourceEditable
  "column name"
  startEditable
}
"""
select "event_aggregate_bool_exp_bool_or_arguments_columns" columns of table "event"
"""
enum event_select_column_event_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  allDay
  "column name"
  constraint
  "column name"
  durationEditable
  "column name"
  editable
  "column name"
  overlap
  "column name"
  resourceEditable
  "column name"
  startEditable
}
"""
select "grid_aggregate_bool_exp_bool_and_arguments_columns" columns of table "grid"
"""
enum grid_select_column_grid_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  horizontalScroll
}
"""
select "grid_aggregate_bool_exp_bool_or_arguments_columns" columns of table "grid"
"""
enum grid_select_column_grid_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  horizontalScroll
}
"""
select "showinfo_aggregate_bool_exp_bool_and_arguments_columns" columns of table "showinfo"
"""
enum showinfo_select_column_showinfo_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  bold
  "column name"
  global
  "column name"
  show
}
"""
select "showinfo_aggregate_bool_exp_bool_or_arguments_columns" columns of table "showinfo"
"""
enum showinfo_select_column_showinfo_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  bold
  "column name"
  global
  "column name"
  show
}
"The direction of the call"
enum smartcodec_query_lines_items_status_status_direction {
  idle
  incoming
  outgoing
}
"The state of the line"
enum smartcodec_query_lines_items_status_status_state {
  busy
  connected
  out_of_order
  ready
  unavailable
}
"""
select "user_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user"
"""
enum user_select_column_user_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  eulaAccepted
  "column name"
  resetPassword
}
"""
select "user_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user"
"""
enum user_select_column_user_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  eulaAccepted
  "column name"
  resetPassword
}
"""
Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
"""
input ActionBoolExp {
  _and: [ActionBoolExp!]
  _not: ActionBoolExp
  _or: [ActionBoolExp!]
  buttons: ButtonBoolExp
  buttons_aggregate: button_aggregate_bool_exp
  command: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  type: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "action"
"""
input ActionInsertInput {
  buttons: ButtonArrRelInsertInput
  "The command of the action."
  command: String
  "The date and time when the action was created."
  createdAt: timestamptz
  "The date and time when the action was deleted."
  deletedAt: timestamptz
  "The description of the action."
  description: String
  "The unique identifier of the action."
  id: uuid
  "The label of the action is used to override the name in the UI."
  label: String
  "The name of the action."
  name: String
  "The type of the action."
  type: String
  "The date and time when the action was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "action"
"""
input ActionObjRelInsertInput {
  data: ActionInsertInput!
  "upsert condition"
  onConflict: ActionOnConflict
}
"""
on_conflict condition type for table "action"
"""
input ActionOnConflict {
  constraint: ActionConstraint!
  update_columns: [ActionUpdateColumn!]! = []
  where: ActionBoolExp
}
"""
Ordering options when selecting data from "action".
"""
input ActionOrderBy {
  buttonsAggregate: ButtonAggregateOrderBy
  command: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: action"
input ActionPkColumnsInput {
  "The unique identifier of the action."
  id: uuid!
}
"""
input type for updating data in table "action"
"""
input ActionSetInput {
  "The command of the action."
  command: String
  "The date and time when the action was created."
  createdAt: timestamptz
  "The date and time when the action was deleted."
  deletedAt: timestamptz
  "The description of the action."
  description: String
  "The unique identifier of the action."
  id: uuid
  "The label of the action is used to override the name in the UI."
  label: String
  "The name of the action."
  name: String
  "The type of the action."
  type: String
  "The date and time when the action was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "action"
"""
input ActionStreamCursorInput {
  "Stream column input with initial value"
  initialValue: ActionStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input ActionStreamCursorValueInput {
  "The command of the action."
  command: String
  "The date and time when the action was created."
  createdAt: timestamptz
  "The date and time when the action was deleted."
  deletedAt: timestamptz
  "The description of the action."
  description: String
  "The unique identifier of the action."
  id: uuid
  "The label of the action is used to override the name in the UI."
  label: String
  "The name of the action."
  name: String
  "The type of the action."
  type: String
  "The date and time when the action was last updated."
  updatedAt: timestamptz
}
input ActionUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: ActionSetInput
  where: ActionBoolExp!
}
"""
order by aggregate values of table "address"
"""
input AddressAggregateOrderBy {
  count: OrderBy
  max: address_max_order_by
  min: address_min_order_by
}
"""
input type for inserting array relation for remote table "address"
"""
input AddressArrRelInsertInput {
  data: [AddressInsertInput!]!
  "upsert condition"
  onConflict: AddressOnConflict
}
"""
Boolean expression to filter rows from the table "address". All fields are combined with a logical 'AND'.
"""
input AddressBoolExp {
  _and: [AddressBoolExp!]
  _not: AddressBoolExp
  _or: [AddressBoolExp!]
  contact: ContactBoolExp
  contactId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  validatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}
"""
input type for inserting data into table "address"
"""
input AddressInsertInput {
  contact: ContactObjRelInsertInput
  "The contact that the address belongs to."
  contactId: uuid
  "The date and time when the address was created."
  createdAt: timestamptz
  "The date and time when the address was deleted."
  deletedAt: timestamptz
  "The unique identifier of the address."
  id: uuid
  "The date and time when the address was last updated."
  updatedAt: timestamptz
  "The date and time when the address was validated."
  validatedAt: timestamptz
  "The text value of the address."
  value: String
}
"""
on_conflict condition type for table "address"
"""
input AddressOnConflict {
  constraint: AddressConstraint!
  update_columns: [AddressUpdateColumn!]! = []
  where: AddressBoolExp
}
"""
Ordering options when selecting data from "address".
"""
input AddressOrderBy {
  contact: ContactOrderBy
  contactId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  updatedAt: OrderBy
  validatedAt: OrderBy
  value: OrderBy
}
"primary key columns input for table: address"
input AddressPkColumnsInput {
  "The unique identifier of the address."
  id: uuid!
}
"""
input type for updating data in table "address"
"""
input AddressSetInput {
  "The contact that the address belongs to."
  contactId: uuid
  "The date and time when the address was created."
  createdAt: timestamptz
  "The date and time when the address was deleted."
  deletedAt: timestamptz
  "The unique identifier of the address."
  id: uuid
  "The date and time when the address was last updated."
  updatedAt: timestamptz
  "The date and time when the address was validated."
  validatedAt: timestamptz
  "The text value of the address."
  value: String
}
"""
Streaming cursor of the table "address"
"""
input AddressStreamCursorInput {
  "Stream column input with initial value"
  initialValue: AddressStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input AddressStreamCursorValueInput {
  "The contact that the address belongs to."
  contactId: uuid
  "The date and time when the address was created."
  createdAt: timestamptz
  "The date and time when the address was deleted."
  deletedAt: timestamptz
  "The unique identifier of the address."
  id: uuid
  "The date and time when the address was last updated."
  updatedAt: timestamptz
  "The date and time when the address was validated."
  validatedAt: timestamptz
  "The text value of the address."
  value: String
}
input AddressUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: AddressSetInput
  where: AddressBoolExp!
}
"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}
"""
order by aggregate values of table "button"
"""
input ButtonAggregateOrderBy {
  avg: button_avg_order_by
  count: OrderBy
  max: button_max_order_by
  min: button_min_order_by
  stddev: button_stddev_order_by
  stddev_pop: button_stddev_pop_order_by
  stddev_samp: button_stddev_samp_order_by
  sum: button_sum_order_by
  var_pop: button_var_pop_order_by
  var_samp: button_var_samp_order_by
  variance: button_variance_order_by
}
"""
input type for inserting array relation for remote table "button"
"""
input ButtonArrRelInsertInput {
  data: [ButtonInsertInput!]!
  "upsert condition"
  onConflict: ButtonOnConflict
}
"""
Boolean expression to filter rows from the table "button". All fields are combined with a logical 'AND'.
"""
input ButtonBoolExp {
  _and: [ButtonBoolExp!]
  _not: ButtonBoolExp
  _or: [ButtonBoolExp!]
  action: ActionBoolExp
  actionId: UuidComparisonExp
  card_buttons: CardButtonBoolExp
  card_buttons_aggregate: card_button_aggregate_bool_exp
  colorOff: CitextComparisonExp
  colorOn: CitextComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  global: BooleanComparisonExp
  icon: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  position: IntComparisonExp
  show: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
  url: StringComparisonExp
}
"""
input type for incrementing numeric columns in table "button"
"""
input ButtonIncInput {
  "The position of the button."
  position: Int
}
"""
input type for inserting data into table "button"
"""
input ButtonInsertInput {
  action: ActionObjRelInsertInput
  "The action that the button triggers."
  actionId: uuid
  card_buttons: CardButtonArrRelInsertInput
  "The color of the button when it is off."
  colorOff: citext
  "The color of the button when it is on."
  colorOn: citext
  "The date and time when the button was created."
  createdAt: timestamptz
  "The date and time when the button was deleted."
  deletedAt: timestamptz
  "The description of the button."
  description: String
  "Whether the button is global."
  global: Boolean
  "The icon of the button."
  icon: String
  "The unique identifier of the button."
  id: uuid
  "The label of the button is used to override the name in the UI."
  label: String
  "The name of the button."
  name: String
  "The position of the button."
  position: Int
  show: Boolean
  "The date and time when the button was last updated."
  updatedAt: timestamptz
  "The url of the button."
  url: String
}
"""
input type for inserting object relation for remote table "button"
"""
input ButtonObjRelInsertInput {
  data: ButtonInsertInput!
  "upsert condition"
  onConflict: ButtonOnConflict
}
"""
on_conflict condition type for table "button"
"""
input ButtonOnConflict {
  constraint: ButtonConstraint!
  update_columns: [ButtonUpdateColumn!]! = []
  where: ButtonBoolExp
}
"""
Ordering options when selecting data from "button".
"""
input ButtonOrderBy {
  action: ActionOrderBy
  actionId: OrderBy
  card_buttonsAggregate: CardButtonAggregateOrderBy
  colorOff: OrderBy
  colorOn: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  global: OrderBy
  icon: OrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  position: OrderBy
  show: OrderBy
  updatedAt: OrderBy
  url: OrderBy
}
"primary key columns input for table: button"
input ButtonPkColumnsInput {
  "The unique identifier of the button."
  id: uuid!
}
"""
input type for updating data in table "button"
"""
input ButtonSetInput {
  "The action that the button triggers."
  actionId: uuid
  "The color of the button when it is off."
  colorOff: citext
  "The color of the button when it is on."
  colorOn: citext
  "The date and time when the button was created."
  createdAt: timestamptz
  "The date and time when the button was deleted."
  deletedAt: timestamptz
  "The description of the button."
  description: String
  "Whether the button is global."
  global: Boolean
  "The icon of the button."
  icon: String
  "The unique identifier of the button."
  id: uuid
  "The label of the button is used to override the name in the UI."
  label: String
  "The name of the button."
  name: String
  "The position of the button."
  position: Int
  show: Boolean
  "The date and time when the button was last updated."
  updatedAt: timestamptz
  "The url of the button."
  url: String
}
"""
Streaming cursor of the table "button"
"""
input ButtonStreamCursorInput {
  "Stream column input with initial value"
  initialValue: ButtonStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input ButtonStreamCursorValueInput {
  "The action that the button triggers."
  actionId: uuid
  "The color of the button when it is off."
  colorOff: citext
  "The color of the button when it is on."
  colorOn: citext
  "The date and time when the button was created."
  createdAt: timestamptz
  "The date and time when the button was deleted."
  deletedAt: timestamptz
  "The description of the button."
  description: String
  "Whether the button is global."
  global: Boolean
  "The icon of the button."
  icon: String
  "The unique identifier of the button."
  id: uuid
  "The label of the button is used to override the name in the UI."
  label: String
  "The name of the button."
  name: String
  "The position of the button."
  position: Int
  show: Boolean
  "The date and time when the button was last updated."
  updatedAt: timestamptz
  "The url of the button."
  url: String
}
input ButtonUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: ButtonIncInput
  "sets the columns of the filtered rows to the given values"
  _set: ButtonSetInput
  where: ButtonBoolExp!
}
"""
Boolean expression to filter rows from the table "calendar". All fields are combined with a logical 'AND'.
"""
input CalendarBoolExp {
  _and: [CalendarBoolExp!]
  _not: CalendarBoolExp
  _or: [CalendarBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  events: EventBoolExp
  events_aggregate: event_aggregate_bool_exp
  id: UuidComparisonExp
  label: StringComparisonExp
  line: LineBoolExp
  name: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "calendar"
"""
input CalendarInsertInput {
  "The date and time when the calendar was created."
  createdAt: timestamptz
  "The date and time when the calendar was deleted."
  deletedAt: timestamptz
  "The description of the calendar."
  description: String
  events: EventArrRelInsertInput
  "The unique identifier of the calendar."
  id: uuid
  "The label of the calendar is used to override the name in the UI."
  label: String
  line: LineObjRelInsertInput
  "The name of the calendar."
  name: String
  "The date and time when the calendar was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "calendar"
"""
input CalendarObjRelInsertInput {
  data: CalendarInsertInput!
  "upsert condition"
  onConflict: CalendarOnConflict
}
"""
on_conflict condition type for table "calendar"
"""
input CalendarOnConflict {
  constraint: CalendarConstraint!
  update_columns: [CalendarUpdateColumn!]! = []
  where: CalendarBoolExp
}
"""
Ordering options when selecting data from "calendar".
"""
input CalendarOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventsAggregate: EventAggregateOrderBy
  id: OrderBy
  label: OrderBy
  line: LineOrderBy
  name: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: calendar"
input CalendarPkColumnsInput {
  "The unique identifier of the calendar."
  id: uuid!
}
"""
input type for updating data in table "calendar"
"""
input CalendarSetInput {
  "The date and time when the calendar was created."
  createdAt: timestamptz
  "The date and time when the calendar was deleted."
  deletedAt: timestamptz
  "The description of the calendar."
  description: String
  "The unique identifier of the calendar."
  id: uuid
  "The label of the calendar is used to override the name in the UI."
  label: String
  "The name of the calendar."
  name: String
  "The date and time when the calendar was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "calendar"
"""
input CalendarStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CalendarStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CalendarStreamCursorValueInput {
  "The date and time when the calendar was created."
  createdAt: timestamptz
  "The date and time when the calendar was deleted."
  deletedAt: timestamptz
  "The description of the calendar."
  description: String
  "The unique identifier of the calendar."
  id: uuid
  "The label of the calendar is used to override the name in the UI."
  label: String
  "The name of the calendar."
  name: String
  "The date and time when the calendar was last updated."
  updatedAt: timestamptz
}
input CalendarUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: CalendarSetInput
  where: CalendarBoolExp!
}
"""
order by aggregate values of table "card"
"""
input CardAggregateOrderBy {
  count: OrderBy
  max: card_max_order_by
  min: card_min_order_by
}
"""
input type for inserting array relation for remote table "card"
"""
input CardArrRelInsertInput {
  data: [CardInsertInput!]!
  "upsert condition"
  onConflict: CardOnConflict
}
"""
Boolean expression to filter rows from the table "card". All fields are combined with a logical 'AND'.
"""
input CardBoolExp {
  _and: [CardBoolExp!]
  _not: CardBoolExp
  _or: [CardBoolExp!]
  backgroundColor: CitextComparisonExp
  borderColor: CitextComparisonExp
  card_buttons: CardButtonBoolExp
  card_buttons_aggregate: card_button_aggregate_bool_exp
  card_grids: CardGridBoolExp
  card_grids_aggregate: card_grid_aggregate_bool_exp
  card_tags: CardTagBoolExp
  card_tags_aggregate: card_tag_aggregate_bool_exp
  card_type: CardTypeBoolExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  line: LineBoolExp
  lineId: UuidComparisonExp
  name: StringComparisonExp
  slotColor: CitextComparisonExp
  textColor: CitextComparisonExp
  type: CardTypeEnumComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
order by aggregate values of table "card_button"
"""
input CardButtonAggregateOrderBy {
  count: OrderBy
  max: card_button_max_order_by
  min: card_button_min_order_by
}
"""
input type for inserting array relation for remote table "card_button"
"""
input CardButtonArrRelInsertInput {
  data: [CardButtonInsertInput!]!
  "upsert condition"
  onConflict: CardButtonOnConflict
}
"""
Boolean expression to filter rows from the table "card_button". All fields are combined with a logical 'AND'.
"""
input CardButtonBoolExp {
  _and: [CardButtonBoolExp!]
  _not: CardButtonBoolExp
  _or: [CardButtonBoolExp!]
  button: ButtonBoolExp
  buttonId: UuidComparisonExp
  card: CardBoolExp
  cardId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "card_button"
"""
input CardButtonInsertInput {
  button: ButtonObjRelInsertInput
  buttonId: uuid
  card: CardObjRelInsertInput
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "card_button"
"""
input CardButtonOnConflict {
  constraint: CardButtonConstraint!
  update_columns: [CardButtonUpdateColumn!]! = []
  where: CardButtonBoolExp
}
"""
Ordering options when selecting data from "card_button".
"""
input CardButtonOrderBy {
  button: ButtonOrderBy
  buttonId: OrderBy
  card: CardOrderBy
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: card_button"
input CardButtonPkColumnsInput {
  buttonId: uuid!
  cardId: uuid!
}
"""
input type for updating data in table "card_button"
"""
input CardButtonSetInput {
  buttonId: uuid
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "card_button"
"""
input CardButtonStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CardButtonStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CardButtonStreamCursorValueInput {
  buttonId: uuid
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  updatedAt: timestamptz
}
input CardButtonUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: CardButtonSetInput
  where: CardButtonBoolExp!
}
"""
order by aggregate values of table "card_grid"
"""
input CardGridAggregateOrderBy {
  avg: card_grid_avg_order_by
  count: OrderBy
  max: card_grid_max_order_by
  min: card_grid_min_order_by
  stddev: card_grid_stddev_order_by
  stddev_pop: card_grid_stddev_pop_order_by
  stddev_samp: card_grid_stddev_samp_order_by
  sum: card_grid_sum_order_by
  var_pop: card_grid_var_pop_order_by
  var_samp: card_grid_var_samp_order_by
  variance: card_grid_variance_order_by
}
"""
input type for inserting array relation for remote table "card_grid"
"""
input CardGridArrRelInsertInput {
  data: [CardGridInsertInput!]!
  "upsert condition"
  onConflict: CardGridOnConflict
}
"""
Boolean expression to filter rows from the table "card_grid". All fields are combined with a logical 'AND'.
"""
input CardGridBoolExp {
  _and: [CardGridBoolExp!]
  _not: CardGridBoolExp
  _or: [CardGridBoolExp!]
  card: CardBoolExp
  cardId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  grid: GridBoolExp
  gridId: UuidComparisonExp
  position: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for incrementing numeric columns in table "card_grid"
"""
input CardGridIncInput {
  "The position of the card in the grid."
  position: Int
}
"""
input type for inserting data into table "card_grid"
"""
input CardGridInsertInput {
  card: CardObjRelInsertInput
  "The card that is in the grid."
  cardId: uuid
  "The date and time when the card grid was created."
  createdAt: timestamptz
  "The date and time when the card grid was deleted."
  deletedAt: timestamptz
  grid: GridObjRelInsertInput
  "The grid that the card is in."
  gridId: uuid
  "The position of the card in the grid."
  position: Int
  "The date and time when the card grid was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "card_grid"
"""
input CardGridOnConflict {
  constraint: CardGridConstraint!
  update_columns: [CardGridUpdateColumn!]! = []
  where: CardGridBoolExp
}
"""
Ordering options when selecting data from "card_grid".
"""
input CardGridOrderBy {
  card: CardOrderBy
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  grid: GridOrderBy
  gridId: OrderBy
  position: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: card_grid"
input CardGridPkColumnsInput {
  "The card that is in the grid."
  cardId: uuid!
  "The grid that the card is in."
  gridId: uuid!
}
"""
input type for updating data in table "card_grid"
"""
input CardGridSetInput {
  "The card that is in the grid."
  cardId: uuid
  "The date and time when the card grid was created."
  createdAt: timestamptz
  "The date and time when the card grid was deleted."
  deletedAt: timestamptz
  "The grid that the card is in."
  gridId: uuid
  "The position of the card in the grid."
  position: Int
  "The date and time when the card grid was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "card_grid"
"""
input CardGridStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CardGridStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CardGridStreamCursorValueInput {
  "The card that is in the grid."
  cardId: uuid
  "The date and time when the card grid was created."
  createdAt: timestamptz
  "The date and time when the card grid was deleted."
  deletedAt: timestamptz
  "The grid that the card is in."
  gridId: uuid
  "The position of the card in the grid."
  position: Int
  "The date and time when the card grid was last updated."
  updatedAt: timestamptz
}
input CardGridUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: CardGridIncInput
  "sets the columns of the filtered rows to the given values"
  _set: CardGridSetInput
  where: CardGridBoolExp!
}
"""
input type for inserting data into table "card"
"""
input CardInsertInput {
  "The background color of the card."
  backgroundColor: citext
  "The border color of the card."
  borderColor: citext
  card_buttons: CardButtonArrRelInsertInput
  card_grids: CardGridArrRelInsertInput
  card_tags: CardTagArrRelInsertInput
  card_type: CardTypeObjRelInsertInput
  "The date and time when the card was created."
  createdAt: timestamptz
  "The date and time when the card was deleted."
  deletedAt: timestamptz
  "The description of the card."
  description: String
  "The unique identifier of the card."
  id: uuid
  "The label of the card is used to override the name in the UI."
  label: String
  line: LineObjRelInsertInput
  "The line that the card is associated with."
  lineId: uuid
  "The name of the card."
  name: String
  "The slot color of the card."
  slotColor: citext
  "The text color of the card."
  textColor: citext
  "The type of the card."
  type: CardTypeEnum
  "The date and time when the card was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "card"
"""
input CardObjRelInsertInput {
  data: CardInsertInput!
  "upsert condition"
  onConflict: CardOnConflict
}
"""
on_conflict condition type for table "card"
"""
input CardOnConflict {
  constraint: CardConstraint!
  update_columns: [CardUpdateColumn!]! = []
  where: CardBoolExp
}
"""
Ordering options when selecting data from "card".
"""
input CardOrderBy {
  backgroundColor: OrderBy
  borderColor: OrderBy
  card_buttonsAggregate: CardButtonAggregateOrderBy
  card_gridsAggregate: CardGridAggregateOrderBy
  card_tagsAggregate: CardTagAggregateOrderBy
  card_type: CardTypeOrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  id: OrderBy
  label: OrderBy
  line: LineOrderBy
  lineId: OrderBy
  name: OrderBy
  slotColor: OrderBy
  textColor: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: card"
input CardPkColumnsInput {
  "The unique identifier of the card."
  id: uuid!
}
"""
input type for updating data in table "card"
"""
input CardSetInput {
  "The background color of the card."
  backgroundColor: citext
  "The border color of the card."
  borderColor: citext
  "The date and time when the card was created."
  createdAt: timestamptz
  "The date and time when the card was deleted."
  deletedAt: timestamptz
  "The description of the card."
  description: String
  "The unique identifier of the card."
  id: uuid
  "The label of the card is used to override the name in the UI."
  label: String
  "The line that the card is associated with."
  lineId: uuid
  "The name of the card."
  name: String
  "The slot color of the card."
  slotColor: citext
  "The text color of the card."
  textColor: citext
  "The type of the card."
  type: CardTypeEnum
  "The date and time when the card was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "card"
"""
input CardStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CardStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CardStreamCursorValueInput {
  "The background color of the card."
  backgroundColor: citext
  "The border color of the card."
  borderColor: citext
  "The date and time when the card was created."
  createdAt: timestamptz
  "The date and time when the card was deleted."
  deletedAt: timestamptz
  "The description of the card."
  description: String
  "The unique identifier of the card."
  id: uuid
  "The label of the card is used to override the name in the UI."
  label: String
  "The line that the card is associated with."
  lineId: uuid
  "The name of the card."
  name: String
  "The slot color of the card."
  slotColor: citext
  "The text color of the card."
  textColor: citext
  "The type of the card."
  type: CardTypeEnum
  "The date and time when the card was last updated."
  updatedAt: timestamptz
}
"""
order by aggregate values of table "card_tag"
"""
input CardTagAggregateOrderBy {
  count: OrderBy
  max: card_tag_max_order_by
  min: card_tag_min_order_by
}
"""
input type for inserting array relation for remote table "card_tag"
"""
input CardTagArrRelInsertInput {
  data: [CardTagInsertInput!]!
  "upsert condition"
  onConflict: CardTagOnConflict
}
"""
Boolean expression to filter rows from the table "card_tag". All fields are combined with a logical 'AND'.
"""
input CardTagBoolExp {
  _and: [CardTagBoolExp!]
  _not: CardTagBoolExp
  _or: [CardTagBoolExp!]
  card: CardBoolExp
  cardId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  tag: TagBoolExp
  tagId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "card_tag"
"""
input CardTagInsertInput {
  card: CardObjRelInsertInput
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  tag: TagObjRelInsertInput
  tagId: uuid
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "card_tag"
"""
input CardTagOnConflict {
  constraint: CardTagConstraint!
  update_columns: [CardTagUpdateColumn!]! = []
  where: CardTagBoolExp
}
"""
Ordering options when selecting data from "card_tag".
"""
input CardTagOrderBy {
  card: CardOrderBy
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  tag: TagOrderBy
  tagId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: card_tag"
input CardTagPkColumnsInput {
  cardId: uuid!
  tagId: uuid!
}
"""
input type for updating data in table "card_tag"
"""
input CardTagSetInput {
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  tagId: uuid
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "card_tag"
"""
input CardTagStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CardTagStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CardTagStreamCursorValueInput {
  cardId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  tagId: uuid
  updatedAt: timestamptz
}
input CardTagUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: CardTagSetInput
  where: CardTagBoolExp!
}
"""
Boolean expression to filter rows from the table "card_type". All fields are combined with a logical 'AND'.
"""
input CardTypeBoolExp {
  _and: [CardTypeBoolExp!]
  _not: CardTypeBoolExp
  _or: [CardTypeBoolExp!]
  cards: CardBoolExp
  cards_aggregate: card_aggregate_bool_exp
  comment: StringComparisonExp
  value: StringComparisonExp
}
"""
Boolean expression to compare columns of type "CardTypeEnum". All fields are combined with logical 'AND'.
"""
input CardTypeEnumComparisonExp {
  _eq: CardTypeEnum
  _in: [CardTypeEnum!]
  _isNull: Boolean
  _neq: CardTypeEnum
  _nin: [CardTypeEnum!]
}
"""
input type for inserting data into table "card_type"
"""
input CardTypeInsertInput {
  cards: CardArrRelInsertInput
  "The comment of the card type."
  comment: String
  "The value of the card type."
  value: String
}
"""
input type for inserting object relation for remote table "card_type"
"""
input CardTypeObjRelInsertInput {
  data: CardTypeInsertInput!
  "upsert condition"
  onConflict: CardTypeOnConflict
}
"""
on_conflict condition type for table "card_type"
"""
input CardTypeOnConflict {
  constraint: CardTypeConstraint!
  update_columns: [CardTypeUpdateColumn!]! = []
  where: CardTypeBoolExp
}
"""
Ordering options when selecting data from "card_type".
"""
input CardTypeOrderBy {
  cardsAggregate: CardAggregateOrderBy
  comment: OrderBy
  value: OrderBy
}
"primary key columns input for table: card_type"
input CardTypePkColumnsInput {
  "The value of the card type."
  value: String!
}
"""
input type for updating data in table "card_type"
"""
input CardTypeSetInput {
  "The comment of the card type."
  comment: String
  "The value of the card type."
  value: String
}
"""
Streaming cursor of the table "card_type"
"""
input CardTypeStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CardTypeStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CardTypeStreamCursorValueInput {
  "The comment of the card type."
  comment: String
  "The value of the card type."
  value: String
}
input CardTypeUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: CardTypeSetInput
  where: CardTypeBoolExp!
}
input CardUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: CardSetInput
  where: CardBoolExp!
}
"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input CitextComparisonExp {
  _eq: citext
  _gt: citext
  _gte: citext
  "does the column match the given case-insensitive pattern"
  _ilike: citext
  _in: [citext!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: citext
  _isNull: Boolean
  "does the column match the given pattern"
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext
  "does the column NOT match the given case-insensitive pattern"
  _nilike: citext
  _nin: [citext!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: citext
  "does the column NOT match the given pattern"
  _nlike: citext
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: citext
  "does the column NOT match the given SQL regular expression"
  _nsimilar: citext
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: citext
  "does the column match the given SQL regular expression"
  _similar: citext
}
"""
Boolean expression to filter rows from the table "codec". All fields are combined with a logical 'AND'.
"""
input CodecBoolExp {
  _and: [CodecBoolExp!]
  _not: CodecBoolExp
  _or: [CodecBoolExp!]
  capabilities: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  line: LineBoolExp
  smartcodecId: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for incrementing numeric columns in table "codec"
"""
input CodecIncInput {
  "The smartcodec id of the codec."
  smartcodecId: Int
}
"""
input type for inserting data into table "codec"
"""
input CodecInsertInput {
  "The capabilities of the codec."
  capabilities: String
  "The date and time when the codec was created."
  createdAt: timestamptz
  "The date and time when the codec was deleted."
  deletedAt: timestamptz
  "The unique identifier of the codec."
  id: uuid
  line: LineObjRelInsertInput
  "The smartcodec id of the codec."
  smartcodecId: Int
  "The date and time when the codec was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "codec"
"""
input CodecObjRelInsertInput {
  data: CodecInsertInput!
  "upsert condition"
  onConflict: CodecOnConflict
}
"""
on_conflict condition type for table "codec"
"""
input CodecOnConflict {
  constraint: CodecConstraint!
  update_columns: [CodecUpdateColumn!]! = []
  where: CodecBoolExp
}
"""
Ordering options when selecting data from "codec".
"""
input CodecOrderBy {
  capabilities: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  line: LineOrderBy
  smartcodecId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: codec"
input CodecPkColumnsInput {
  "The unique identifier of the codec."
  id: uuid!
}
"""
input type for updating data in table "codec"
"""
input CodecSetInput {
  "The capabilities of the codec."
  capabilities: String
  "The date and time when the codec was created."
  createdAt: timestamptz
  "The date and time when the codec was deleted."
  deletedAt: timestamptz
  "The unique identifier of the codec."
  id: uuid
  "The smartcodec id of the codec."
  smartcodecId: Int
  "The date and time when the codec was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "codec"
"""
input CodecStreamCursorInput {
  "Stream column input with initial value"
  initialValue: CodecStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input CodecStreamCursorValueInput {
  "The capabilities of the codec."
  capabilities: String
  "The date and time when the codec was created."
  createdAt: timestamptz
  "The date and time when the codec was deleted."
  deletedAt: timestamptz
  "The unique identifier of the codec."
  id: uuid
  "The smartcodec id of the codec."
  smartcodecId: Int
  "The date and time when the codec was last updated."
  updatedAt: timestamptz
}
input CodecUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: CodecIncInput
  "sets the columns of the filtered rows to the given values"
  _set: CodecSetInput
  where: CodecBoolExp!
}
"""
Boolean expression to filter rows from the table "contact". All fields are combined with a logical 'AND'.
"""
input ContactBoolExp {
  _and: [ContactBoolExp!]
  _not: ContactBoolExp
  _or: [ContactBoolExp!]
  addresses: AddressBoolExp
  addresses_aggregate: address_aggregate_bool_exp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  emails: EmailBoolExp
  emails_aggregate: email_aggregate_bool_exp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  phones: PhoneBoolExp
  phones_aggregate: phone_aggregate_bool_exp
  type: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  userId: UuidComparisonExp
}
"""
input type for inserting data into table "contact"
"""
input ContactInsertInput {
  addresses: AddressArrRelInsertInput
  "The date and time when the contact was created."
  createdAt: timestamptz
  "The date and time when the contact was deleted."
  deletedAt: timestamptz
  "The description of the contact."
  description: String
  emails: EmailArrRelInsertInput
  "The unique identifier of the contact."
  id: uuid
  "The label of the contact is used to override the name in the UI."
  label: String
  "The name of the contact."
  name: String
  phones: PhoneArrRelInsertInput
  "The type of the contact."
  type: String
  "The date and time when the contact was last updated."
  updatedAt: timestamptz
  "The user that the contact belongs to."
  userId: uuid
}
"""
input type for inserting object relation for remote table "contact"
"""
input ContactObjRelInsertInput {
  data: ContactInsertInput!
  "upsert condition"
  onConflict: ContactOnConflict
}
"""
on_conflict condition type for table "contact"
"""
input ContactOnConflict {
  constraint: ContactConstraint!
  update_columns: [ContactUpdateColumn!]! = []
  where: ContactBoolExp
}
"""
Ordering options when selecting data from "contact".
"""
input ContactOrderBy {
  addressesAggregate: AddressAggregateOrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  emailsAggregate: EmailAggregateOrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  phonesAggregate: PhoneAggregateOrderBy
  type: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}
"primary key columns input for table: contact"
input ContactPkColumnsInput {
  "The unique identifier of the contact."
  id: uuid!
}
"""
input type for updating data in table "contact"
"""
input ContactSetInput {
  "The date and time when the contact was created."
  createdAt: timestamptz
  "The date and time when the contact was deleted."
  deletedAt: timestamptz
  "The description of the contact."
  description: String
  "The unique identifier of the contact."
  id: uuid
  "The label of the contact is used to override the name in the UI."
  label: String
  "The name of the contact."
  name: String
  "The type of the contact."
  type: String
  "The date and time when the contact was last updated."
  updatedAt: timestamptz
  "The user that the contact belongs to."
  userId: uuid
}
"""
Streaming cursor of the table "contact"
"""
input ContactStreamCursorInput {
  "Stream column input with initial value"
  initialValue: ContactStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input ContactStreamCursorValueInput {
  "The date and time when the contact was created."
  createdAt: timestamptz
  "The date and time when the contact was deleted."
  deletedAt: timestamptz
  "The description of the contact."
  description: String
  "The unique identifier of the contact."
  id: uuid
  "The label of the contact is used to override the name in the UI."
  label: String
  "The name of the contact."
  name: String
  "The type of the contact."
  type: String
  "The date and time when the contact was last updated."
  updatedAt: timestamptz
  "The user that the contact belongs to."
  userId: uuid
}
input ContactUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: ContactSetInput
  where: ContactBoolExp!
}
"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}
"""
Boolean expression to filter rows from the table "device". All fields are combined with a logical 'AND'.
"""
input DeviceBoolExp {
  _and: [DeviceBoolExp!]
  _not: DeviceBoolExp
  _or: [DeviceBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  type: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "device"
"""
input DeviceInsertInput {
  "The date and time when the device was created."
  createdAt: timestamptz
  "The date and time when the device was deleted."
  deletedAt: timestamptz
  "The description of the device."
  description: String
  "The unique identifier of the device."
  id: uuid
  "The label of the device is used to override the name in the UI."
  label: String
  "The name of the device."
  name: String
  "The type of the device."
  type: String
  "The date and time when the device was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "device"
"""
input DeviceOnConflict {
  constraint: DeviceConstraint!
  update_columns: [DeviceUpdateColumn!]! = []
  where: DeviceBoolExp
}
"""
Ordering options when selecting data from "device".
"""
input DeviceOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: device"
input DevicePkColumnsInput {
  "The unique identifier of the device."
  id: uuid!
}
"""
input type for updating data in table "device"
"""
input DeviceSetInput {
  "The date and time when the device was created."
  createdAt: timestamptz
  "The date and time when the device was deleted."
  deletedAt: timestamptz
  "The description of the device."
  description: String
  "The unique identifier of the device."
  id: uuid
  "The label of the device is used to override the name in the UI."
  label: String
  "The name of the device."
  name: String
  "The type of the device."
  type: String
  "The date and time when the device was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "device"
"""
input DeviceStreamCursorInput {
  "Stream column input with initial value"
  initialValue: DeviceStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input DeviceStreamCursorValueInput {
  "The date and time when the device was created."
  createdAt: timestamptz
  "The date and time when the device was deleted."
  deletedAt: timestamptz
  "The description of the device."
  description: String
  "The unique identifier of the device."
  id: uuid
  "The label of the device is used to override the name in the UI."
  label: String
  "The name of the device."
  name: String
  "The type of the device."
  type: String
  "The date and time when the device was last updated."
  updatedAt: timestamptz
}
input DeviceUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: DeviceSetInput
  where: DeviceBoolExp!
}
"""
order by aggregate values of table "email"
"""
input EmailAggregateOrderBy {
  count: OrderBy
  max: email_max_order_by
  min: email_min_order_by
}
"""
input type for inserting array relation for remote table "email"
"""
input EmailArrRelInsertInput {
  data: [EmailInsertInput!]!
  "upsert condition"
  onConflict: EmailOnConflict
}
"""
Boolean expression to filter rows from the table "email". All fields are combined with a logical 'AND'.
"""
input EmailBoolExp {
  _and: [EmailBoolExp!]
  _not: EmailBoolExp
  _or: [EmailBoolExp!]
  contact: ContactBoolExp
  contactId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  validatedAt: TimestamptzComparisonExp
  value: CitextComparisonExp
}
"""
input type for inserting data into table "email"
"""
input EmailInsertInput {
  contact: ContactObjRelInsertInput
  "The contact that the email belongs to."
  contactId: uuid
  "The date and time when the email was created."
  createdAt: timestamptz
  "The date and time when the email was deleted."
  deletedAt: timestamptz
  "The unique identifier of the email."
  id: uuid
  "The date and time when the email was last updated."
  updatedAt: timestamptz
  "The date and time when the email was validated."
  validatedAt: timestamptz
  "The email address of the email."
  value: citext
}
"""
on_conflict condition type for table "email"
"""
input EmailOnConflict {
  constraint: EmailConstraint!
  update_columns: [EmailUpdateColumn!]! = []
  where: EmailBoolExp
}
"""
Ordering options when selecting data from "email".
"""
input EmailOrderBy {
  contact: ContactOrderBy
  contactId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  updatedAt: OrderBy
  validatedAt: OrderBy
  value: OrderBy
}
"primary key columns input for table: email"
input EmailPkColumnsInput {
  "The unique identifier of the email."
  id: uuid!
}
"""
input type for updating data in table "email"
"""
input EmailSetInput {
  "The contact that the email belongs to."
  contactId: uuid
  "The date and time when the email was created."
  createdAt: timestamptz
  "The date and time when the email was deleted."
  deletedAt: timestamptz
  "The unique identifier of the email."
  id: uuid
  "The date and time when the email was last updated."
  updatedAt: timestamptz
  "The date and time when the email was validated."
  validatedAt: timestamptz
  "The email address of the email."
  value: citext
}
"""
Streaming cursor of the table "email"
"""
input EmailStreamCursorInput {
  "Stream column input with initial value"
  initialValue: EmailStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input EmailStreamCursorValueInput {
  "The contact that the email belongs to."
  contactId: uuid
  "The date and time when the email was created."
  createdAt: timestamptz
  "The date and time when the email was deleted."
  deletedAt: timestamptz
  "The unique identifier of the email."
  id: uuid
  "The date and time when the email was last updated."
  updatedAt: timestamptz
  "The date and time when the email was validated."
  validatedAt: timestamptz
  "The email address of the email."
  value: citext
}
input EmailUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: EmailSetInput
  where: EmailBoolExp!
}
"""
order by aggregate values of table "event"
"""
input EventAggregateOrderBy {
  count: OrderBy
  max: event_max_order_by
  min: event_min_order_by
}
"append existing jsonb value of filtered columns with new jsonb value"
input EventAppendInput {
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: jsonb
}
"""
input type for inserting array relation for remote table "event"
"""
input EventArrRelInsertInput {
  data: [EventInsertInput!]!
  "upsert condition"
  onConflict: EventOnConflict
}
"""
Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
"""
input EventBoolExp {
  _and: [EventBoolExp!]
  _not: EventBoolExp
  _or: [EventBoolExp!]
  allDay: BooleanComparisonExp
  backgroundColor: CitextComparisonExp
  borderColor: CitextComparisonExp
  calendar: CalendarBoolExp
  calendarId: UuidComparisonExp
  classNames: StringComparisonExp
  constraint: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  display: StringComparisonExp
  durationEditable: BooleanComparisonExp
  editable: BooleanComparisonExp
  end: TimestamptzComparisonExp
  endStr: StringComparisonExp
  event: EventBoolExp
  events: EventBoolExp
  events_aggregate: event_aggregate_bool_exp
  extendedProps: JsonbComparisonExp
  groupId: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  line: LineBoolExp
  lineId: UuidComparisonExp
  name: StringComparisonExp
  overlap: BooleanComparisonExp
  resourceEditable: BooleanComparisonExp
  sourceId: UuidComparisonExp
  start: TimestamptzComparisonExp
  startEditable: BooleanComparisonExp
  startStr: StringComparisonExp
  textColor: CitextComparisonExp
  title: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  url: StringComparisonExp
}
"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input EventDeleteAtPathInput {
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: [String!]
}
"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input EventDeleteElemInput {
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: Int
}
"delete key/value pair or string element. key/value pairs are matched based on their key value"
input EventDeleteKeyInput {
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: String
}
"""
input type for inserting data into table "event"
"""
input EventInsertInput {
  "Determines if the event is shown in the “all-day” section of relevant views. In addition, if true the time text is not displayed with the event."
  allDay: Boolean
  "The eventBackgroundColor override for this specific event."
  backgroundColor: citext
  "The eventBorderColor override for this specific event."
  borderColor: citext
  calendar: CalendarObjRelInsertInput
  calendarId: uuid
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: String
  "The eventConstraint override for this specific event."
  constraint: Boolean
  "The date and time when the event was created."
  createdAt: timestamptz
  "The date and time when the event was deleted."
  deletedAt: timestamptz
  "The description of the event."
  description: String
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: String
  "The value overriding the eventDurationEditable setting for this specific event."
  durationEditable: Boolean
  "The value overriding the editable setting for this specific event."
  editable: Boolean
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: timestamptz
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: String
  event: EventObjRelInsertInput
  events: EventArrRelInsertInput
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: jsonb
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: String
  "The unique identifier of the event."
  id: uuid
  "The label of the event is used to override the name in the UI."
  label: String
  line: LineObjRelInsertInput
  "A reference to the line this calendar is linked to"
  lineId: uuid
  "The name of the event."
  name: String
  "The value overriding the eventOverlap setting for this specific event. If false, prevents this event from being dragged/resized over other events. Also prevents other events from being dragged/resized over this event. Does not accept a function."
  overlap: Boolean
  "The value overriding the eventResourceEditable setting for this specific event."
  resourceEditable: Boolean
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: uuid
  "Date object that obeys the current timeZone. When an event begins."
  start: timestamptz
  "The value overriding the eventStartEditable setting for this specific event."
  startEditable: Boolean
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: String
  "The eventTextColor override for this specific event."
  textColor: citext
  "The text that will appear on an event."
  title: String
  "The date and time when the event was last updated."
  updatedAt: timestamptz
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: String
}
"""
input type for inserting object relation for remote table "event"
"""
input EventObjRelInsertInput {
  data: EventInsertInput!
  "upsert condition"
  onConflict: EventOnConflict
}
"""
on_conflict condition type for table "event"
"""
input EventOnConflict {
  constraint: EventConstraint!
  update_columns: [EventUpdateColumn!]! = []
  where: EventBoolExp
}
"""
Ordering options when selecting data from "event".
"""
input EventOrderBy {
  allDay: OrderBy
  backgroundColor: OrderBy
  borderColor: OrderBy
  calendar: CalendarOrderBy
  calendarId: OrderBy
  classNames: OrderBy
  constraint: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  display: OrderBy
  durationEditable: OrderBy
  editable: OrderBy
  end: OrderBy
  endStr: OrderBy
  event: EventOrderBy
  eventsAggregate: EventAggregateOrderBy
  extendedProps: OrderBy
  groupId: OrderBy
  id: OrderBy
  label: OrderBy
  line: LineOrderBy
  lineId: OrderBy
  name: OrderBy
  overlap: OrderBy
  resourceEditable: OrderBy
  sourceId: OrderBy
  start: OrderBy
  startEditable: OrderBy
  startStr: OrderBy
  textColor: OrderBy
  title: OrderBy
  updatedAt: OrderBy
  url: OrderBy
}
"primary key columns input for table: event"
input EventPkColumnsInput {
  "The unique identifier of the event."
  id: uuid!
}
"prepend existing jsonb value of filtered columns with new jsonb value"
input EventPrependInput {
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: jsonb
}
"""
input type for updating data in table "event"
"""
input EventSetInput {
  "Determines if the event is shown in the “all-day” section of relevant views. In addition, if true the time text is not displayed with the event."
  allDay: Boolean
  "The eventBackgroundColor override for this specific event."
  backgroundColor: citext
  "The eventBorderColor override for this specific event."
  borderColor: citext
  calendarId: uuid
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: String
  "The eventConstraint override for this specific event."
  constraint: Boolean
  "The date and time when the event was created."
  createdAt: timestamptz
  "The date and time when the event was deleted."
  deletedAt: timestamptz
  "The description of the event."
  description: String
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: String
  "The value overriding the eventDurationEditable setting for this specific event."
  durationEditable: Boolean
  "The value overriding the editable setting for this specific event."
  editable: Boolean
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: timestamptz
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: String
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: jsonb
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: String
  "The unique identifier of the event."
  id: uuid
  "The label of the event is used to override the name in the UI."
  label: String
  "A reference to the line this calendar is linked to"
  lineId: uuid
  "The name of the event."
  name: String
  "The value overriding the eventOverlap setting for this specific event. If false, prevents this event from being dragged/resized over other events. Also prevents other events from being dragged/resized over this event. Does not accept a function."
  overlap: Boolean
  "The value overriding the eventResourceEditable setting for this specific event."
  resourceEditable: Boolean
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: uuid
  "Date object that obeys the current timeZone. When an event begins."
  start: timestamptz
  "The value overriding the eventStartEditable setting for this specific event."
  startEditable: Boolean
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: String
  "The eventTextColor override for this specific event."
  textColor: citext
  "The text that will appear on an event."
  title: String
  "The date and time when the event was last updated."
  updatedAt: timestamptz
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: String
}
"""
Streaming cursor of the table "event"
"""
input EventStreamCursorInput {
  "Stream column input with initial value"
  initialValue: EventStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input EventStreamCursorValueInput {
  "Determines if the event is shown in the “all-day” section of relevant views. In addition, if true the time text is not displayed with the event."
  allDay: Boolean
  "The eventBackgroundColor override for this specific event."
  backgroundColor: citext
  "The eventBorderColor override for this specific event."
  borderColor: citext
  calendarId: uuid
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: String
  "The eventConstraint override for this specific event."
  constraint: Boolean
  "The date and time when the event was created."
  createdAt: timestamptz
  "The date and time when the event was deleted."
  deletedAt: timestamptz
  "The description of the event."
  description: String
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: String
  "The value overriding the eventDurationEditable setting for this specific event."
  durationEditable: Boolean
  "The value overriding the editable setting for this specific event."
  editable: Boolean
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: timestamptz
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: String
  "A plain object holding miscellaneous other properties specified during parsing. Receives properties in the explicitly given extendedProps hash as well as other non-standard properties."
  extendedProps: jsonb
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: String
  "The unique identifier of the event."
  id: uuid
  "The label of the event is used to override the name in the UI."
  label: String
  "A reference to the line this calendar is linked to"
  lineId: uuid
  "The name of the event."
  name: String
  "The value overriding the eventOverlap setting for this specific event. If false, prevents this event from being dragged/resized over other events. Also prevents other events from being dragged/resized over this event. Does not accept a function."
  overlap: Boolean
  "The value overriding the eventResourceEditable setting for this specific event."
  resourceEditable: Boolean
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: uuid
  "Date object that obeys the current timeZone. When an event begins."
  start: timestamptz
  "The value overriding the eventStartEditable setting for this specific event."
  startEditable: Boolean
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: String
  "The eventTextColor override for this specific event."
  textColor: citext
  "The text that will appear on an event."
  title: String
  "The date and time when the event was last updated."
  updatedAt: timestamptz
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: String
}
input EventUpdates {
  "append existing jsonb value of filtered columns with new jsonb value"
  _append: EventAppendInput
  "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
  _deleteAtPath: EventDeleteAtPathInput
  "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
  _deleteElem: EventDeleteElemInput
  "delete key/value pair or string element. key/value pairs are matched based on their key value"
  _deleteKey: EventDeleteKeyInput
  "prepend existing jsonb value of filtered columns with new jsonb value"
  _prepend: EventPrependInput
  "sets the columns of the filtered rows to the given values"
  _set: EventSetInput
  where: EventBoolExp!
}
"""
order by aggregate values of table "grid"
"""
input GridAggregateOrderBy {
  avg: grid_avg_order_by
  count: OrderBy
  max: grid_max_order_by
  min: grid_min_order_by
  stddev: grid_stddev_order_by
  stddev_pop: grid_stddev_pop_order_by
  stddev_samp: grid_stddev_samp_order_by
  sum: grid_sum_order_by
  var_pop: grid_var_pop_order_by
  var_samp: grid_var_samp_order_by
  variance: grid_variance_order_by
}
"""
input type for inserting array relation for remote table "grid"
"""
input GridArrRelInsertInput {
  data: [GridInsertInput!]!
  "upsert condition"
  onConflict: GridOnConflict
}
"""
Boolean expression to filter rows from the table "grid". All fields are combined with a logical 'AND'.
"""
input GridBoolExp {
  _and: [GridBoolExp!]
  _not: GridBoolExp
  _or: [GridBoolExp!]
  cardBorderWidth: IntComparisonExp
  card_grids: CardGridBoolExp
  card_grids_aggregate: card_grid_aggregate_bool_exp
  column: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  grid_showinfos: GridShowinfoBoolExp
  grid_showinfos_aggregate: grid_showinfo_aggregate_bool_exp
  horizontalScroll: BooleanComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  position: IntComparisonExp
  row: IntComparisonExp
  showinfos: ShowinfoBoolExp
  showinfos_aggregate: showinfo_aggregate_bool_exp
  slotPadding: IntComparisonExp
  studio: StudioBoolExp
  studioId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for incrementing numeric columns in table "grid"
"""
input GridIncInput {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  "The number of columns in the grid."
  column: Int
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  "The padding of the grid slots."
  slotPadding: Int
}
"""
input type for inserting data into table "grid"
"""
input GridInsertInput {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  card_grids: CardGridArrRelInsertInput
  "The number of columns in the grid."
  column: Int
  "The date and time when the grid was created."
  createdAt: timestamptz
  "The date and time when the grid was deleted."
  deletedAt: timestamptz
  "The description of the grid."
  description: String
  grid_showinfos: GridShowinfoArrRelInsertInput
  "Whether the grid has horizontal scroll."
  horizontalScroll: Boolean
  "The unique identifier of the grid."
  id: uuid
  "The label of the grid is used to override the name in the UI."
  label: String
  "The name of the grid."
  name: String
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  showinfos: ShowinfoArrRelInsertInput
  "The padding of the grid slots."
  slotPadding: Int
  studio: StudioObjRelInsertInput
  "The studio that the grid belongs to."
  studioId: uuid
  "The date and time when the grid was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "grid"
"""
input GridObjRelInsertInput {
  data: GridInsertInput!
  "upsert condition"
  onConflict: GridOnConflict
}
"""
on_conflict condition type for table "grid"
"""
input GridOnConflict {
  constraint: GridConstraint!
  update_columns: [GridUpdateColumn!]! = []
  where: GridBoolExp
}
"""
Ordering options when selecting data from "grid".
"""
input GridOrderBy {
  cardBorderWidth: OrderBy
  card_gridsAggregate: CardGridAggregateOrderBy
  column: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  grid_showinfosAggregate: GridShowinfoAggregateOrderBy
  horizontalScroll: OrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  position: OrderBy
  row: OrderBy
  showinfosAggregate: ShowinfoAggregateOrderBy
  slotPadding: OrderBy
  studio: StudioOrderBy
  studioId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: grid"
input GridPkColumnsInput {
  "The unique identifier of the grid."
  id: uuid!
}
"""
input type for updating data in table "grid"
"""
input GridSetInput {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  "The number of columns in the grid."
  column: Int
  "The date and time when the grid was created."
  createdAt: timestamptz
  "The date and time when the grid was deleted."
  deletedAt: timestamptz
  "The description of the grid."
  description: String
  "Whether the grid has horizontal scroll."
  horizontalScroll: Boolean
  "The unique identifier of the grid."
  id: uuid
  "The label of the grid is used to override the name in the UI."
  label: String
  "The name of the grid."
  name: String
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  "The padding of the grid slots."
  slotPadding: Int
  "The studio that the grid belongs to."
  studioId: uuid
  "The date and time when the grid was last updated."
  updatedAt: timestamptz
}
"""
order by aggregate values of table "grid_showinfo"
"""
input GridShowinfoAggregateOrderBy {
  count: OrderBy
  max: grid_showinfo_max_order_by
  min: grid_showinfo_min_order_by
}
"""
input type for inserting array relation for remote table "grid_showinfo"
"""
input GridShowinfoArrRelInsertInput {
  data: [GridShowinfoInsertInput!]!
  "upsert condition"
  onConflict: GridShowinfoOnConflict
}
"""
Boolean expression to filter rows from the table "grid_showinfo". All fields are combined with a logical 'AND'.
"""
input GridShowinfoBoolExp {
  _and: [GridShowinfoBoolExp!]
  _not: GridShowinfoBoolExp
  _or: [GridShowinfoBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  grid: GridBoolExp
  gridId: UuidComparisonExp
  id: UuidComparisonExp
  showinfo: ShowinfoBoolExp
  showinfoId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "grid_showinfo"
"""
input GridShowinfoInsertInput {
  "The date and time when the grid_showinfo was created."
  createdAt: timestamptz
  "The date and time when the grid_showinfo was deleted."
  deletedAt: timestamptz
  grid: GridObjRelInsertInput
  "The grid this grid_showinfo is linked to."
  gridId: uuid
  "The unique identifier of the grid_showinfo."
  id: uuid
  showinfo: ShowinfoObjRelInsertInput
  "The showinfo this grid_showinfo is linked to."
  showinfoId: uuid
  "The date and time when the grid_showinfo was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "grid_showinfo"
"""
input GridShowinfoOnConflict {
  constraint: GridShowinfoConstraint!
  update_columns: [GridShowinfoUpdateColumn!]! = []
  where: GridShowinfoBoolExp
}
"""
Ordering options when selecting data from "grid_showinfo".
"""
input GridShowinfoOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  grid: GridOrderBy
  gridId: OrderBy
  id: OrderBy
  showinfo: ShowinfoOrderBy
  showinfoId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: grid_showinfo"
input GridShowinfoPkColumnsInput {
  "The unique identifier of the grid_showinfo."
  id: uuid!
}
"""
input type for updating data in table "grid_showinfo"
"""
input GridShowinfoSetInput {
  "The date and time when the grid_showinfo was created."
  createdAt: timestamptz
  "The date and time when the grid_showinfo was deleted."
  deletedAt: timestamptz
  "The grid this grid_showinfo is linked to."
  gridId: uuid
  "The unique identifier of the grid_showinfo."
  id: uuid
  "The showinfo this grid_showinfo is linked to."
  showinfoId: uuid
  "The date and time when the grid_showinfo was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "grid_showinfo"
"""
input GridShowinfoStreamCursorInput {
  "Stream column input with initial value"
  initialValue: GridShowinfoStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input GridShowinfoStreamCursorValueInput {
  "The date and time when the grid_showinfo was created."
  createdAt: timestamptz
  "The date and time when the grid_showinfo was deleted."
  deletedAt: timestamptz
  "The grid this grid_showinfo is linked to."
  gridId: uuid
  "The unique identifier of the grid_showinfo."
  id: uuid
  "The showinfo this grid_showinfo is linked to."
  showinfoId: uuid
  "The date and time when the grid_showinfo was last updated."
  updatedAt: timestamptz
}
input GridShowinfoUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: GridShowinfoSetInput
  where: GridShowinfoBoolExp!
}
"""
Streaming cursor of the table "grid"
"""
input GridStreamCursorInput {
  "Stream column input with initial value"
  initialValue: GridStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input GridStreamCursorValueInput {
  "The border width of the cards in the grid."
  cardBorderWidth: Int
  "The number of columns in the grid."
  column: Int
  "The date and time when the grid was created."
  createdAt: timestamptz
  "The date and time when the grid was deleted."
  deletedAt: timestamptz
  "The description of the grid."
  description: String
  "Whether the grid has horizontal scroll."
  horizontalScroll: Boolean
  "The unique identifier of the grid."
  id: uuid
  "The label of the grid is used to override the name in the UI."
  label: String
  "The name of the grid."
  name: String
  "The position of the grid in the ui."
  position: Int
  "The number of rows in the grid."
  row: Int
  "The padding of the grid slots."
  slotPadding: Int
  "The studio that the grid belongs to."
  studioId: uuid
  "The date and time when the grid was last updated."
  updatedAt: timestamptz
}
input GridUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: GridIncInput
  "sets the columns of the filtered rows to the given values"
  _set: GridSetInput
  where: GridBoolExp!
}
"""
order by aggregate values of table "group"
"""
input GroupAggregateOrderBy {
  count: OrderBy
  max: group_max_order_by
  min: group_min_order_by
}
"""
input type for inserting array relation for remote table "group"
"""
input GroupArrRelInsertInput {
  data: [GroupInsertInput!]!
  "upsert condition"
  onConflict: GroupOnConflict
}
"""
Boolean expression to filter rows from the table "group". All fields are combined with a logical 'AND'.
"""
input GroupBoolExp {
  _and: [GroupBoolExp!]
  _not: GroupBoolExp
  _or: [GroupBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  group: GroupBoolExp
  group_studios: GroupStudioBoolExp
  group_studios_aggregate: group_studio_aggregate_bool_exp
  groups: GroupBoolExp
  groups_aggregate: group_aggregate_bool_exp
  id: UuidComparisonExp
  label: StringComparisonExp
  logo: StringComparisonExp
  name: StringComparisonExp
  organization: OrganizationBoolExp
  organizationId: UuidComparisonExp
  parentId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  user_groups: UserGroupBoolExp
  user_groups_aggregate: user_group_aggregate_bool_exp
}
"""
input type for inserting data into table "group"
"""
input GroupInsertInput {
  "The date and time when the group was created."
  createdAt: timestamptz
  "The date and time when the group was deleted."
  deletedAt: timestamptz
  "The description of the group."
  description: String
  group: GroupObjRelInsertInput
  group_studios: GroupStudioArrRelInsertInput
  groups: GroupArrRelInsertInput
  "The unique identifier of the group."
  id: uuid
  "The label of the group is used to override the name in the UI."
  label: String
  "The logo image path of the group."
  logo: String
  "The name of the group."
  name: String
  organization: OrganizationObjRelInsertInput
  "The organization id of the group."
  organizationId: uuid
  "The parent group of the group."
  parentId: uuid
  "The date and time when the group was last updated."
  updatedAt: timestamptz
  user_groups: UserGroupArrRelInsertInput
}
"""
input type for inserting object relation for remote table "group"
"""
input GroupObjRelInsertInput {
  data: GroupInsertInput!
  "upsert condition"
  onConflict: GroupOnConflict
}
"""
on_conflict condition type for table "group"
"""
input GroupOnConflict {
  constraint: GroupConstraint!
  update_columns: [GroupUpdateColumn!]! = []
  where: GroupBoolExp
}
"""
Ordering options when selecting data from "group".
"""
input GroupOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  group: GroupOrderBy
  group_studiosAggregate: GroupStudioAggregateOrderBy
  groupsAggregate: GroupAggregateOrderBy
  id: OrderBy
  label: OrderBy
  logo: OrderBy
  name: OrderBy
  organization: OrganizationOrderBy
  organizationId: OrderBy
  parentId: OrderBy
  updatedAt: OrderBy
  user_groupsAggregate: UserGroupAggregateOrderBy
}
"primary key columns input for table: group"
input GroupPkColumnsInput {
  "The unique identifier of the group."
  id: uuid!
}
"""
input type for updating data in table "group"
"""
input GroupSetInput {
  "The date and time when the group was created."
  createdAt: timestamptz
  "The date and time when the group was deleted."
  deletedAt: timestamptz
  "The description of the group."
  description: String
  "The unique identifier of the group."
  id: uuid
  "The label of the group is used to override the name in the UI."
  label: String
  "The logo image path of the group."
  logo: String
  "The name of the group."
  name: String
  "The organization id of the group."
  organizationId: uuid
  "The parent group of the group."
  parentId: uuid
  "The date and time when the group was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "group"
"""
input GroupStreamCursorInput {
  "Stream column input with initial value"
  initialValue: GroupStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input GroupStreamCursorValueInput {
  "The date and time when the group was created."
  createdAt: timestamptz
  "The date and time when the group was deleted."
  deletedAt: timestamptz
  "The description of the group."
  description: String
  "The unique identifier of the group."
  id: uuid
  "The label of the group is used to override the name in the UI."
  label: String
  "The logo image path of the group."
  logo: String
  "The name of the group."
  name: String
  "The organization id of the group."
  organizationId: uuid
  "The parent group of the group."
  parentId: uuid
  "The date and time when the group was last updated."
  updatedAt: timestamptz
}
"""
order by aggregate values of table "group_studio"
"""
input GroupStudioAggregateOrderBy {
  count: OrderBy
  max: group_studio_max_order_by
  min: group_studio_min_order_by
}
"""
input type for inserting array relation for remote table "group_studio"
"""
input GroupStudioArrRelInsertInput {
  data: [GroupStudioInsertInput!]!
  "upsert condition"
  onConflict: GroupStudioOnConflict
}
"""
Boolean expression to filter rows from the table "group_studio". All fields are combined with a logical 'AND'.
"""
input GroupStudioBoolExp {
  _and: [GroupStudioBoolExp!]
  _not: GroupStudioBoolExp
  _or: [GroupStudioBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  group: GroupBoolExp
  groupId: UuidComparisonExp
  studio: StudioBoolExp
  studioId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "group_studio"
"""
input GroupStudioInsertInput {
  "The date and time when the group studio was created."
  createdAt: timestamptz
  "The date and time when the group studio was deleted."
  deletedAt: timestamptz
  group: GroupObjRelInsertInput
  "The group of the group studio."
  groupId: uuid
  studio: StudioObjRelInsertInput
  "The studio of the group studio."
  studioId: uuid
  "The date and time when the group studio was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "group_studio"
"""
input GroupStudioOnConflict {
  constraint: GroupStudioConstraint!
  update_columns: [GroupStudioUpdateColumn!]! = []
  where: GroupStudioBoolExp
}
"""
Ordering options when selecting data from "group_studio".
"""
input GroupStudioOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  group: GroupOrderBy
  groupId: OrderBy
  studio: StudioOrderBy
  studioId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: group_studio"
input GroupStudioPkColumnsInput {
  "The group of the group studio."
  groupId: uuid!
  "The studio of the group studio."
  studioId: uuid!
}
"""
input type for updating data in table "group_studio"
"""
input GroupStudioSetInput {
  "The date and time when the group studio was created."
  createdAt: timestamptz
  "The date and time when the group studio was deleted."
  deletedAt: timestamptz
  "The group of the group studio."
  groupId: uuid
  "The studio of the group studio."
  studioId: uuid
  "The date and time when the group studio was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "group_studio"
"""
input GroupStudioStreamCursorInput {
  "Stream column input with initial value"
  initialValue: GroupStudioStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input GroupStudioStreamCursorValueInput {
  "The date and time when the group studio was created."
  createdAt: timestamptz
  "The date and time when the group studio was deleted."
  deletedAt: timestamptz
  "The group of the group studio."
  groupId: uuid
  "The studio of the group studio."
  studioId: uuid
  "The date and time when the group studio was last updated."
  updatedAt: timestamptz
}
input GroupStudioUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: GroupStudioSetInput
  where: GroupStudioBoolExp!
}
input GroupUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: GroupSetInput
  where: GroupBoolExp!
}
"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}
input JsonbCastExp {
  String: StringComparisonExp
}
"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp
  "is the column contained in the given json value"
  _containedIn: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _hasKey: String
  "do all of these strings exist as top-level keys in the column"
  _hasKeysAll: [String!]
  "do any of these strings exist as top-level keys in the column"
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}
"""
order by aggregate values of table "line"
"""
input LineAggregateOrderBy {
  count: OrderBy
  max: line_max_order_by
  min: line_min_order_by
}
"""
input type for inserting array relation for remote table "line"
"""
input LineArrRelInsertInput {
  data: [LineInsertInput!]!
  "upsert condition"
  onConflict: LineOnConflict
}
"""
Boolean expression to filter rows from the table "line". All fields are combined with a logical 'AND'.
"""
input LineBoolExp {
  _and: [LineBoolExp!]
  _not: LineBoolExp
  _or: [LineBoolExp!]
  calendar: CalendarBoolExp
  cardsByLineId: CardBoolExp
  cardsByLineId_aggregate: card_aggregate_bool_exp
  codec: CodecBoolExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  events: EventBoolExp
  events_aggregate: event_aggregate_bool_exp
  id: UuidComparisonExp
  label: StringComparisonExp
  line_studios: LineStudioBoolExp
  line_studios_aggregate: line_studio_aggregate_bool_exp
  line_type: LineTypeBoolExp
  name: StringComparisonExp
  organization: OrganizationBoolExp
  organizationId: UuidComparisonExp
  sip: SipBoolExp
  status: StringComparisonExp
  type: LineTypeEnumComparisonExp
  updatedAt: TimestamptzComparisonExp
  webrtc: WebrtcBoolExp
}
"""
input type for inserting data into table "line"
"""
input LineInsertInput {
  calendar: CalendarObjRelInsertInput
  cardsByLineId: CardArrRelInsertInput
  codec: CodecObjRelInsertInput
  "The date and time when the line was created."
  createdAt: timestamptz
  "The date and time when the line was deleted."
  deletedAt: timestamptz
  "The description of the line."
  description: String
  events: EventArrRelInsertInput
  "The unique identifier of the line."
  id: uuid
  "The label of the line is used to override the name in the UI."
  label: String
  line_studios: LineStudioArrRelInsertInput
  line_type: LineTypeObjRelInsertInput
  "The name of the line."
  name: String
  organization: OrganizationObjRelInsertInput
  organizationId: uuid
  sip: SipObjRelInsertInput
  "The status of the line."
  status: String
  "The type of the line."
  type: LineTypeEnum
  "The date and time when the line was last updated."
  updatedAt: timestamptz
  webrtc: WebrtcObjRelInsertInput
}
"""
input type for inserting object relation for remote table "line"
"""
input LineObjRelInsertInput {
  data: LineInsertInput!
  "upsert condition"
  onConflict: LineOnConflict
}
"""
on_conflict condition type for table "line"
"""
input LineOnConflict {
  constraint: LineConstraint!
  update_columns: [LineUpdateColumn!]! = []
  where: LineBoolExp
}
"""
Ordering options when selecting data from "line".
"""
input LineOrderBy {
  calendar: CalendarOrderBy
  cardsByLineIdAggregate: CardAggregateOrderBy
  codec: CodecOrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventsAggregate: EventAggregateOrderBy
  id: OrderBy
  label: OrderBy
  line_studiosAggregate: LineStudioAggregateOrderBy
  line_type: LineTypeOrderBy
  name: OrderBy
  organization: OrganizationOrderBy
  organizationId: OrderBy
  sip: SipOrderBy
  status: OrderBy
  type: OrderBy
  updatedAt: OrderBy
  webrtc: WebrtcOrderBy
}
"primary key columns input for table: line"
input LinePkColumnsInput {
  "The unique identifier of the line."
  id: uuid!
}
"""
input type for updating data in table "line"
"""
input LineSetInput {
  "The date and time when the line was created."
  createdAt: timestamptz
  "The date and time when the line was deleted."
  deletedAt: timestamptz
  "The description of the line."
  description: String
  "The unique identifier of the line."
  id: uuid
  "The label of the line is used to override the name in the UI."
  label: String
  "The name of the line."
  name: String
  organizationId: uuid
  "The status of the line."
  status: String
  "The type of the line."
  type: LineTypeEnum
  "The date and time when the line was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "line"
"""
input LineStreamCursorInput {
  "Stream column input with initial value"
  initialValue: LineStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input LineStreamCursorValueInput {
  "The date and time when the line was created."
  createdAt: timestamptz
  "The date and time when the line was deleted."
  deletedAt: timestamptz
  "The description of the line."
  description: String
  "The unique identifier of the line."
  id: uuid
  "The label of the line is used to override the name in the UI."
  label: String
  "The name of the line."
  name: String
  organizationId: uuid
  "The status of the line."
  status: String
  "The type of the line."
  type: LineTypeEnum
  "The date and time when the line was last updated."
  updatedAt: timestamptz
}
"""
order by aggregate values of table "line_studio"
"""
input LineStudioAggregateOrderBy {
  count: OrderBy
  max: line_studio_max_order_by
  min: line_studio_min_order_by
}
"""
input type for inserting array relation for remote table "line_studio"
"""
input LineStudioArrRelInsertInput {
  data: [LineStudioInsertInput!]!
  "upsert condition"
  onConflict: LineStudioOnConflict
}
"""
Boolean expression to filter rows from the table "line_studio". All fields are combined with a logical 'AND'.
"""
input LineStudioBoolExp {
  _and: [LineStudioBoolExp!]
  _not: LineStudioBoolExp
  _or: [LineStudioBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  line: LineBoolExp
  lineId: UuidComparisonExp
  studio: StudioBoolExp
  studioId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "line_studio"
"""
input LineStudioInsertInput {
  "The date and time when the line_studio was created."
  createdAt: timestamptz
  "The date and time when the line_studio was deleted."
  deletedAt: timestamptz
  line: LineObjRelInsertInput
  "The line this line_studio is linked to."
  lineId: uuid
  studio: StudioObjRelInsertInput
  "The studio this line_studio is linked to."
  studioId: uuid
  "The date and time when the line_studio was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "line_studio"
"""
input LineStudioOnConflict {
  constraint: LineStudioConstraint!
  update_columns: [LineStudioUpdateColumn!]! = []
  where: LineStudioBoolExp
}
"""
Ordering options when selecting data from "line_studio".
"""
input LineStudioOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  line: LineOrderBy
  lineId: OrderBy
  studio: StudioOrderBy
  studioId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: line_studio"
input LineStudioPkColumnsInput {
  "The line this line_studio is linked to."
  lineId: uuid!
  "The studio this line_studio is linked to."
  studioId: uuid!
}
"""
input type for updating data in table "line_studio"
"""
input LineStudioSetInput {
  "The date and time when the line_studio was created."
  createdAt: timestamptz
  "The date and time when the line_studio was deleted."
  deletedAt: timestamptz
  "The line this line_studio is linked to."
  lineId: uuid
  "The studio this line_studio is linked to."
  studioId: uuid
  "The date and time when the line_studio was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "line_studio"
"""
input LineStudioStreamCursorInput {
  "Stream column input with initial value"
  initialValue: LineStudioStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input LineStudioStreamCursorValueInput {
  "The date and time when the line_studio was created."
  createdAt: timestamptz
  "The date and time when the line_studio was deleted."
  deletedAt: timestamptz
  "The line this line_studio is linked to."
  lineId: uuid
  "The studio this line_studio is linked to."
  studioId: uuid
  "The date and time when the line_studio was last updated."
  updatedAt: timestamptz
}
input LineStudioUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: LineStudioSetInput
  where: LineStudioBoolExp!
}
"""
Boolean expression to filter rows from the table "line_type". All fields are combined with a logical 'AND'.
"""
input LineTypeBoolExp {
  _and: [LineTypeBoolExp!]
  _not: LineTypeBoolExp
  _or: [LineTypeBoolExp!]
  comment: StringComparisonExp
  lines: LineBoolExp
  lines_aggregate: line_aggregate_bool_exp
  value: StringComparisonExp
}
"""
Boolean expression to compare columns of type "LineTypeEnum". All fields are combined with logical 'AND'.
"""
input LineTypeEnumComparisonExp {
  _eq: LineTypeEnum
  _in: [LineTypeEnum!]
  _isNull: Boolean
  _neq: LineTypeEnum
  _nin: [LineTypeEnum!]
}
"""
input type for inserting data into table "line_type"
"""
input LineTypeInsertInput {
  "The comment of the line type."
  comment: String
  lines: LineArrRelInsertInput
  "The value of the line type."
  value: String
}
"""
input type for inserting object relation for remote table "line_type"
"""
input LineTypeObjRelInsertInput {
  data: LineTypeInsertInput!
  "upsert condition"
  onConflict: LineTypeOnConflict
}
"""
on_conflict condition type for table "line_type"
"""
input LineTypeOnConflict {
  constraint: LineTypeConstraint!
  update_columns: [LineTypeUpdateColumn!]! = []
  where: LineTypeBoolExp
}
"""
Ordering options when selecting data from "line_type".
"""
input LineTypeOrderBy {
  comment: OrderBy
  linesAggregate: LineAggregateOrderBy
  value: OrderBy
}
"primary key columns input for table: line_type"
input LineTypePkColumnsInput {
  "The value of the line type."
  value: String!
}
"""
input type for updating data in table "line_type"
"""
input LineTypeSetInput {
  "The comment of the line type."
  comment: String
  "The value of the line type."
  value: String
}
"""
Streaming cursor of the table "line_type"
"""
input LineTypeStreamCursorInput {
  "Stream column input with initial value"
  initialValue: LineTypeStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input LineTypeStreamCursorValueInput {
  "The comment of the line type."
  comment: String
  "The value of the line type."
  value: String
}
input LineTypeUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: LineTypeSetInput
  where: LineTypeBoolExp!
}
input LineUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: LineSetInput
  where: LineBoolExp!
}
"""
Boolean expression to filter rows from the table "media". All fields are combined with a logical 'AND'.
"""
input MediaBoolExp {
  _and: [MediaBoolExp!]
  _not: MediaBoolExp
  _or: [MediaBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  type: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "media"
"""
input MediaInsertInput {
  "The date and time when the media was created."
  createdAt: timestamptz
  "The date and time when the media was deleted."
  deletedAt: timestamptz
  "The description of the media."
  description: String
  "The unique identifier of the media."
  id: uuid
  "The label of the media is used to override the name in the UI."
  label: String
  "The name of the media."
  name: String
  "The type of the media."
  type: String
  "The date and time when the media was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "media"
"""
input MediaOnConflict {
  constraint: MediaConstraint!
  update_columns: [MediaUpdateColumn!]! = []
  where: MediaBoolExp
}
"""
Ordering options when selecting data from "media".
"""
input MediaOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: media"
input MediaPkColumnsInput {
  "The unique identifier of the media."
  id: uuid!
}
"""
input type for updating data in table "media"
"""
input MediaSetInput {
  "The date and time when the media was created."
  createdAt: timestamptz
  "The date and time when the media was deleted."
  deletedAt: timestamptz
  "The description of the media."
  description: String
  "The unique identifier of the media."
  id: uuid
  "The label of the media is used to override the name in the UI."
  label: String
  "The name of the media."
  name: String
  "The type of the media."
  type: String
  "The date and time when the media was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "media"
"""
input MediaStreamCursorInput {
  "Stream column input with initial value"
  initialValue: MediaStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input MediaStreamCursorValueInput {
  "The date and time when the media was created."
  createdAt: timestamptz
  "The date and time when the media was deleted."
  deletedAt: timestamptz
  "The description of the media."
  description: String
  "The unique identifier of the media."
  id: uuid
  "The label of the media is used to override the name in the UI."
  label: String
  "The name of the media."
  name: String
  "The type of the media."
  type: String
  "The date and time when the media was last updated."
  updatedAt: timestamptz
}
input MediaUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: MediaSetInput
  where: MediaBoolExp!
}
"""
Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'.
"""
input OrganizationBoolExp {
  _and: [OrganizationBoolExp!]
  _not: OrganizationBoolExp
  _or: [OrganizationBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  groups: GroupBoolExp
  groups_aggregate: group_aggregate_bool_exp
  id: UuidComparisonExp
  label: StringComparisonExp
  lines: LineBoolExp
  lines_aggregate: line_aggregate_bool_exp
  logo: StringComparisonExp
  name: StringComparisonExp
  studios: StudioBoolExp
  studios_aggregate: studio_aggregate_bool_exp
  updatedAt: TimestamptzComparisonExp
  users: UserBoolExp
  users_aggregate: user_aggregate_bool_exp
}
"""
input type for inserting data into table "organization"
"""
input OrganizationInsertInput {
  "The date and time when the organization was created."
  createdAt: timestamptz
  "The date and time when the organization was deleted."
  deletedAt: timestamptz
  "The description of the organization."
  description: String
  groups: GroupArrRelInsertInput
  "The unique identifier of the organization."
  id: uuid
  "The label of the organization is used to override the name in the UI."
  label: String
  lines: LineArrRelInsertInput
  "The logo image path of the organization."
  logo: String
  "The name of the organization."
  name: String
  studios: StudioArrRelInsertInput
  "The date and time when the organization was last updated."
  updatedAt: timestamptz
  users: UserArrRelInsertInput
}
"""
input type for inserting object relation for remote table "organization"
"""
input OrganizationObjRelInsertInput {
  data: OrganizationInsertInput!
  "upsert condition"
  onConflict: OrganizationOnConflict
}
"""
on_conflict condition type for table "organization"
"""
input OrganizationOnConflict {
  constraint: OrganizationConstraint!
  update_columns: [OrganizationUpdateColumn!]! = []
  where: OrganizationBoolExp
}
"""
Ordering options when selecting data from "organization".
"""
input OrganizationOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  groupsAggregate: GroupAggregateOrderBy
  id: OrderBy
  label: OrderBy
  linesAggregate: LineAggregateOrderBy
  logo: OrderBy
  name: OrderBy
  studiosAggregate: StudioAggregateOrderBy
  updatedAt: OrderBy
  usersAggregate: UserAggregateOrderBy
}
"primary key columns input for table: organization"
input OrganizationPkColumnsInput {
  "The unique identifier of the organization."
  id: uuid!
}
"""
input type for updating data in table "organization"
"""
input OrganizationSetInput {
  "The date and time when the organization was created."
  createdAt: timestamptz
  "The date and time when the organization was deleted."
  deletedAt: timestamptz
  "The description of the organization."
  description: String
  "The unique identifier of the organization."
  id: uuid
  "The label of the organization is used to override the name in the UI."
  label: String
  "The logo image path of the organization."
  logo: String
  "The name of the organization."
  name: String
  "The date and time when the organization was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "organization"
"""
input OrganizationStreamCursorInput {
  "Stream column input with initial value"
  initialValue: OrganizationStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input OrganizationStreamCursorValueInput {
  "The date and time when the organization was created."
  createdAt: timestamptz
  "The date and time when the organization was deleted."
  deletedAt: timestamptz
  "The description of the organization."
  description: String
  "The unique identifier of the organization."
  id: uuid
  "The label of the organization is used to override the name in the UI."
  label: String
  "The logo image path of the organization."
  logo: String
  "The name of the organization."
  name: String
  "The date and time when the organization was last updated."
  updatedAt: timestamptz
}
input OrganizationUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: OrganizationSetInput
  where: OrganizationBoolExp!
}
"""
order by aggregate values of table "phone"
"""
input PhoneAggregateOrderBy {
  count: OrderBy
  max: phone_max_order_by
  min: phone_min_order_by
}
"""
input type for inserting array relation for remote table "phone"
"""
input PhoneArrRelInsertInput {
  data: [PhoneInsertInput!]!
  "upsert condition"
  onConflict: PhoneOnConflict
}
"""
Boolean expression to filter rows from the table "phone". All fields are combined with a logical 'AND'.
"""
input PhoneBoolExp {
  _and: [PhoneBoolExp!]
  _not: PhoneBoolExp
  _or: [PhoneBoolExp!]
  contact: ContactBoolExp
  contactId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  number: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  validatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "phone"
"""
input PhoneInsertInput {
  contact: ContactObjRelInsertInput
  "The contact that the phone belongs to."
  contactId: uuid
  "The date and time when the contact phone was created."
  createdAt: timestamptz
  "The date and time when the contact phone was deleted."
  deletedAt: timestamptz
  "The unique identifier of the contact phone."
  id: uuid
  "The phone number of the contact phone."
  number: String
  "The date and time when the contact phone was last updated."
  updatedAt: timestamptz
  "The date and time when the contact phone was validated."
  validatedAt: timestamptz
}
"""
on_conflict condition type for table "phone"
"""
input PhoneOnConflict {
  constraint: PhoneConstraint!
  update_columns: [PhoneUpdateColumn!]! = []
  where: PhoneBoolExp
}
"""
Ordering options when selecting data from "phone".
"""
input PhoneOrderBy {
  contact: ContactOrderBy
  contactId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  number: OrderBy
  updatedAt: OrderBy
  validatedAt: OrderBy
}
"primary key columns input for table: phone"
input PhonePkColumnsInput {
  "The unique identifier of the contact phone."
  id: uuid!
}
"""
input type for updating data in table "phone"
"""
input PhoneSetInput {
  "The contact that the phone belongs to."
  contactId: uuid
  "The date and time when the contact phone was created."
  createdAt: timestamptz
  "The date and time when the contact phone was deleted."
  deletedAt: timestamptz
  "The unique identifier of the contact phone."
  id: uuid
  "The phone number of the contact phone."
  number: String
  "The date and time when the contact phone was last updated."
  updatedAt: timestamptz
  "The date and time when the contact phone was validated."
  validatedAt: timestamptz
}
"""
Streaming cursor of the table "phone"
"""
input PhoneStreamCursorInput {
  "Stream column input with initial value"
  initialValue: PhoneStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input PhoneStreamCursorValueInput {
  "The contact that the phone belongs to."
  contactId: uuid
  "The date and time when the contact phone was created."
  createdAt: timestamptz
  "The date and time when the contact phone was deleted."
  deletedAt: timestamptz
  "The unique identifier of the contact phone."
  id: uuid
  "The phone number of the contact phone."
  number: String
  "The date and time when the contact phone was last updated."
  updatedAt: timestamptz
  "The date and time when the contact phone was validated."
  validatedAt: timestamptz
}
input PhoneUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: PhoneSetInput
  where: PhoneBoolExp!
}
"""
Boolean expression to filter rows from the table "setting". All fields are combined with a logical 'AND'.
"""
input SettingBoolExp {
  _and: [SettingBoolExp!]
  _not: SettingBoolExp
  _or: [SettingBoolExp!]
  createdAt: TimestamptzComparisonExp
  darkMode: BooleanComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  gridTabBottom: BooleanComparisonExp
  id: UuidComparisonExp
  leftPanelWidth: IntComparisonExp
  name: StringComparisonExp
  padding: IntComparisonExp
  panelTabBottom: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for incrementing numeric columns in table "setting"
"""
input SettingIncInput {
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The padding of the grid."
  padding: Int
}
"""
input type for inserting data into table "setting"
"""
input SettingInsertInput {
  "The date and time when the setting was created."
  createdAt: timestamptz
  "Enable or disable dark mode."
  darkMode: Boolean
  "The date and time when the setting was deleted."
  deletedAt: timestamptz
  "The description of the setting."
  description: String
  "Show tabs at the bottom of the grid."
  gridTabBottom: Boolean
  "The unique identifier of the setting."
  id: uuid
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The name of the setting."
  name: String
  "The padding of the grid."
  padding: Int
  "Show tabs at the bottom of the panel."
  panelTabBottom: Boolean
  "The date and time when the setting was last updated."
  updatedAt: timestamptz
}
"""
on_conflict condition type for table "setting"
"""
input SettingOnConflict {
  constraint: SettingConstraint!
  update_columns: [SettingUpdateColumn!]! = []
  where: SettingBoolExp
}
"""
Ordering options when selecting data from "setting".
"""
input SettingOrderBy {
  createdAt: OrderBy
  darkMode: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  gridTabBottom: OrderBy
  id: OrderBy
  leftPanelWidth: OrderBy
  name: OrderBy
  padding: OrderBy
  panelTabBottom: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: setting"
input SettingPkColumnsInput {
  "The unique identifier of the setting."
  id: uuid!
}
"""
input type for updating data in table "setting"
"""
input SettingSetInput {
  "The date and time when the setting was created."
  createdAt: timestamptz
  "Enable or disable dark mode."
  darkMode: Boolean
  "The date and time when the setting was deleted."
  deletedAt: timestamptz
  "The description of the setting."
  description: String
  "Show tabs at the bottom of the grid."
  gridTabBottom: Boolean
  "The unique identifier of the setting."
  id: uuid
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The name of the setting."
  name: String
  "The padding of the grid."
  padding: Int
  "Show tabs at the bottom of the panel."
  panelTabBottom: Boolean
  "The date and time when the setting was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "setting"
"""
input SettingStreamCursorInput {
  "Stream column input with initial value"
  initialValue: SettingStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input SettingStreamCursorValueInput {
  "The date and time when the setting was created."
  createdAt: timestamptz
  "Enable or disable dark mode."
  darkMode: Boolean
  "The date and time when the setting was deleted."
  deletedAt: timestamptz
  "The description of the setting."
  description: String
  "Show tabs at the bottom of the grid."
  gridTabBottom: Boolean
  "The unique identifier of the setting."
  id: uuid
  "Left panel size in pixel"
  leftPanelWidth: Int
  "The name of the setting."
  name: String
  "The padding of the grid."
  padding: Int
  "Show tabs at the bottom of the panel."
  panelTabBottom: Boolean
  "The date and time when the setting was last updated."
  updatedAt: timestamptz
}
input SettingUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: SettingIncInput
  "sets the columns of the filtered rows to the given values"
  _set: SettingSetInput
  where: SettingBoolExp!
}
"""
order by aggregate values of table "showinfo"
"""
input ShowinfoAggregateOrderBy {
  avg: showinfo_avg_order_by
  count: OrderBy
  max: showinfo_max_order_by
  min: showinfo_min_order_by
  stddev: showinfo_stddev_order_by
  stddev_pop: showinfo_stddev_pop_order_by
  stddev_samp: showinfo_stddev_samp_order_by
  sum: showinfo_sum_order_by
  var_pop: showinfo_var_pop_order_by
  var_samp: showinfo_var_samp_order_by
  variance: showinfo_variance_order_by
}
"""
input type for inserting array relation for remote table "showinfo"
"""
input ShowinfoArrRelInsertInput {
  data: [ShowinfoInsertInput!]!
  "upsert condition"
  onConflict: ShowinfoOnConflict
}
"""
Boolean expression to filter rows from the table "showinfo". All fields are combined with a logical 'AND'.
"""
input ShowinfoBoolExp {
  _and: [ShowinfoBoolExp!]
  _not: ShowinfoBoolExp
  _or: [ShowinfoBoolExp!]
  align: StringComparisonExp
  backgroundColor: CitextComparisonExp
  bold: BooleanComparisonExp
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  global: BooleanComparisonExp
  grid: GridBoolExp
  gridId: UuidComparisonExp
  grid_showinfos: GridShowinfoBoolExp
  grid_showinfos_aggregate: grid_showinfo_aggregate_bool_exp
  id: UuidComparisonExp
  name: StringComparisonExp
  path: StringComparisonExp
  position: IntComparisonExp
  show: BooleanComparisonExp
  size: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for incrementing numeric columns in table "showinfo"
"""
input ShowinfoIncInput {
  "The position of the information."
  position: Int
  "The size of the text."
  size: Int
}
"""
input type for inserting data into table "showinfo"
"""
input ShowinfoInsertInput {
  "The alignment of the text."
  align: String
  "The background color of the information."
  backgroundColor: citext
  "Make the text bold."
  bold: Boolean
  "The color of the text."
  color: String
  "The date and time when the showinfo was created."
  createdAt: timestamptz
  "The date and time when the showinfo was deleted."
  deletedAt: timestamptz
  "Is it the global showinfo template."
  global: Boolean
  grid: GridObjRelInsertInput
  "The grid this showinfo is linked to."
  gridId: uuid
  grid_showinfos: GridShowinfoArrRelInsertInput
  "The unique identifier of the showinfo."
  id: uuid
  "The name of the information."
  name: String
  "Javascript path to the information."
  path: String
  "The position of the information."
  position: Int
  "Show or hide the information in the card."
  show: Boolean
  "The size of the text."
  size: Int
  "The date and time when the showinfo was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "showinfo"
"""
input ShowinfoObjRelInsertInput {
  data: ShowinfoInsertInput!
  "upsert condition"
  onConflict: ShowinfoOnConflict
}
"""
on_conflict condition type for table "showinfo"
"""
input ShowinfoOnConflict {
  constraint: ShowinfoConstraint!
  update_columns: [ShowinfoUpdateColumn!]! = []
  where: ShowinfoBoolExp
}
"""
Ordering options when selecting data from "showinfo".
"""
input ShowinfoOrderBy {
  align: OrderBy
  backgroundColor: OrderBy
  bold: OrderBy
  color: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  global: OrderBy
  grid: GridOrderBy
  gridId: OrderBy
  grid_showinfosAggregate: GridShowinfoAggregateOrderBy
  id: OrderBy
  name: OrderBy
  path: OrderBy
  position: OrderBy
  show: OrderBy
  size: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: showinfo"
input ShowinfoPkColumnsInput {
  "The unique identifier of the showinfo."
  id: uuid!
}
"""
input type for updating data in table "showinfo"
"""
input ShowinfoSetInput {
  "The alignment of the text."
  align: String
  "The background color of the information."
  backgroundColor: citext
  "Make the text bold."
  bold: Boolean
  "The color of the text."
  color: String
  "The date and time when the showinfo was created."
  createdAt: timestamptz
  "The date and time when the showinfo was deleted."
  deletedAt: timestamptz
  "Is it the global showinfo template."
  global: Boolean
  "The grid this showinfo is linked to."
  gridId: uuid
  "The unique identifier of the showinfo."
  id: uuid
  "The name of the information."
  name: String
  "Javascript path to the information."
  path: String
  "The position of the information."
  position: Int
  "Show or hide the information in the card."
  show: Boolean
  "The size of the text."
  size: Int
  "The date and time when the showinfo was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "showinfo"
"""
input ShowinfoStreamCursorInput {
  "Stream column input with initial value"
  initialValue: ShowinfoStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input ShowinfoStreamCursorValueInput {
  "The alignment of the text."
  align: String
  "The background color of the information."
  backgroundColor: citext
  "Make the text bold."
  bold: Boolean
  "The color of the text."
  color: String
  "The date and time when the showinfo was created."
  createdAt: timestamptz
  "The date and time when the showinfo was deleted."
  deletedAt: timestamptz
  "Is it the global showinfo template."
  global: Boolean
  "The grid this showinfo is linked to."
  gridId: uuid
  "The unique identifier of the showinfo."
  id: uuid
  "The name of the information."
  name: String
  "Javascript path to the information."
  path: String
  "The position of the information."
  position: Int
  "Show or hide the information in the card."
  show: Boolean
  "The size of the text."
  size: Int
  "The date and time when the showinfo was last updated."
  updatedAt: timestamptz
}
input ShowinfoUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: ShowinfoIncInput
  "sets the columns of the filtered rows to the given values"
  _set: ShowinfoSetInput
  where: ShowinfoBoolExp!
}
input SignupInput {
  email: citext!
  organizationId: uuid!
  password: String!
  username: String!
}
"""
Boolean expression to filter rows from the table "sip". All fields are combined with a logical 'AND'.
"""
input SipBoolExp {
  _and: [SipBoolExp!]
  _not: SipBoolExp
  _or: [SipBoolExp!]
  address: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  line: LineBoolExp
  password: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  username: StringComparisonExp
}
"""
input type for inserting data into table "sip"
"""
input SipInsertInput {
  "The address of the trunk."
  address: String
  "The date and time when the SIP line was created."
  createdAt: timestamptz
  "The date and time when the SIP line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the SIP line."
  id: uuid
  line: LineObjRelInsertInput
  "The password of the SIP line."
  password: String
  "The date and time when the SIP line was last updated."
  updatedAt: timestamptz
  "The username of the SIP line."
  username: String
}
"""
input type for inserting object relation for remote table "sip"
"""
input SipObjRelInsertInput {
  data: SipInsertInput!
  "upsert condition"
  onConflict: SipOnConflict
}
"""
on_conflict condition type for table "sip"
"""
input SipOnConflict {
  constraint: SipConstraint!
  update_columns: [SipUpdateColumn!]! = []
  where: SipBoolExp
}
"""
Ordering options when selecting data from "sip".
"""
input SipOrderBy {
  address: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  line: LineOrderBy
  password: OrderBy
  updatedAt: OrderBy
  username: OrderBy
}
"primary key columns input for table: sip"
input SipPkColumnsInput {
  "The unique identifier of the SIP line."
  id: uuid!
}
"""
input type for updating data in table "sip"
"""
input SipSetInput {
  "The address of the trunk."
  address: String
  "The date and time when the SIP line was created."
  createdAt: timestamptz
  "The date and time when the SIP line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the SIP line."
  id: uuid
  "The password of the SIP line."
  password: String
  "The date and time when the SIP line was last updated."
  updatedAt: timestamptz
  "The username of the SIP line."
  username: String
}
"""
Streaming cursor of the table "sip"
"""
input SipStreamCursorInput {
  "Stream column input with initial value"
  initialValue: SipStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input SipStreamCursorValueInput {
  "The address of the trunk."
  address: String
  "The date and time when the SIP line was created."
  createdAt: timestamptz
  "The date and time when the SIP line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the SIP line."
  id: uuid
  "The password of the SIP line."
  password: String
  "The date and time when the SIP line was last updated."
  updatedAt: timestamptz
  "The username of the SIP line."
  username: String
}
input SipUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: SipSetInput
  where: SipBoolExp!
}
"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _isNull: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}
"""
order by aggregate values of table "studio"
"""
input StudioAggregateOrderBy {
  count: OrderBy
  max: studio_max_order_by
  min: studio_min_order_by
}
"""
input type for inserting array relation for remote table "studio"
"""
input StudioArrRelInsertInput {
  data: [StudioInsertInput!]!
  "upsert condition"
  onConflict: StudioOnConflict
}
"""
Boolean expression to filter rows from the table "studio". All fields are combined with a logical 'AND'.
"""
input StudioBoolExp {
  _and: [StudioBoolExp!]
  _not: StudioBoolExp
  _or: [StudioBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  grids: GridBoolExp
  grids_aggregate: grid_aggregate_bool_exp
  group_studios: GroupStudioBoolExp
  group_studios_aggregate: group_studio_aggregate_bool_exp
  id: UuidComparisonExp
  label: StringComparisonExp
  line_studios: LineStudioBoolExp
  line_studios_aggregate: line_studio_aggregate_bool_exp
  logo: StringComparisonExp
  name: StringComparisonExp
  organization: OrganizationBoolExp
  organizationId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "studio"
"""
input StudioInsertInput {
  "The date and time when the studio was created."
  createdAt: timestamptz
  "The date and time when the studio was deleted."
  deletedAt: timestamptz
  "The description of the studio."
  description: String
  grids: GridArrRelInsertInput
  group_studios: GroupStudioArrRelInsertInput
  "The unique identifier of the studio."
  id: uuid
  "The label of the studio is used to override the name in the UI."
  label: String
  line_studios: LineStudioArrRelInsertInput
  "The logo image path of the studio."
  logo: String
  "The name of the studio."
  name: String
  organization: OrganizationObjRelInsertInput
  "The organization id of the studio."
  organizationId: uuid
  "The date and time when the studio was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "studio"
"""
input StudioObjRelInsertInput {
  data: StudioInsertInput!
  "upsert condition"
  onConflict: StudioOnConflict
}
"""
on_conflict condition type for table "studio"
"""
input StudioOnConflict {
  constraint: StudioConstraint!
  update_columns: [StudioUpdateColumn!]! = []
  where: StudioBoolExp
}
"""
Ordering options when selecting data from "studio".
"""
input StudioOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  gridsAggregate: GridAggregateOrderBy
  group_studiosAggregate: GroupStudioAggregateOrderBy
  id: OrderBy
  label: OrderBy
  line_studiosAggregate: LineStudioAggregateOrderBy
  logo: OrderBy
  name: OrderBy
  organization: OrganizationOrderBy
  organizationId: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: studio"
input StudioPkColumnsInput {
  "The unique identifier of the studio."
  id: uuid!
}
"""
input type for updating data in table "studio"
"""
input StudioSetInput {
  "The date and time when the studio was created."
  createdAt: timestamptz
  "The date and time when the studio was deleted."
  deletedAt: timestamptz
  "The description of the studio."
  description: String
  "The unique identifier of the studio."
  id: uuid
  "The label of the studio is used to override the name in the UI."
  label: String
  "The logo image path of the studio."
  logo: String
  "The name of the studio."
  name: String
  "The organization id of the studio."
  organizationId: uuid
  "The date and time when the studio was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "studio"
"""
input StudioStreamCursorInput {
  "Stream column input with initial value"
  initialValue: StudioStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input StudioStreamCursorValueInput {
  "The date and time when the studio was created."
  createdAt: timestamptz
  "The date and time when the studio was deleted."
  deletedAt: timestamptz
  "The description of the studio."
  description: String
  "The unique identifier of the studio."
  id: uuid
  "The label of the studio is used to override the name in the UI."
  label: String
  "The logo image path of the studio."
  logo: String
  "The name of the studio."
  name: String
  "The organization id of the studio."
  organizationId: uuid
  "The date and time when the studio was last updated."
  updatedAt: timestamptz
}
input StudioUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: StudioSetInput
  where: StudioBoolExp!
}
"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input TagBoolExp {
  _and: [TagBoolExp!]
  _not: TagBoolExp
  _or: [TagBoolExp!]
  card_tags: CardTagBoolExp
  card_tags_aggregate: card_tag_aggregate_bool_exp
  color: CitextComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  name: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}
"""
input type for inserting data into table "tag"
"""
input TagInsertInput {
  card_tags: CardTagArrRelInsertInput
  "The color of the tag."
  color: citext
  "The date and time when the tag was created."
  createdAt: timestamptz
  "The date and time when the tag was deleted."
  deletedAt: timestamptz
  "The description of the tag."
  description: String
  "The unique identifier of the tag."
  id: uuid
  "The label of the tag is used to override the name in the UI."
  label: String
  "The name of the tag."
  name: String
  "The date and time when the tag was last updated."
  updatedAt: timestamptz
}
"""
input type for inserting object relation for remote table "tag"
"""
input TagObjRelInsertInput {
  data: TagInsertInput!
  "upsert condition"
  onConflict: TagOnConflict
}
"""
on_conflict condition type for table "tag"
"""
input TagOnConflict {
  constraint: TagConstraint!
  update_columns: [TagUpdateColumn!]! = []
  where: TagBoolExp
}
"""
Ordering options when selecting data from "tag".
"""
input TagOrderBy {
  card_tagsAggregate: CardTagAggregateOrderBy
  color: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  id: OrderBy
  label: OrderBy
  name: OrderBy
  updatedAt: OrderBy
}
"primary key columns input for table: tag"
input TagPkColumnsInput {
  "The unique identifier of the tag."
  id: uuid!
}
"""
input type for updating data in table "tag"
"""
input TagSetInput {
  "The color of the tag."
  color: citext
  "The date and time when the tag was created."
  createdAt: timestamptz
  "The date and time when the tag was deleted."
  deletedAt: timestamptz
  "The description of the tag."
  description: String
  "The unique identifier of the tag."
  id: uuid
  "The label of the tag is used to override the name in the UI."
  label: String
  "The name of the tag."
  name: String
  "The date and time when the tag was last updated."
  updatedAt: timestamptz
}
"""
Streaming cursor of the table "tag"
"""
input TagStreamCursorInput {
  "Stream column input with initial value"
  initialValue: TagStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input TagStreamCursorValueInput {
  "The color of the tag."
  color: citext
  "The date and time when the tag was created."
  createdAt: timestamptz
  "The date and time when the tag was deleted."
  deletedAt: timestamptz
  "The description of the tag."
  description: String
  "The unique identifier of the tag."
  id: uuid
  "The label of the tag is used to override the name in the UI."
  label: String
  "The name of the tag."
  name: String
  "The date and time when the tag was last updated."
  updatedAt: timestamptz
}
input TagUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: TagSetInput
  where: TagBoolExp!
}
"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
"""
order by aggregate values of table "user"
"""
input UserAggregateOrderBy {
  count: OrderBy
  max: user_max_order_by
  min: user_min_order_by
}
"""
input type for inserting array relation for remote table "user"
"""
input UserArrRelInsertInput {
  data: [UserInsertInput!]!
  "upsert condition"
  onConflict: UserOnConflict
}
"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  beginDate: DateComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  email: CitextComparisonExp
  endDate: DateComparisonExp
  eulaAccepted: BooleanComparisonExp
  firstName: StringComparisonExp
  id: UuidComparisonExp
  lastName: StringComparisonExp
  lastSeen: TimestamptzComparisonExp
  organization: OrganizationBoolExp
  organizationId: UuidComparisonExp
  password: StringComparisonExp
  resetPassword: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
  user_groups: UserGroupBoolExp
  user_groups_aggregate: user_group_aggregate_bool_exp
  username: StringComparisonExp
}
"""
order by aggregate values of table "user_group"
"""
input UserGroupAggregateOrderBy {
  count: OrderBy
  max: user_group_max_order_by
  min: user_group_min_order_by
}
"""
input type for inserting array relation for remote table "user_group"
"""
input UserGroupArrRelInsertInput {
  data: [UserGroupInsertInput!]!
  "upsert condition"
  onConflict: UserGroupOnConflict
}
"""
Boolean expression to filter rows from the table "user_group". All fields are combined with a logical 'AND'.
"""
input UserGroupBoolExp {
  _and: [UserGroupBoolExp!]
  _not: UserGroupBoolExp
  _or: [UserGroupBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  group: GroupBoolExp
  groupId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UserBoolExp
  userId: UuidComparisonExp
}
"""
input type for inserting data into table "user_group"
"""
input UserGroupInsertInput {
  "The date and time when the user group was created."
  createdAt: timestamptz
  "The date and time when the user group was deleted."
  deletedAt: timestamptz
  group: GroupObjRelInsertInput
  "The group of the user group."
  groupId: uuid
  "The date and time when the user group was last updated."
  updatedAt: timestamptz
  user: UserObjRelInsertInput
  "The user of the user group."
  userId: uuid
}
"""
on_conflict condition type for table "user_group"
"""
input UserGroupOnConflict {
  constraint: UserGroupConstraint!
  update_columns: [UserGroupUpdateColumn!]! = []
  where: UserGroupBoolExp
}
"""
Ordering options when selecting data from "user_group".
"""
input UserGroupOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  group: GroupOrderBy
  groupId: OrderBy
  updatedAt: OrderBy
  user: UserOrderBy
  userId: OrderBy
}
"primary key columns input for table: user_group"
input UserGroupPkColumnsInput {
  "The group of the user group."
  groupId: uuid!
  "The user of the user group."
  userId: uuid!
}
"""
input type for updating data in table "user_group"
"""
input UserGroupSetInput {
  "The date and time when the user group was created."
  createdAt: timestamptz
  "The date and time when the user group was deleted."
  deletedAt: timestamptz
  "The group of the user group."
  groupId: uuid
  "The date and time when the user group was last updated."
  updatedAt: timestamptz
  "The user of the user group."
  userId: uuid
}
"""
Streaming cursor of the table "user_group"
"""
input UserGroupStreamCursorInput {
  "Stream column input with initial value"
  initialValue: UserGroupStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input UserGroupStreamCursorValueInput {
  "The date and time when the user group was created."
  createdAt: timestamptz
  "The date and time when the user group was deleted."
  deletedAt: timestamptz
  "The group of the user group."
  groupId: uuid
  "The date and time when the user group was last updated."
  updatedAt: timestamptz
  "The user of the user group."
  userId: uuid
}
input UserGroupUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: UserGroupSetInput
  where: UserGroupBoolExp!
}
"""
input type for inserting data into table "user"
"""
input UserInsertInput {
  "The date when the user started working."
  beginDate: date
  "The date and time when the user was created."
  createdAt: timestamptz
  "The date and time when the user was deleted."
  deletedAt: timestamptz
  "The email of the user."
  email: citext
  "The date when the user stopped working."
  endDate: date
  "Whether the user has accepted the eula."
  eulaAccepted: Boolean
  "The first name of the user."
  firstName: String
  "The unique identifier of the user."
  id: uuid
  "The last name of the user."
  lastName: String
  "The date and time when the user was last seen."
  lastSeen: timestamptz
  organization: OrganizationObjRelInsertInput
  "The organization of the user."
  organizationId: uuid
  "The password of the user."
  password: String
  "Whether the user should be asked to reset their password on next login."
  resetPassword: Boolean
  "The date and time when the user was last updated."
  updatedAt: timestamptz
  user_groups: UserGroupArrRelInsertInput
  "The username of the user."
  username: String
}
"""
input type for inserting object relation for remote table "user"
"""
input UserObjRelInsertInput {
  data: UserInsertInput!
  "upsert condition"
  onConflict: UserOnConflict
}
"""
on_conflict condition type for table "user"
"""
input UserOnConflict {
  constraint: UserConstraint!
  update_columns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}
"""
Ordering options when selecting data from "user".
"""
input UserOrderBy {
  beginDate: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  endDate: OrderBy
  eulaAccepted: OrderBy
  firstName: OrderBy
  id: OrderBy
  lastName: OrderBy
  lastSeen: OrderBy
  organization: OrganizationOrderBy
  organizationId: OrderBy
  password: OrderBy
  resetPassword: OrderBy
  updatedAt: OrderBy
  user_groupsAggregate: UserGroupAggregateOrderBy
  username: OrderBy
}
"primary key columns input for table: user"
input UserPkColumnsInput {
  "The unique identifier of the user."
  id: uuid!
}
"""
input type for updating data in table "user"
"""
input UserSetInput {
  "The date when the user started working."
  beginDate: date
  "The date and time when the user was created."
  createdAt: timestamptz
  "The date and time when the user was deleted."
  deletedAt: timestamptz
  "The email of the user."
  email: citext
  "The date when the user stopped working."
  endDate: date
  "Whether the user has accepted the eula."
  eulaAccepted: Boolean
  "The first name of the user."
  firstName: String
  "The unique identifier of the user."
  id: uuid
  "The last name of the user."
  lastName: String
  "The date and time when the user was last seen."
  lastSeen: timestamptz
  "The organization of the user."
  organizationId: uuid
  "The password of the user."
  password: String
  "Whether the user should be asked to reset their password on next login."
  resetPassword: Boolean
  "The date and time when the user was last updated."
  updatedAt: timestamptz
  "The username of the user."
  username: String
}
"""
Streaming cursor of the table "user"
"""
input UserStreamCursorInput {
  "Stream column input with initial value"
  initialValue: UserStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input UserStreamCursorValueInput {
  "The date when the user started working."
  beginDate: date
  "The date and time when the user was created."
  createdAt: timestamptz
  "The date and time when the user was deleted."
  deletedAt: timestamptz
  "The email of the user."
  email: citext
  "The date when the user stopped working."
  endDate: date
  "Whether the user has accepted the eula."
  eulaAccepted: Boolean
  "The first name of the user."
  firstName: String
  "The unique identifier of the user."
  id: uuid
  "The last name of the user."
  lastName: String
  "The date and time when the user was last seen."
  lastSeen: timestamptz
  "The organization of the user."
  organizationId: uuid
  "The password of the user."
  password: String
  "Whether the user should be asked to reset their password on next login."
  resetPassword: Boolean
  "The date and time when the user was last updated."
  updatedAt: timestamptz
  "The username of the user."
  username: String
}
input UserUpdates {
  "sets the columns of the filtered rows to the given values"
  _set: UserSetInput
  where: UserBoolExp!
}
"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
"""
Boolean expression to filter rows from the table "webrtc". All fields are combined with a logical 'AND'.
"""
input WebrtcBoolExp {
  _and: [WebrtcBoolExp!]
  _not: WebrtcBoolExp
  _or: [WebrtcBoolExp!]
  audioPortRead: IntComparisonExp
  audioPortWrite: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  line: LineBoolExp
  updatedAt: TimestamptzComparisonExp
  video: BooleanComparisonExp
  videoPortRead: IntComparisonExp
  videoPortWrite: IntComparisonExp
}
"""
input type for incrementing numeric columns in table "webrtc"
"""
input WebrtcIncInput {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"""
input type for inserting data into table "webrtc"
"""
input WebrtcInsertInput {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The date and time when the WebRTC line was created."
  createdAt: timestamptz
  "The date and time when the WebRTC line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the WebRTC line."
  id: uuid
  line: LineObjRelInsertInput
  "The date and time when the WebRTC line was last updated."
  updatedAt: timestamptz
  "Whether the WebRTC line has video."
  video: Boolean
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"""
input type for inserting object relation for remote table "webrtc"
"""
input WebrtcObjRelInsertInput {
  data: WebrtcInsertInput!
  "upsert condition"
  onConflict: WebrtcOnConflict
}
"""
on_conflict condition type for table "webrtc"
"""
input WebrtcOnConflict {
  constraint: WebrtcConstraint!
  update_columns: [WebrtcUpdateColumn!]! = []
  where: WebrtcBoolExp
}
"""
Ordering options when selecting data from "webrtc".
"""
input WebrtcOrderBy {
  audioPortRead: OrderBy
  audioPortWrite: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  line: LineOrderBy
  updatedAt: OrderBy
  video: OrderBy
  videoPortRead: OrderBy
  videoPortWrite: OrderBy
}
"primary key columns input for table: webrtc"
input WebrtcPkColumnsInput {
  "The unique identifier of the WebRTC line."
  id: uuid!
}
"""
input type for updating data in table "webrtc"
"""
input WebrtcSetInput {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The date and time when the WebRTC line was created."
  createdAt: timestamptz
  "The date and time when the WebRTC line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the WebRTC line."
  id: uuid
  "The date and time when the WebRTC line was last updated."
  updatedAt: timestamptz
  "Whether the WebRTC line has video."
  video: Boolean
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
"""
Streaming cursor of the table "webrtc"
"""
input WebrtcStreamCursorInput {
  "Stream column input with initial value"
  initialValue: WebrtcStreamCursorValueInput!
  "cursor ordering"
  ordering: CursorOrdering
}
"Initial value of the column from where the streaming should start"
input WebrtcStreamCursorValueInput {
  "The port used to read audio."
  audioPortRead: Int
  "The port used to write audio."
  audioPortWrite: Int
  "The date and time when the WebRTC line was created."
  createdAt: timestamptz
  "The date and time when the WebRTC line was deleted."
  deletedAt: timestamptz
  "The unique identifier of the WebRTC line."
  id: uuid
  "The date and time when the WebRTC line was last updated."
  updatedAt: timestamptz
  "Whether the WebRTC line has video."
  video: Boolean
  "The port used to read video."
  videoPortRead: Int
  "The port used to write video."
  videoPortWrite: Int
}
input WebrtcUpdates {
  "increments the numeric columns with given value of the filtered values"
  _inc: WebrtcIncInput
  "sets the columns of the filtered rows to the given values"
  _set: WebrtcSetInput
  where: WebrtcBoolExp!
}
input address_aggregate_bool_exp {
  count: address_aggregate_bool_exp_count
}
input address_aggregate_bool_exp_count {
  arguments: [AddressSelectColumn!]
  distinct: Boolean
  filter: AddressBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "address"
"""
input address_max_order_by {
  "The contact that the address belongs to."
  contactId: OrderBy
  "The date and time when the address was created."
  createdAt: OrderBy
  "The date and time when the address was deleted."
  deletedAt: OrderBy
  "The unique identifier of the address."
  id: OrderBy
  "The date and time when the address was last updated."
  updatedAt: OrderBy
  "The date and time when the address was validated."
  validatedAt: OrderBy
  "The text value of the address."
  value: OrderBy
}
"""
order by min() on columns of table "address"
"""
input address_min_order_by {
  "The contact that the address belongs to."
  contactId: OrderBy
  "The date and time when the address was created."
  createdAt: OrderBy
  "The date and time when the address was deleted."
  deletedAt: OrderBy
  "The unique identifier of the address."
  id: OrderBy
  "The date and time when the address was last updated."
  updatedAt: OrderBy
  "The date and time when the address was validated."
  validatedAt: OrderBy
  "The text value of the address."
  value: OrderBy
}
input button_aggregate_bool_exp {
  bool_and: button_aggregate_bool_exp_bool_and
  bool_or: button_aggregate_bool_exp_bool_or
  count: button_aggregate_bool_exp_count
}
input button_aggregate_bool_exp_bool_and {
  arguments: button_select_column_button_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: ButtonBoolExp
  predicate: BooleanComparisonExp!
}
input button_aggregate_bool_exp_bool_or {
  arguments: button_select_column_button_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: ButtonBoolExp
  predicate: BooleanComparisonExp!
}
input button_aggregate_bool_exp_count {
  arguments: [ButtonSelectColumn!]
  distinct: Boolean
  filter: ButtonBoolExp
  predicate: IntComparisonExp!
}
"""
order by avg() on columns of table "button"
"""
input button_avg_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by max() on columns of table "button"
"""
input button_max_order_by {
  "The action that the button triggers."
  actionId: OrderBy
  "The color of the button when it is off."
  colorOff: OrderBy
  "The color of the button when it is on."
  colorOn: OrderBy
  "The date and time when the button was created."
  createdAt: OrderBy
  "The date and time when the button was deleted."
  deletedAt: OrderBy
  "The description of the button."
  description: OrderBy
  "The icon of the button."
  icon: OrderBy
  "The unique identifier of the button."
  id: OrderBy
  "The label of the button is used to override the name in the UI."
  label: OrderBy
  "The name of the button."
  name: OrderBy
  "The position of the button."
  position: OrderBy
  "The date and time when the button was last updated."
  updatedAt: OrderBy
  "The url of the button."
  url: OrderBy
}
"""
order by min() on columns of table "button"
"""
input button_min_order_by {
  "The action that the button triggers."
  actionId: OrderBy
  "The color of the button when it is off."
  colorOff: OrderBy
  "The color of the button when it is on."
  colorOn: OrderBy
  "The date and time when the button was created."
  createdAt: OrderBy
  "The date and time when the button was deleted."
  deletedAt: OrderBy
  "The description of the button."
  description: OrderBy
  "The icon of the button."
  icon: OrderBy
  "The unique identifier of the button."
  id: OrderBy
  "The label of the button is used to override the name in the UI."
  label: OrderBy
  "The name of the button."
  name: OrderBy
  "The position of the button."
  position: OrderBy
  "The date and time when the button was last updated."
  updatedAt: OrderBy
  "The url of the button."
  url: OrderBy
}
"""
order by stddev() on columns of table "button"
"""
input button_stddev_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by stddev_pop() on columns of table "button"
"""
input button_stddev_pop_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by stddev_samp() on columns of table "button"
"""
input button_stddev_samp_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by sum() on columns of table "button"
"""
input button_sum_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by var_pop() on columns of table "button"
"""
input button_var_pop_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by var_samp() on columns of table "button"
"""
input button_var_samp_order_by {
  "The position of the button."
  position: OrderBy
}
"""
order by variance() on columns of table "button"
"""
input button_variance_order_by {
  "The position of the button."
  position: OrderBy
}
input card_aggregate_bool_exp {
  count: card_aggregate_bool_exp_count
}
input card_aggregate_bool_exp_count {
  arguments: [CardSelectColumn!]
  distinct: Boolean
  filter: CardBoolExp
  predicate: IntComparisonExp!
}
input card_button_aggregate_bool_exp {
  count: card_button_aggregate_bool_exp_count
}
input card_button_aggregate_bool_exp_count {
  arguments: [CardButtonSelectColumn!]
  distinct: Boolean
  filter: CardButtonBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "card_button"
"""
input card_button_max_order_by {
  buttonId: OrderBy
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  updatedAt: OrderBy
}
"""
order by min() on columns of table "card_button"
"""
input card_button_min_order_by {
  buttonId: OrderBy
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  updatedAt: OrderBy
}
input card_grid_aggregate_bool_exp {
  count: card_grid_aggregate_bool_exp_count
}
input card_grid_aggregate_bool_exp_count {
  arguments: [CardGridSelectColumn!]
  distinct: Boolean
  filter: CardGridBoolExp
  predicate: IntComparisonExp!
}
"""
order by avg() on columns of table "card_grid"
"""
input card_grid_avg_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by max() on columns of table "card_grid"
"""
input card_grid_max_order_by {
  "The card that is in the grid."
  cardId: OrderBy
  "The date and time when the card grid was created."
  createdAt: OrderBy
  "The date and time when the card grid was deleted."
  deletedAt: OrderBy
  "The grid that the card is in."
  gridId: OrderBy
  "The position of the card in the grid."
  position: OrderBy
  "The date and time when the card grid was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "card_grid"
"""
input card_grid_min_order_by {
  "The card that is in the grid."
  cardId: OrderBy
  "The date and time when the card grid was created."
  createdAt: OrderBy
  "The date and time when the card grid was deleted."
  deletedAt: OrderBy
  "The grid that the card is in."
  gridId: OrderBy
  "The position of the card in the grid."
  position: OrderBy
  "The date and time when the card grid was last updated."
  updatedAt: OrderBy
}
"""
order by stddev() on columns of table "card_grid"
"""
input card_grid_stddev_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by stddev_pop() on columns of table "card_grid"
"""
input card_grid_stddev_pop_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by stddev_samp() on columns of table "card_grid"
"""
input card_grid_stddev_samp_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by sum() on columns of table "card_grid"
"""
input card_grid_sum_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by var_pop() on columns of table "card_grid"
"""
input card_grid_var_pop_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by var_samp() on columns of table "card_grid"
"""
input card_grid_var_samp_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by variance() on columns of table "card_grid"
"""
input card_grid_variance_order_by {
  "The position of the card in the grid."
  position: OrderBy
}
"""
order by max() on columns of table "card"
"""
input card_max_order_by {
  "The background color of the card."
  backgroundColor: OrderBy
  "The border color of the card."
  borderColor: OrderBy
  "The date and time when the card was created."
  createdAt: OrderBy
  "The date and time when the card was deleted."
  deletedAt: OrderBy
  "The description of the card."
  description: OrderBy
  "The unique identifier of the card."
  id: OrderBy
  "The label of the card is used to override the name in the UI."
  label: OrderBy
  "The line that the card is associated with."
  lineId: OrderBy
  "The name of the card."
  name: OrderBy
  "The slot color of the card."
  slotColor: OrderBy
  "The text color of the card."
  textColor: OrderBy
  "The date and time when the card was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "card"
"""
input card_min_order_by {
  "The background color of the card."
  backgroundColor: OrderBy
  "The border color of the card."
  borderColor: OrderBy
  "The date and time when the card was created."
  createdAt: OrderBy
  "The date and time when the card was deleted."
  deletedAt: OrderBy
  "The description of the card."
  description: OrderBy
  "The unique identifier of the card."
  id: OrderBy
  "The label of the card is used to override the name in the UI."
  label: OrderBy
  "The line that the card is associated with."
  lineId: OrderBy
  "The name of the card."
  name: OrderBy
  "The slot color of the card."
  slotColor: OrderBy
  "The text color of the card."
  textColor: OrderBy
  "The date and time when the card was last updated."
  updatedAt: OrderBy
}
input card_tag_aggregate_bool_exp {
  count: card_tag_aggregate_bool_exp_count
}
input card_tag_aggregate_bool_exp_count {
  arguments: [CardTagSelectColumn!]
  distinct: Boolean
  filter: CardTagBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "card_tag"
"""
input card_tag_max_order_by {
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  tagId: OrderBy
  updatedAt: OrderBy
}
"""
order by min() on columns of table "card_tag"
"""
input card_tag_min_order_by {
  cardId: OrderBy
  createdAt: OrderBy
  deletedAt: OrderBy
  tagId: OrderBy
  updatedAt: OrderBy
}
input email_aggregate_bool_exp {
  count: email_aggregate_bool_exp_count
}
input email_aggregate_bool_exp_count {
  arguments: [EmailSelectColumn!]
  distinct: Boolean
  filter: EmailBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "email"
"""
input email_max_order_by {
  "The contact that the email belongs to."
  contactId: OrderBy
  "The date and time when the email was created."
  createdAt: OrderBy
  "The date and time when the email was deleted."
  deletedAt: OrderBy
  "The unique identifier of the email."
  id: OrderBy
  "The date and time when the email was last updated."
  updatedAt: OrderBy
  "The date and time when the email was validated."
  validatedAt: OrderBy
  "The email address of the email."
  value: OrderBy
}
"""
order by min() on columns of table "email"
"""
input email_min_order_by {
  "The contact that the email belongs to."
  contactId: OrderBy
  "The date and time when the email was created."
  createdAt: OrderBy
  "The date and time when the email was deleted."
  deletedAt: OrderBy
  "The unique identifier of the email."
  id: OrderBy
  "The date and time when the email was last updated."
  updatedAt: OrderBy
  "The date and time when the email was validated."
  validatedAt: OrderBy
  "The email address of the email."
  value: OrderBy
}
input event_aggregate_bool_exp {
  bool_and: event_aggregate_bool_exp_bool_and
  bool_or: event_aggregate_bool_exp_bool_or
  count: event_aggregate_bool_exp_count
}
input event_aggregate_bool_exp_bool_and {
  arguments: event_select_column_event_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: EventBoolExp
  predicate: BooleanComparisonExp!
}
input event_aggregate_bool_exp_bool_or {
  arguments: event_select_column_event_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: EventBoolExp
  predicate: BooleanComparisonExp!
}
input event_aggregate_bool_exp_count {
  arguments: [EventSelectColumn!]
  distinct: Boolean
  filter: EventBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "event"
"""
input event_max_order_by {
  "The eventBackgroundColor override for this specific event."
  backgroundColor: OrderBy
  "The eventBorderColor override for this specific event."
  borderColor: OrderBy
  calendarId: OrderBy
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: OrderBy
  "The date and time when the event was created."
  createdAt: OrderBy
  "The date and time when the event was deleted."
  deletedAt: OrderBy
  "The description of the event."
  description: OrderBy
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: OrderBy
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: OrderBy
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: OrderBy
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: OrderBy
  "The unique identifier of the event."
  id: OrderBy
  "The label of the event is used to override the name in the UI."
  label: OrderBy
  "A reference to the line this calendar is linked to"
  lineId: OrderBy
  "The name of the event."
  name: OrderBy
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: OrderBy
  "Date object that obeys the current timeZone. When an event begins."
  start: OrderBy
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: OrderBy
  "The eventTextColor override for this specific event."
  textColor: OrderBy
  "The text that will appear on an event."
  title: OrderBy
  "The date and time when the event was last updated."
  updatedAt: OrderBy
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: OrderBy
}
"""
order by min() on columns of table "event"
"""
input event_min_order_by {
  "The eventBackgroundColor override for this specific event."
  backgroundColor: OrderBy
  "The eventBorderColor override for this specific event."
  borderColor: OrderBy
  calendarId: OrderBy
  """
  An array of strings like [ "myclass1", "myclass2" ]. Determines which HTML classNames will be attached to the rendered event.
  """
  classNames: OrderBy
  "The date and time when the event was created."
  createdAt: OrderBy
  "The date and time when the event was deleted."
  deletedAt: OrderBy
  "The description of the event."
  description: OrderBy
  "The rendering type of this event. Can be auto, block, list-item, background, inverse-background, or none."
  display: OrderBy
  """
  Date object that obeys the current timeZone. When an event ends. It could be null if an end wasn’t specified.
  Note: This value is exclusive. For example, an event with the end of 2018-09-03 will appear to span through 2018-09-02 but end before the start of 2018-09-03. See how events are are parsed from a plain object for further details.
  """
  end: OrderBy
  "An ISO8601 string representation of the end date. If the event is all-day, there will not be a time part."
  endStr: OrderBy
  "Events that share a groupId will be dragged and resized together automatically."
  groupId: OrderBy
  "The unique identifier of the event."
  id: OrderBy
  "The label of the event is used to override the name in the UI."
  label: OrderBy
  "A reference to the line this calendar is linked to"
  lineId: OrderBy
  "The name of the event."
  name: OrderBy
  "A reference to the Event Source this event came from. If the event was added dynamically via addEvent, and the source parameter was not specified, this value will be null."
  sourceId: OrderBy
  "Date object that obeys the current timeZone. When an event begins."
  start: OrderBy
  "An ISO8601 string representation of the start date. If the event is all-day, there will not be a time part."
  startStr: OrderBy
  "The eventTextColor override for this specific event."
  textColor: OrderBy
  "The text that will appear on an event."
  title: OrderBy
  "The date and time when the event was last updated."
  updatedAt: OrderBy
  "A URL that will be visited when this event is clicked by the user. For more information on controlling this behavior, see the eventClick callback."
  url: OrderBy
}
input grid_aggregate_bool_exp {
  bool_and: grid_aggregate_bool_exp_bool_and
  bool_or: grid_aggregate_bool_exp_bool_or
  count: grid_aggregate_bool_exp_count
}
input grid_aggregate_bool_exp_bool_and {
  arguments: grid_select_column_grid_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: GridBoolExp
  predicate: BooleanComparisonExp!
}
input grid_aggregate_bool_exp_bool_or {
  arguments: grid_select_column_grid_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: GridBoolExp
  predicate: BooleanComparisonExp!
}
input grid_aggregate_bool_exp_count {
  arguments: [GridSelectColumn!]
  distinct: Boolean
  filter: GridBoolExp
  predicate: IntComparisonExp!
}
"""
order by avg() on columns of table "grid"
"""
input grid_avg_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by max() on columns of table "grid"
"""
input grid_max_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The date and time when the grid was created."
  createdAt: OrderBy
  "The date and time when the grid was deleted."
  deletedAt: OrderBy
  "The description of the grid."
  description: OrderBy
  "The unique identifier of the grid."
  id: OrderBy
  "The label of the grid is used to override the name in the UI."
  label: OrderBy
  "The name of the grid."
  name: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
  "The studio that the grid belongs to."
  studioId: OrderBy
  "The date and time when the grid was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "grid"
"""
input grid_min_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The date and time when the grid was created."
  createdAt: OrderBy
  "The date and time when the grid was deleted."
  deletedAt: OrderBy
  "The description of the grid."
  description: OrderBy
  "The unique identifier of the grid."
  id: OrderBy
  "The label of the grid is used to override the name in the UI."
  label: OrderBy
  "The name of the grid."
  name: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
  "The studio that the grid belongs to."
  studioId: OrderBy
  "The date and time when the grid was last updated."
  updatedAt: OrderBy
}
input grid_showinfo_aggregate_bool_exp {
  count: grid_showinfo_aggregate_bool_exp_count
}
input grid_showinfo_aggregate_bool_exp_count {
  arguments: [GridShowinfoSelectColumn!]
  distinct: Boolean
  filter: GridShowinfoBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "grid_showinfo"
"""
input grid_showinfo_max_order_by {
  "The date and time when the grid_showinfo was created."
  createdAt: OrderBy
  "The date and time when the grid_showinfo was deleted."
  deletedAt: OrderBy
  "The grid this grid_showinfo is linked to."
  gridId: OrderBy
  "The unique identifier of the grid_showinfo."
  id: OrderBy
  "The showinfo this grid_showinfo is linked to."
  showinfoId: OrderBy
  "The date and time when the grid_showinfo was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "grid_showinfo"
"""
input grid_showinfo_min_order_by {
  "The date and time when the grid_showinfo was created."
  createdAt: OrderBy
  "The date and time when the grid_showinfo was deleted."
  deletedAt: OrderBy
  "The grid this grid_showinfo is linked to."
  gridId: OrderBy
  "The unique identifier of the grid_showinfo."
  id: OrderBy
  "The showinfo this grid_showinfo is linked to."
  showinfoId: OrderBy
  "The date and time when the grid_showinfo was last updated."
  updatedAt: OrderBy
}
"""
order by stddev() on columns of table "grid"
"""
input grid_stddev_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by stddev_pop() on columns of table "grid"
"""
input grid_stddev_pop_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by stddev_samp() on columns of table "grid"
"""
input grid_stddev_samp_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by sum() on columns of table "grid"
"""
input grid_sum_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by var_pop() on columns of table "grid"
"""
input grid_var_pop_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by var_samp() on columns of table "grid"
"""
input grid_var_samp_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
"""
order by variance() on columns of table "grid"
"""
input grid_variance_order_by {
  "The border width of the cards in the grid."
  cardBorderWidth: OrderBy
  "The number of columns in the grid."
  column: OrderBy
  "The position of the grid in the ui."
  position: OrderBy
  "The number of rows in the grid."
  row: OrderBy
  "The padding of the grid slots."
  slotPadding: OrderBy
}
input group_aggregate_bool_exp {
  count: group_aggregate_bool_exp_count
}
input group_aggregate_bool_exp_count {
  arguments: [GroupSelectColumn!]
  distinct: Boolean
  filter: GroupBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "group"
"""
input group_max_order_by {
  "The date and time when the group was created."
  createdAt: OrderBy
  "The date and time when the group was deleted."
  deletedAt: OrderBy
  "The description of the group."
  description: OrderBy
  "The unique identifier of the group."
  id: OrderBy
  "The label of the group is used to override the name in the UI."
  label: OrderBy
  "The logo image path of the group."
  logo: OrderBy
  "The name of the group."
  name: OrderBy
  "The organization id of the group."
  organizationId: OrderBy
  "The parent group of the group."
  parentId: OrderBy
  "The date and time when the group was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "group"
"""
input group_min_order_by {
  "The date and time when the group was created."
  createdAt: OrderBy
  "The date and time when the group was deleted."
  deletedAt: OrderBy
  "The description of the group."
  description: OrderBy
  "The unique identifier of the group."
  id: OrderBy
  "The label of the group is used to override the name in the UI."
  label: OrderBy
  "The logo image path of the group."
  logo: OrderBy
  "The name of the group."
  name: OrderBy
  "The organization id of the group."
  organizationId: OrderBy
  "The parent group of the group."
  parentId: OrderBy
  "The date and time when the group was last updated."
  updatedAt: OrderBy
}
input group_studio_aggregate_bool_exp {
  count: group_studio_aggregate_bool_exp_count
}
input group_studio_aggregate_bool_exp_count {
  arguments: [GroupStudioSelectColumn!]
  distinct: Boolean
  filter: GroupStudioBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "group_studio"
"""
input group_studio_max_order_by {
  "The date and time when the group studio was created."
  createdAt: OrderBy
  "The date and time when the group studio was deleted."
  deletedAt: OrderBy
  "The group of the group studio."
  groupId: OrderBy
  "The studio of the group studio."
  studioId: OrderBy
  "The date and time when the group studio was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "group_studio"
"""
input group_studio_min_order_by {
  "The date and time when the group studio was created."
  createdAt: OrderBy
  "The date and time when the group studio was deleted."
  deletedAt: OrderBy
  "The group of the group studio."
  groupId: OrderBy
  "The studio of the group studio."
  studioId: OrderBy
  "The date and time when the group studio was last updated."
  updatedAt: OrderBy
}
input line_aggregate_bool_exp {
  count: line_aggregate_bool_exp_count
}
input line_aggregate_bool_exp_count {
  arguments: [LineSelectColumn!]
  distinct: Boolean
  filter: LineBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "line"
"""
input line_max_order_by {
  "The date and time when the line was created."
  createdAt: OrderBy
  "The date and time when the line was deleted."
  deletedAt: OrderBy
  "The description of the line."
  description: OrderBy
  "The unique identifier of the line."
  id: OrderBy
  "The label of the line is used to override the name in the UI."
  label: OrderBy
  "The name of the line."
  name: OrderBy
  organizationId: OrderBy
  "The status of the line."
  status: OrderBy
  "The date and time when the line was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "line"
"""
input line_min_order_by {
  "The date and time when the line was created."
  createdAt: OrderBy
  "The date and time when the line was deleted."
  deletedAt: OrderBy
  "The description of the line."
  description: OrderBy
  "The unique identifier of the line."
  id: OrderBy
  "The label of the line is used to override the name in the UI."
  label: OrderBy
  "The name of the line."
  name: OrderBy
  organizationId: OrderBy
  "The status of the line."
  status: OrderBy
  "The date and time when the line was last updated."
  updatedAt: OrderBy
}
input line_studio_aggregate_bool_exp {
  count: line_studio_aggregate_bool_exp_count
}
input line_studio_aggregate_bool_exp_count {
  arguments: [LineStudioSelectColumn!]
  distinct: Boolean
  filter: LineStudioBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "line_studio"
"""
input line_studio_max_order_by {
  "The date and time when the line_studio was created."
  createdAt: OrderBy
  "The date and time when the line_studio was deleted."
  deletedAt: OrderBy
  "The line this line_studio is linked to."
  lineId: OrderBy
  "The studio this line_studio is linked to."
  studioId: OrderBy
  "The date and time when the line_studio was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "line_studio"
"""
input line_studio_min_order_by {
  "The date and time when the line_studio was created."
  createdAt: OrderBy
  "The date and time when the line_studio was deleted."
  deletedAt: OrderBy
  "The line this line_studio is linked to."
  lineId: OrderBy
  "The studio this line_studio is linked to."
  studioId: OrderBy
  "The date and time when the line_studio was last updated."
  updatedAt: OrderBy
}
input phone_aggregate_bool_exp {
  count: phone_aggregate_bool_exp_count
}
input phone_aggregate_bool_exp_count {
  arguments: [PhoneSelectColumn!]
  distinct: Boolean
  filter: PhoneBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "phone"
"""
input phone_max_order_by {
  "The contact that the phone belongs to."
  contactId: OrderBy
  "The date and time when the contact phone was created."
  createdAt: OrderBy
  "The date and time when the contact phone was deleted."
  deletedAt: OrderBy
  "The unique identifier of the contact phone."
  id: OrderBy
  "The phone number of the contact phone."
  number: OrderBy
  "The date and time when the contact phone was last updated."
  updatedAt: OrderBy
  "The date and time when the contact phone was validated."
  validatedAt: OrderBy
}
"""
order by min() on columns of table "phone"
"""
input phone_min_order_by {
  "The contact that the phone belongs to."
  contactId: OrderBy
  "The date and time when the contact phone was created."
  createdAt: OrderBy
  "The date and time when the contact phone was deleted."
  deletedAt: OrderBy
  "The unique identifier of the contact phone."
  id: OrderBy
  "The phone number of the contact phone."
  number: OrderBy
  "The date and time when the contact phone was last updated."
  updatedAt: OrderBy
  "The date and time when the contact phone was validated."
  validatedAt: OrderBy
}
input showinfo_aggregate_bool_exp {
  bool_and: showinfo_aggregate_bool_exp_bool_and
  bool_or: showinfo_aggregate_bool_exp_bool_or
  count: showinfo_aggregate_bool_exp_count
}
input showinfo_aggregate_bool_exp_bool_and {
  arguments: showinfo_select_column_showinfo_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: ShowinfoBoolExp
  predicate: BooleanComparisonExp!
}
input showinfo_aggregate_bool_exp_bool_or {
  arguments: showinfo_select_column_showinfo_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: ShowinfoBoolExp
  predicate: BooleanComparisonExp!
}
input showinfo_aggregate_bool_exp_count {
  arguments: [ShowinfoSelectColumn!]
  distinct: Boolean
  filter: ShowinfoBoolExp
  predicate: IntComparisonExp!
}
"""
order by avg() on columns of table "showinfo"
"""
input showinfo_avg_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by max() on columns of table "showinfo"
"""
input showinfo_max_order_by {
  "The alignment of the text."
  align: OrderBy
  "The background color of the information."
  backgroundColor: OrderBy
  "The color of the text."
  color: OrderBy
  "The date and time when the showinfo was created."
  createdAt: OrderBy
  "The date and time when the showinfo was deleted."
  deletedAt: OrderBy
  "The grid this showinfo is linked to."
  gridId: OrderBy
  "The unique identifier of the showinfo."
  id: OrderBy
  "The name of the information."
  name: OrderBy
  "Javascript path to the information."
  path: OrderBy
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
  "The date and time when the showinfo was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "showinfo"
"""
input showinfo_min_order_by {
  "The alignment of the text."
  align: OrderBy
  "The background color of the information."
  backgroundColor: OrderBy
  "The color of the text."
  color: OrderBy
  "The date and time when the showinfo was created."
  createdAt: OrderBy
  "The date and time when the showinfo was deleted."
  deletedAt: OrderBy
  "The grid this showinfo is linked to."
  gridId: OrderBy
  "The unique identifier of the showinfo."
  id: OrderBy
  "The name of the information."
  name: OrderBy
  "Javascript path to the information."
  path: OrderBy
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
  "The date and time when the showinfo was last updated."
  updatedAt: OrderBy
}
"""
order by stddev() on columns of table "showinfo"
"""
input showinfo_stddev_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by stddev_pop() on columns of table "showinfo"
"""
input showinfo_stddev_pop_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by stddev_samp() on columns of table "showinfo"
"""
input showinfo_stddev_samp_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by sum() on columns of table "showinfo"
"""
input showinfo_sum_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by var_pop() on columns of table "showinfo"
"""
input showinfo_var_pop_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by var_samp() on columns of table "showinfo"
"""
input showinfo_var_samp_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"""
order by variance() on columns of table "showinfo"
"""
input showinfo_variance_order_by {
  "The position of the information."
  position: OrderBy
  "The size of the text."
  size: OrderBy
}
"Call configuration that can be set by the client"
input smartcodec_CallSetup_Input {
  "Array of addresses"
  addresses: [smartcodec_query_lines_items_setup_addresses_items_Input]
  protocol: smartcodec_Protocol_Input
}
"At which speed data flows"
input smartcodec_Datarate_Input {
  name: smartcodec_DatarateName
  "Value from 1 to 1000000000"
  nbOfChannels: Int
}
"Line configuration that can be set by the client"
input smartcodec_LineSetup_Input {
  "Array of addresses"
  addresses: [smartcodec_query_lines_items_setup_addresses_items_Input]
  call: smartcodec_CallSetup_Input
  protocol: smartcodec_Protocol_Input
}
input smartcodec_Protocol_Input {
  datarate: smartcodec_Datarate_Input
  "Protocol name"
  name: String
  samplingrate: smartcodec_Samplingrate
  "How the sound is splited"
  separation: String
  "The service used to cary the data"
  transport: String
}
"Streams"
input smartcodec_Streams_request_Input {
  """
  the location where data will be sent.  Must be network
  accessible by the source server
  """
  callbackUrl: smartcodec_URL
}
input smartcodec_query_lines_items_setup_addresses_items_Input {
  address: smartcodec_query_lines_items_setup_addresses_items_address
  "Value from 1 to 1000"
  addressIdx: Int
}
input studio_aggregate_bool_exp {
  count: studio_aggregate_bool_exp_count
}
input studio_aggregate_bool_exp_count {
  arguments: [StudioSelectColumn!]
  distinct: Boolean
  filter: StudioBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "studio"
"""
input studio_max_order_by {
  "The date and time when the studio was created."
  createdAt: OrderBy
  "The date and time when the studio was deleted."
  deletedAt: OrderBy
  "The description of the studio."
  description: OrderBy
  "The unique identifier of the studio."
  id: OrderBy
  "The label of the studio is used to override the name in the UI."
  label: OrderBy
  "The logo image path of the studio."
  logo: OrderBy
  "The name of the studio."
  name: OrderBy
  "The organization id of the studio."
  organizationId: OrderBy
  "The date and time when the studio was last updated."
  updatedAt: OrderBy
}
"""
order by min() on columns of table "studio"
"""
input studio_min_order_by {
  "The date and time when the studio was created."
  createdAt: OrderBy
  "The date and time when the studio was deleted."
  deletedAt: OrderBy
  "The description of the studio."
  description: OrderBy
  "The unique identifier of the studio."
  id: OrderBy
  "The label of the studio is used to override the name in the UI."
  label: OrderBy
  "The logo image path of the studio."
  logo: OrderBy
  "The name of the studio."
  name: OrderBy
  "The organization id of the studio."
  organizationId: OrderBy
  "The date and time when the studio was last updated."
  updatedAt: OrderBy
}
input user_aggregate_bool_exp {
  bool_and: user_aggregate_bool_exp_bool_and
  bool_or: user_aggregate_bool_exp_bool_or
  count: user_aggregate_bool_exp_count
}
input user_aggregate_bool_exp_bool_and {
  arguments: user_select_column_user_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}
input user_aggregate_bool_exp_bool_or {
  arguments: user_select_column_user_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}
input user_aggregate_bool_exp_count {
  arguments: [UserSelectColumn!]
  distinct: Boolean
  filter: UserBoolExp
  predicate: IntComparisonExp!
}
input user_group_aggregate_bool_exp {
  count: user_group_aggregate_bool_exp_count
}
input user_group_aggregate_bool_exp_count {
  arguments: [UserGroupSelectColumn!]
  distinct: Boolean
  filter: UserGroupBoolExp
  predicate: IntComparisonExp!
}
"""
order by max() on columns of table "user_group"
"""
input user_group_max_order_by {
  "The date and time when the user group was created."
  createdAt: OrderBy
  "The date and time when the user group was deleted."
  deletedAt: OrderBy
  "The group of the user group."
  groupId: OrderBy
  "The date and time when the user group was last updated."
  updatedAt: OrderBy
  "The user of the user group."
  userId: OrderBy
}
"""
order by min() on columns of table "user_group"
"""
input user_group_min_order_by {
  "The date and time when the user group was created."
  createdAt: OrderBy
  "The date and time when the user group was deleted."
  deletedAt: OrderBy
  "The group of the user group."
  groupId: OrderBy
  "The date and time when the user group was last updated."
  updatedAt: OrderBy
  "The user of the user group."
  userId: OrderBy
}
"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  "The date when the user started working."
  beginDate: OrderBy
  "The date and time when the user was created."
  createdAt: OrderBy
  "The date and time when the user was deleted."
  deletedAt: OrderBy
  "The email of the user."
  email: OrderBy
  "The date when the user stopped working."
  endDate: OrderBy
  "The first name of the user."
  firstName: OrderBy
  "The unique identifier of the user."
  id: OrderBy
  "The last name of the user."
  lastName: OrderBy
  "The date and time when the user was last seen."
  lastSeen: OrderBy
  "The organization of the user."
  organizationId: OrderBy
  "The password of the user."
  password: OrderBy
  "The date and time when the user was last updated."
  updatedAt: OrderBy
  "The username of the user."
  username: OrderBy
}
"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  "The date when the user started working."
  beginDate: OrderBy
  "The date and time when the user was created."
  createdAt: OrderBy
  "The date and time when the user was deleted."
  deletedAt: OrderBy
  "The email of the user."
  email: OrderBy
  "The date when the user stopped working."
  endDate: OrderBy
  "The first name of the user."
  firstName: OrderBy
  "The unique identifier of the user."
  id: OrderBy
  "The last name of the user."
  lastName: OrderBy
  "The date and time when the user was last seen."
  lastSeen: OrderBy
  "The organization of the user."
  organizationId: OrderBy
  "The password of the user."
  password: OrderBy
  "The date and time when the user was last updated."
  updatedAt: OrderBy
  "The username of the user."
  username: OrderBy
}
"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "measured in seconds"
    ttl: Int! = 60,
    "refresh the cache entry"
    refresh: Boolean! = false
  ) on QUERY
